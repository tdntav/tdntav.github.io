<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Stringchain is a word game. Replace, add, swap, or delete a letter to make a new word. How long can you make your chain of words?">
    <title>stringchain - word game</title>
    <link rel="icon" href="/favicon.ico">
    <script>window.sa_event=window.sa_event||function(){var a=[].slice.call(arguments);window.sa_event.q?window.sa_event.q.push(a):window.sa_event.q=[a]};</script>
    <style>
        :root {
            --grid-size: 3;       /* will be overwritten by JS */
            --cell-size: 48px;
            --gap: 9px;
            /* --rail-width: ((360 - ((var(--grid-size)*(var(--cell-size)+var(--gap))) + var(--gap)))/2)px; */

            --rail-width: 61.5px;
/* 48, 9, 61.5 */



            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #123;
            --text: #cde;

            --accent: #456;
            --accent-text: #9ab;

            --positive-feedback: #7da;
            --pos-fb-text: var(--bg);

            --negative-feedback: #a77;
            --disabled: #234;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--positive-feedback);
            --selected-text: var(--pos-fb-text);
            --selected-border: 2px solid var(--selected-cell);


        }

        .not-too-light {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #9ab;
            --text: #123;

            --accent: #def;
            --accent-text: #456;

            --positive-feedback: #396;

            --disabled: #789;
            --negative-feedback: #721;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: #fde;
            --selected-text: var(--accent-text);
            --selected-border: 2px solid var(--selected-cell);


        }

        .green-pops {
            --rounding: 18px;
            --rounding-small: 12px;

            --bg: #111;
            --text: #fff;

            --accent: #6c9;
            --accent-text: #000;

            --positive-feedback: #396;

            --disabled: #666;
            --negative-feedback: #721;

            --wordcell: #ccc;
            --wordcell-text: #333;
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: #ea1;
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .winery {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #312;
            --text: #fde;

            --accent: #645;
            --accent-text: #cab;

            --positive-feedback: #5b8;
            --pos-fb-text: var(--bg);

            --disabled: #435;
            --negative-feedback: #500;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--disabled);
            --selected-border: 2px solid var(--selected-cell);

        }

        .tannery {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #fed;
            --text: #321;

            --accent: #cba;
            --accent-text: #654;

            --positive-feedback: #396;

            --negative-feedback: #833;
            --disabled: #a98;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .yello-pops {
            --rounding: 20px;
            --rounding-small: 10px;

            --bg: #111;
            --text: #fff;

            --accent: #ca2;
            --accent-text: #000;

            --positive-feedback: #6c9;

            --disabled: #860;
            --negative-feedback: #800;

            --wordcell: #444;
            --wordcell-text: #fff;
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--accent);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--accent);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .too-light {
            --rounding: 4px;
            --rounding-small: 2px;

            --bg: #fff;
            --text: #666;

            --accent: #eee;
            --accent-text: #555;

            --positive-feedback: #5b8;

            --negative-feedback: #321;
            --disabled: #aaa;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--gridcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);



        }

        .greenery {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #020;
            --text: #dfb;

            --accent: #0c0;
            --accent-text: #000;

            --positive-feedback: #dfb;

            --negative-feedback: #000;
            --disabled: #372;

            --wordcell: #6a5;
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--wordcell-text);
            --gridcell-border: 2px solid var(--gridcell);

            --selected-cell: var(--positive-feedback);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);



        }

        .pinko {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #fdf;
            --text: #606;

            --accent: #faf;
            --accent-text: #606;

            --positive-feedback: #5b8;

            --negative-feedback: #a02;
            --disabled: #a4a;

            --wordcell: #fff;
            --wordcell-text: var(--disabled);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--accent);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--accent);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--text);



            /* --button-border: 3px inset #000; */
        }

        .minimal-animal {
            --rounding: 24px;
            --rounding-small: 12px;

            --bg: #eee;
            --text: #555;

            --accent: #f87;
            --accent-text: #eee;

            --positive-feedback: #0c6;

            --negative-feedback: #000;
            --disabled: #333;

            --wordcell: #999;
            --wordcell-text: var(--bg);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--wordcell-text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--text);



        }

        .minimal-liminal {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #ddd;
            --text: #456;

            --accent: #abc;
            --accent-text: #text;

            --positive-feedback: #7da;

            --negative-feedback: #a66;
            --disabled: #89a;

            --wordcell: #fff;
            --wordcell-text: var(--text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--text);


        }

        .dark-grey {
            --rounding: 2px;
            --rounding-small: 2px;

            --bg: #000;
            --text: #ccc;

            --accent: #777;
            --accent-text: #text;

            --positive-feedback: #5b8;

            --negative-feedback: #c66;
            --disabled: #444;

            --wordcell: var(--accent);
            --wordcell-text: var(--text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--accent);
            --gridcell-text: var(--wordcell-text);
            --gridcell-border: 2px solid var(--accent);

            --selected-cell: var(--bg);
            --selected-text: var(--text);
            --selected-border: 2px solid var(--text);


        }

        .blue-pops {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #033;
            --text: #fff;

            --accent: #2aa;
            --accent-text: var(--bg);

            --positive-feedback: #0ff;

            --negative-feedback: #815;
            --disabled: #477;

            --wordcell: #cff;
            --wordcell-text: var(--bg);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--disabled);

            --selected-cell: #055;
            --selected-text: var(--text);
            --selected-border: 2px solid #0ff;
        }

        .hi-contrast {
            --rounding: 6px;
            --rounding-small: 3px;

            --bg: #101;
            --text: #fff;

            --accent: #a7f;
            --accent-text: var(--bg);

            --positive-feedback: #daf;

            --negative-feedback: #f00;
            --disabled: #645;

            --wordcell: var(--text);
            --wordcell-text: var(--bg);
            --wordcell-border: 2px solid var(--text);

            --gridcell: var(--text);
            --gridcell-text: var(--bg);
            --gridcell-border: 2px solid var(--text);

            --selected-cell: var(--bg);
            --selected-text: var(--positive-feedback);
            --selected-border: 2px solid var(--positive-feedback);
        }

        .fruit-salad {
            --rounding: 26px;
            --rounding-small: 14px;

            --bg: #fef;
            --text: #606;

            --accent: #fab;
            --accent-text: #606;

            --positive-feedback: #adf;

            --disabled: #b8b;
            --negative-feedback: #800;

            --wordcell: var(--accent);
            --wordcell-text: #fff;
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--accent);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--accent-text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        /* END OF THEMES*/

        body {
            font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif;
            background: var(--bg);
            max-width: 400px;
            margin: auto;
            /* margin: 0; */
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            /* padding: 10px; */
            font-size: 20pt;
        }

        h1,
        h3 {
            font-family: "Courier New", monospace;
            margin: 0 0 5px 0;
            text-align: center;
        }

        h4, h5, h6 {
            /* font-family: "Courier New", monospace; */
            margin: 0 0 5px 0;
            text-align: center;
        }

        .scores {
            position: relative;
            padding-block: 10px;
            /* padding-right:22px; */
            font-size: 15pt;
            flex-wrap: wrap;
            text-align: center;
            width: 100%;
            height: 22px;
            font-family: 'Courier New', Courier, monospace;
            z-index: 1;
            /* font-weight: bold; */
            /* background-image: linear-gradient(to top, var(--wordcell), var(--bg)); */
        }

        .message {
            /* position: relative; */
            /* bottom: 2px; */
            font-size: 11pt;
            border-radius: var(--rounding) var(--rounding) 0px 0px;
            font-family: 'Courier New', Courier, monospace;
            flex-wrap: wrap;
            text-align: center;
            color: var(--accent-text);
            height: 66px;
            width: 100%;
            background-image: linear-gradient(to top, var(--bg), var(--accent));
            padding-block: 15px;
            opacity: 75%;
            z-index: -1;
        }

        .scale-wrapper {
            transform: scale(var(--scale-var));
            display: flex;
            /* width:100%; */
            justify-content: center;
            /* overflow: hidden; */
            background: transparent;
            padding: 10px;
            transform-origin: center;
            transition: transform 1s ease;
            border-radius: var(--rounding);
            z-index: 2;
        }

        .word-container {
            transform: scale(var(--scale-var));
            background: transparent;
            display: flex;
            align-items: center;
            /* flex-wrap: wrap; */
            justify-content: center;
            margin-bottom: 10px;
            padding: 2px;
            border-radius: var(--rounding);
        }

        .letter,
        .insert-slot {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--rounding-small);
            text-transform: uppercase;
            cursor: pointer;
            margin: 5px;
            background-color: var(--wordcell);
            color: var(--wordcell-text);
            border: var(--wordcell-border);
        }

        .letter {
            width: 28px;
            height: 60px;
            margin: 3px;
        }

        .insert-slot {
            width: 12px;
            height: 30px;
        }

        .selected {
            border: var(--selected-border);
            color: var(--selected-text);
            background: var(--selected-cell);
            filter: none;
            /* height: 54px; */
        }

        .special {
            background: linear-gradient(var(--bg), var(--accent));
        }
        .special-sauce {
            background: none;
            background-color: none;
        }
        


















.game-area {
  width: 360px;
  margin: 20px 50px 15px;
  box-sizing: border-box;
}

.play-grid-layout {
  display: grid;
  grid-template-columns:
    var(--rail-width)
    /* 0px  */
    auto
    /* var(--gap)  */
    var(--rail-width);
    column-gap: 0px;
/*   
  justify-content: center;
  align-content:center; */
}

/* LETTER GRID (auto-adjusts with JS) */
.grid {
  display: grid;
  grid-template-columns: repeat(var(--grid-size), var(--cell-size));
  grid-template-rows:    repeat(var(--grid-size), var(--cell-size));
  gap: var(--gap);
  justify-content: center;
  align-content:center;
}

/* RAILS (rows match grid) */
.rail {
  display: grid;
  grid-template-rows: repeat(var(--grid-size), var(--cell-size));
  gap: var(--gap);
  width: var(--rail-width);
  margin:none;
  padding:none;
}

/* BUTTONS */
.rail-btn {
  width: 100%;
  height: 100%;
  border: 2px solid var(--accent-text);
  box-sizing: border-box;

  /* margin:none;
  padding:none; */
}

/*spans all rows*/
.rail-btn.span {  
  grid-row: span var(--grid-size);
}

/*spans 2 rows*/
.rail-btn.span-2 {
  grid-row: span 2;
}

/*spans 3 rows*/
.rail-btn.span-3 {
  grid-row: span 3;
}

.rail-btn.span-0 {
  display: none;
}




































/* 
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(12vw, 100vw));
            margin: auto;
            row-gap: 7px;
            column-gap: 10px;
            padding: auto;
        } */


        .grid-cell {
            box-sizing: border-box;
            border: var(--gridcell-border);
            color: var(--gridcell-text);
            width: var(--cell-size);
            /* this also needs to be edited in renderGrid function */
            height: var(--cell-size);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--gridcell);
            border-radius: var(--rounding);
            text-transform: uppercase;
            cursor: pointer;
            font-size: 16pt;
        }

        .grid-cell.used {
            background: transparent;
            cursor: default;
            border: 2px solid transparent;
        }

        .grid-cell.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
        }

        .button-row {
            display: flex;
            gap: 0.5px;
            justify-content: center;
            width: 90%;
            flex-wrap: wrap;
            z-index: 1;
        }




        .button-row button {
            margin: 3px;
            padding: 10px;
            font-family: inherit;
            color: var(--accent-text);
            border-radius: var(--rounding);
            border: 2px solid var(--selected-cell);
            flex: 1 1 30%;
            min-width: 80px;
        }



        


        button {
            background: var(--accent);
            /* margin: 10px 0px; */
            /* padding: 0px 10px; */
            color: var(--accent-text);
            border-radius: var(--rounding);
            /* border: 2px solid var(--accent); */
            border: none;
            margin:none;
            font-size: 11pt;
            height: var(--cell-size);
        } 


        #scrollBtn {
            display: none;
            position: fixed;
            top: 300px;
            align-self: center;
            justify-self: center;
            /* transform: translateY(200px); */
            border-radius: var(--rounding);
            background: var(--wordcell-text);
            color: var(--wordcell);
            margin-top: 15px;
            height: var(--cell-size);
            width: var(--rail-width);
            border: 2px solid var(--wordcell);
            opacity: 50%;
            font-size: 18pt;
            z-index: 99;
        }

        .newgame {
            width: 90%;
            padding: 10px 10px;
            margin:10px 0px;
            display: block;
            background-image: linear-gradient(to right, var(--text), var(--accent), var(--accent-text));
            border: 2px solid var(--accent-text);
            height: var(--cell-size);
        }

        .help {
            border-radius: 23px;
            /* margin: 0.5px; */
            /* border: 2px solid var(--selected-cell); */
            height: 44px;
            width: 44px;
            align-items: center;
            text-align: center;
            margin-block: 0px;
            margin-inline: 4px;
            padding: auto;
        }

        .help-dark {
            border-radius: var(--rounding);
            background: var(--bg);
            color: var(--text);
            margin-top: 15px;
            min-height: 40px;
            min-width: 40px;
            opacity: 50%;
        }

        button:disabled,
        .disabled {
            background: var(--disabled);
            color: var(--accent-text);
            cursor: default;
            border: 2px solid transparent;
            /* filter:blur(1px); */
            /* opacity:67%; */

        }





        #anti-move-wrapper {
            height: 36px;
            /* font-size: 10pt; */
            /* margin: 5px 0; */
            /* color: var(--text); */
            /* text-align: top; */
            align-items: top;
            /* opacity: 45%; */
            padding: auto;
            margin: 0;
            width: 100%;
        }



        #status {
            font-size: 13pt;
            font-family: 'Courier New', Courier, monospace;
            margin: -10px 0px 8px 0px;
            color: var(--accent);
            /* text-align:end; */
            /* align-items: top; */
            /* opacity: 66%; */
            max-height: 6px;
            width:50%;
            text-align:center;
            /* letter-spacing: 0.5em; */
            /* padding-top:-5px; */
            /* margin-top: -15px; */
        }


        #history
        {
            display: block;
            white-space: normal;
            word-wrap: break-word;
            text-align: justify;
            width: 85%;
            min-height: 22px;
            font-size: 12pt;
            font-family: "Courier New", monospace;
            color: var(--accent-text);
            border: 2px solid var(--accent);
            /* box-sizing: border-box; */
            background: var(--accent);
            padding-inline: 2.5%;
            padding-block: 10px;
            margin: 0px;
            border-radius: var(--rounding);
        }


        mark.highlight {
            background: var(--wordcell-text);
            /* text-decoration: underline 3px solid var(--wordcell); */
            color: var(--wordcell);
            /* padding: 4px; */
            border: 2px solid var(--bg);
            border-radius: var(--rounding);
            /* font-weight: bold; */
            /* opacity:75%; */
            transition: font-color text-decoration 5s ease;
        }

        mark.highlight.fade {
            color: transparent;
        }




        #definitions {
            font-size: 10pt;
            color: var(--text);
            margin-bottom: 20px;
            width: 85%;
            background: var(--gridcell);
            color: var(--gridcell-text);
            border: var(--gridcell-border);
            padding-inline: 2.5%;
            padding-block: 10px;
            border-radius: var(--rounding);
            opacity: 66%
        }

        #rules,
        #about {
            background: var(--wordcell);
            padding: 10px;
            margin: 10px;
            /* border-radius: 5px; */

            color: var(--wordcell-text);
            /* width: 80%; */
            font-size: 13px;
        }

        #dropdown {
            background: var(--wordcell);
            padding-block: 20px;
            margin: 0px 10px 0px;
            border-radius: 0 0 var(--rounding) var(--rounding);

            margin: 0px 0px 10px;

            color: var(--wordcell-text);
            width: 100%;
            font-size: 14px;
            text-align: center;
        }

        .high-score-table {
            border: 5px solid;
            border-collapse: collapse;
            border-color: var(--wordcell-text);
            font-size: 9pt;
            margin-inline: auto;


            width: 94%;

        }

        th,
        tr,
        td {
            padding: 8px;
            border: 2px solid;
            border-collapse: collapse;
            border-color: var(--wordcell-text);
            text-align: center;
        }

        .highlight-reel {
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            /* font-size: 9pt; */
            width:auto;
            /* padding:8px; */
            height:10px;
            /* background-image: linear-gradient(to top, var(--word-cell), var(--accent)); */
            /* background: var(--wordcell-text); */
            /* color: var(--wordcell); */
        }

        .demo-div {
            width: 100%;
            background: var(--bg);
            font-size: 22pt;
            border-radius: var(--rounding);
            display: flex;
            flex-direction: column;
            padding-block: 20px;
            /* align-items: center; */
            /* justify-content: center; */
            /* gap: 0rem; */
            /* margin: 0; */
            /* padding: 0; */
            /* box-sizing: border-box; */
            /* height:min-content; */
            /* overflow:unset; */
        }

        .demo-board {
            width: 100%;
            /* transform: scale(1); */
            overflow: hidden;

            transform-origin: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            /* <— don’t vertically center entire board */
            gap: 0rem;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            height: fit-content;
        }

        .demo-para {
            margin-block: 0px;
            /* remove top margin */
            font-size: 10pt;
            color: var(--text);
            text-align: center;
            /* line-height: 1.4; */
        }

        .grid-demo {
            display: grid;
            grid-template-columns: repeat(3, 36px);
            grid-auto-rows: 36px;
            /* Make cells square */
            gap: 7px;
            padding: 5px;
            margin: 20px;
            justify-items: center;
            /* center content in each cell */
            align-items: center;
            /* vertically center */
            justify-content: center;
            /* center entire grid in container */
            align-content: center;
            border-radius: 5px;
        }

        .grid-demo-four {
            display: grid;
            grid-template-columns: repeat(4, 36px);
            grid-auto-rows: 36px;
            /* Make cells square */
            gap: 7px;
            padding: 5px;
            margin: 20px;
            justify-items: center;
            /* center content in each cell */
            align-items: center;
            /* vertically center */
            justify-content: center;
            /* center entire grid in container */
            align-content: center;
            border-radius: 5px;
        }

        .demo {
            justify-content: center;
            align-content: center;
            text-justify: center;
            text-align: center;
            margin: auto;
        }

        .demo-cell {
            cursor: auto;
        }

        .demoscale {
            transform: scale(0.8);
            transform-origin: center;
            overflow: hidden;
        }


        .grid-cell-demo {
            border: var(--gridcell-border);
            color: var(--gridcell-text);
            width: 36px;
            height: 36px;
            font-size: 11pt;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--gridcell);
            border-radius: var(--rounding-small);
            text-transform: uppercase;
            cursor: auto;
        }

        .grid-cell-demo.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
        }

        .grid-cell-demo.used {
            background: var(--bg);
            border: var(--bg);
        }





        .modal {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  /* background-image: linear-gradient(to bottom, var(--accent), var(--bg));   */

  /* Dimming and blur effect */
  background-color: rgba(0, 0, 0, 0.75); /* controls dimming */
  backdrop-filter: blur(3px); /* applies blur to background content */
  -webkit-backdrop-filter: blur(3px); /* Safari support */
}

.modal-content {
    /* background: var(--bg); */
      background-image: linear-gradient(to bottom, var(--accent), var(--bg)); 

    padding:24px;
  border-radius: var(--rounding);
  border:var(--text) solid 4px;
  text-align: center;
  width: 340px;
  /* z-index: 1; */
  /* opacity: unset; */
}

.alpha-grid {
  display: grid;
  /* line-height: 0.1;  */
  grid-template-columns: repeat(7,1fr);
  gap: 5px;
  margin: 20px 0px;
  align-items: center;
            justify-content: center;
}


.alpha-grid button {
  /* padding: 30px 12px; */
  /* font-weight: bold; */
  /* border: 1px solid #ccc; */
  /* border-radius: var(--rounding-small); */
  /* cursor: pointer; */
            border: var(--gridcell-border);
            color: var(--gridcell-text);
            width: var(--cell-size);
            height: var(--cell-size);
            font-size: 18pt;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--gridcell);
            border-radius: var(--rounding-small);
            text-transform: uppercase;
            cursor: auto;
}
.alpha-grid button.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
}











        /* ANIMATIONS AND ANIMATION CLASSES*/

        .anim-pos {
            animation-name: animate-positive;
            animation-duration: 0.5s;
        }

        @keyframes animate-positive {
            0% {
                background-color: var(--positive-feedback);
                border-color: var(--positive-feedback);
                color: var(--bg);
            }

            100% {
                background-color: var(--wordcell);
                border: var(--wordcell-border);
                color: var(--wordcell-text);
            }
        }


        .anim-neg {
            animation-name: animate-negative;
            animation-duration: 1s;
        }

        @keyframes animate-negative {
            0% {
                background-color: var(--negative-feedback);
            }

            100% {
                background-color: var(--bg);
            }
        }


        .anim-bonus {
            animation-name: animate-bonus;
            animation-duration: 0.5s;
        }

        @keyframes animate-bonus {
            0% {
                background-color: var(--positive-feedback);
                transform: scale(75%);
            }

            100% {
                background-color: var(--accent);
                transform: scale(100%);
            }
        }


        .anim-play {
            animation-name: animate-play;
            animation-duration: 0.25s;
        }

        @keyframes animate-play {
            0% {
                transform: scale(75%);
            }

            100% {
                transform: scale(100%);
            }

        }


        .anim-refresh {
            animation-name: animate-refresh;
            animation-duration: 0.5s;
        }

        @keyframes animate-refresh {
            0% {
                /* background-color: var(--positive-feedback); */
                transform: scale(75%);
            }

            100% {
                /* background-color: var(--bg); */
                transform: scale(100%);
            }
        }


        .anim-used {
            animation-name: animate-already-used;
            animation-duration: 5s;
        }

        @keyframes animate-already-used {
            0% {
                background-color: var(--disabled);
            }

            100% {
                background-color: var(--bg);
            }
        }


        .shake {
            animation: shake 0.3s ease;
        }

        @keyframes shake {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            50% {
                transform: translateX(5px);
            }

            75% {
                transform: translateX(-5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        .blur { filter: blur(50%) }
        .hidden { display:none;}
        .opacity-hide { opacity: 0%; }

    </style>
</head>

<body>

    <!-- <div style="height:60px;"><br></div> -->
    <div id="dropdown" style="display:none;">
        <h1>stringchain</h1>

        <div id="highScores"></div>
        <button id="themeToggle" class="help-dark">change</button> <button id="toggle-rules" class="help-dark">HOW TO
            PLAY</button> <button id="aboutBtn" class="help-dark">about</button>
        <div id="rules" style="display: none;">
            <h1>how to play stringchain</h1>
            <h2>PLAYABLE MOVES</h2>

            <div class="demo-div">
                <!-- EXAMPLE 1: SWAP -->
                <div class="demo-board">
                    <p class="demo-para">Swap two <b><i>word</i></b> letters by selecting both.</p>
                    <div class="word-container demoscale">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">M</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Hit the <b><i>PLAY</i></b> button to complete the move.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> 
                        <button class="bonusBtn disabled" style="border:2px solid transparent;">||</button>
                        <button class="actionBtn" style="border:var(--selected-border);">PLAY</button>
                        <button class="shuffleBtn disabled" style="border:2px solid transparent;">#</button>
                        </div> -->

                    <div class="word-container demoscale"
                        style="width:75%;background:var(--positive-feedback);margin-top:20px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">M</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div><br>
            <div class="demo-div">
                <!-- EXAMPLE 2: REARRANGE -->
                <div class="demo-board">
                    <p class="demo-para">Place a <b><i>word</i></b> letter in a <b><i>slot</i></b><br>to rearrange
                        the word.</p>
                    <div class="word-container demoscale" style="margin-top:10px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">M</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">E</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Hit <b><i>PLAY</i></b> to complete the move.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="shuffleBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->
                    <div class="word-container demoscale" style="background:var(--positive-feedback);margin-top:20px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">M</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div>
            <br>
            <div class="demo-div">
                <!-- EXAMPLE 3: DELETE -->
                <div class="demo-board">
                    <p class="demo-para">Select a single <b><i>word</i></b> letter.</p>
                    <div class="word-container demoscale">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">M</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Hit <b><i>PLAY</i></b> to delete it<br>and make a new valid word.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="shuffleBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->

                    <div class="word-container demoscale" style="background:var(--positive-feedback);margin-top:20px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div>

            <p><br>A move can also use a letter from the grid.<br><br></p>


            <div class="demo-div"><!-- EXAMPLE 4: REPLACE -->
                <div class="demo-board">
                    <p class="demo-para">Select a <b><i>word</i></b> letter</p>
                    <div class="word-container demoscale" style="width:100%">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">A</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">and a <b><i>grid</i></b> letter to replace it.</p>
                    <div class="grid-demo">
                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo selected">N</div>

                        <div class="grid-cell-demo">R</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo used"></div>

                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">H</div>
                        <div class="grid-cell-demo">T</div>
                    </div>
                    <p class="demo-para">Hit <b><i>PLAY</i></b> to confirm.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="shuffleBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->
                    <div class="word-container demoscale"
                        style="width:75%;background:var(--positive-feedback);margin-top:20px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div>
            <br>


            <div class="demo-div">
                <!-- EXAMPLE 5: INSERT -->
                <div class="demo-board">
                    <p class="demo-para">Select a <b><i>slot</i></b></p>
                    <div class="word-container demoscale" style="width:100%">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell selected"></div>
                    </div>
                    <p class="demo-para">and a <b><i>grid</i></b> letter to put there</p>


                    <div class="grid-demo">
                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo used"></div>

                        <div class="grid-cell-demo">R</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo used"></div>

                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">H</div>
                        <div class="grid-cell-demo selected">T</div>
                    </div>
                    <p class="demo-para">Engage <b><i>PLAY</i></b> to make it so<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="shuffleBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->

                    <div class="word-container demoscale"
                        style="width:75%;background:var(--positive-feedback);margin-top:20px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div>
            <br>
            <h2>BONUSES</h2>
            <div class="demo-div">
                <!-- EXAMPLE 6: BONUS -->
                <div class="demo-board">
                    <p class="demo-para">A bonus no-penalty setup move is earned<br>for every 5 words
                        added to the chain.<br><br></p>
                    <div class="button-row demo demoscale"> <button class="bonusBtn"
                            style="border:var(--selected-border);">1
                            ||</button><button class="actionBtn disabled"
                            style="border:2px solid transparent;">PLAY</button><button class="shuffleBtn disabled"
                            style="border:2px solid transparent;">#</button></div>
                    <p class="demo-para"><br>To use it, select a move as normal but<br>hit the <b>BONUS ||</b> button
                        instead of <b><i>PLAY</i></b>.
                    </p>
                </div>
            </div>
            <br>
            <div class="demo-div">
                <!-- EXAMPLE 6: REFRESH BUTTON -->
                <div class="demo-board">
                    <p class="demo-para">A free grid refresh bonus is earned<br>for every 30 points (AKA
                        string).<br><br>Play the grid refresh bonus<br>by pressing the # button.<br><br></p>
                    <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn disabled"
                            style="border:2px solid transparent;">PLAY</button><button class="shuffleBtn"
                            style="border:var(--selected-border);"># 1</button></div>
                    <p class="demo-para"><br>Existing grid is replaced with a fresh one.</p>
                    <div class="grid-demo selected" style="background:var(--positive-feedback);border:none;">
                        <div class="grid-cell-demo">A</div>
                        <div class="grid-cell-demo">L</div>
                        <div class="grid-cell-demo">L</div>

                        <div class="grid-cell-demo">N</div>
                        <div class="grid-cell-demo">E</div>
                        <div class="grid-cell-demo">W</div>

                        <div class="grid-cell-demo">N</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">W</div>
                    </div>
                </div>
            </div>
            <br>
            <div class="demo-div">
                <!-- EXAMPLE 8: GRID EXPAND -->
                <div class="demo-board">
                    <div class="word-container demoscale" style="width:110%;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">B</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">L</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">L</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">S</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">Y</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Reach a six letter word once<br>and the grid expands to 4x4.</p>
                    <div class="grid-demo-four selected" style="background:var(--positive-feedback);border:none;">
                        <div class="grid-cell-demo">F</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo">R</div>

                        <div class="grid-cell-demo">F</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo">R</div>

                        <div class="grid-cell-demo">G</div>
                        <div class="grid-cell-demo">R</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo">D</div>

                        <div class="grid-cell-demo">C</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">L</div>
                    </div>

                </div>
            </div>
            <br>
            <h2>GOOD TO KNOW</h2>
            <p style="text-align:left;">If no grid refresh bonus is used, grid letters refresh when a row or column is
                completed.
                <br>
                <br>Attempting to play a previously played word does not incur a penalty.
                <br>
                <br>Words that fail dictionary validation are penalised with increasing severity.
                <br>
                <br>The fifth invalid attempt ends the game. You can see your remaining lives under the current word.
                <br>
                <br>Enjoy!
                <br>
            </p>
        </div>
        <div id="about" style="display: none;">
            <p style="text-align: left;"> <b>ABOUT</b>
                <br>
                <br>Big shoutout to <b><i>dictionaryapi.dev</i></b> and <b><i>wordgamedictionary.com</i></b> for providing free dictionary resources. This is
                the spirit of
                random collaboration that embodies the internet at its best.
                <br>
                <br>Without whoever they are, whoever I am couldn't have made this game for whoever you are.
                <br>
                <br>The internet is awash with bitesize daily puzzles. These are great, but Stringchain is more open-ended and user-driven. 
                Play as much as you want, whenever you want. It's not a subscription, it's not an appointment. You choose when and how much. Take breaks, be healthy.
                <br>
                <br>If you're new to this, you should know it's probably best to start with short malleable words. A new game is a delicate thing, it's too easy to back yourself into a corner and wash out early. 
                I will be addressing this in future updates, as well as adding exciting features to keep the gameplay interesting and help you make the chain as long as you can imagine.
                <br>
                <br>Once you bank some bonuses, you can challenge yourself to play longer words. Your highscores will include a sample of some consecutive words you played. Make yourself presentable.
                <br>
                <br>As the wordlist grows, you may attempt to play a word you already played. 
                Scroll down and see this word highlighted in your word list. 
                Look at the surrounding words to see which nearby words you already used, so you can find your way out of this mess. 
                This highlghting feature allows you to easily pick up where you left off if you are playing over several sessions.
                <br>
                <br>The longer the game goes, the harder it gets. After you've used up all the obvious and convenient short
                words, the game forces you to get creative. 
                <br>
                <br>Get a high score.<br>Beat that high score. <br>Screenshot that high score and challenge your
                friends.<br>Show off your word list. You made that. Look at all the words you know.
                <br>
                <br>I have ideas for future tweaks to game mechanics to incentivise risk-taking, shooting for longer words, making things more exciting. But the core game is in place. Version 1.0. Have at it.
                <br>
                <br>If you enjoy this game, consider buying me a coffee or putting my kids through college.
                <br>
                <br>Word nerd,<br>Dave
            </p>
        </div>




    </div>
    <div class="scores"><span id="score">0</span>&nbsp; <b>string</b><button id="toggle-dropdown"
            class="help toggle-dropdown">+</button><b>chain</b> &nbsp;<span id="chain">0</span></div>
    <div id="anti-move-wrapper">
        <div id="message" class="message"></div>
    </div>
    <div class="scale-wrapper" id="scaleWrapper">
        <div class="word-container" id="wordContainer"></div>
    </div>
    <div id="status">...</div>

    <!-- <div class="button-row">
        <button id="bonusBtn">||</button>
        <button id="actionBtn">PLAY</button>
        <button id="shuffleBtn">#</button>
    </div> -->
    <!-- <div id="message" class="message"></div> -->
<!-- <table class="no-spaces">
    <tr class="no-spaces">
        <td class="button-col">
            <button id="dummyBtn" style="opacity:0%;">?</button>
                <button id="bonusBtn">||</button>
        </td>
        <td style="border:none;margin-top:0px;">
            <div class="grid" id="letterGrid"></div>
        </td>
        <td class="button-col">
            <button id="actionBtn">PLAY</button>
            <button id="shuffleBtn">#</button>
        </td>
    </tr>
</table> -->
<!-- <div id="status">...</div> -->

<div class="game-area"> <!-- Fixed width matching your history area -->

    <div class="play-grid-layout">

        <div class="rail left-rail">
            <button id="dummyBtn1" class="rail-btn span-0" style="opacity:0%;">?</button>
            <button id="bonusBtn" class="rail-btn span-2">||</button>
            <button id="dummyBtn2" class="rail-btn">...</button>
        </div>
<!-- <div></div>             -->
<div class="grid" id="letterGrid"></div>
        <!-- <div></div> -->
        <div class="rail right-rail">
            <button id="actionBtn" class="rail-btn span-2">PLAY</button>
            <button id="dummyBtn3" class="rail-btn span-0" style="opacity:0%;">?</button>
            <button id="shuffleBtn" class="rail-btn">#</button>
            <button id="scrollBtn" class="scrollBtn">^</button>
        </div>

    </div>
</div>
    <div id="history"></div>
    <!-- <div id="disallowed"></div> --> 

                <button id="newGameBtn" class="newgame">RESTART</button>

                        <div id="definitions"></div>
    <!-- <button id="scrollBtn" class="scrollBtn">^</button> -->
    <!-- Asterisk Letter Picker Modal -->
    <div id="asteriskModal" class="modal hidden">
        <div class="modal-content">
          <h6>WILDCARD BONUS</h6>
          <p class="demo-para opacity-hide" style="text-align:left;font-size:13pt;" id="wildcard-1"><br><br>Pick a letter...</p>
          <div class="alpha-grid"></div>
          <p class="demo-para opacity-hide" style="text-align:right;font-size:13pt;" id="wildcard-2">...or save for later with *</p>
          
          <p class="demo-para opacity-hide" style="text-align:justify;" id="wildcard-3">
            <!-- First wildcard bonus when chain reaches 128, another for every additional 32 words. They appear when grid rows and columns are cleared.<br><br> -->
            <br>After 128 words, a wildcard bonus will appear the next time a grid row or column refreshes.
            For every 32 additional words, another wildcard bonus is acquired.</p>
        </div>
    </div>


    <script>

//DECLARATIONS
        const scaleWrapper = document.getElementById('scaleWrapper');
        const wordContainer = document.getElementById('wordContainer');
        const highScoresElement = document.getElementById('highScores');
        const gridElement = document.getElementById('letterGrid');
        const actionBtn = document.getElementById('actionBtn');
        const newGameBtn = document.getElementById('newGameBtn');
        const bonusBtn = document.getElementById('bonusBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const wildcardOne = document.getElementById('wildcard-1');
        const wildcardTwo = document.getElementById('wildcard-2');
        const wildcardThree = document.getElementById('wildcard-3');
        const messageElement = document.getElementById('message');
        const scoreElement = document.getElementById('score');
        const chainElement = document.getElementById('chain');
        const historyElement = document.getElementById('history');
        // const disallowedElement = document.getElementById('disallowed');
        const statusElement = document.getElementById('status');
        const definitionsElement = document.getElementById('definitions');
        const rulesToggle = document.getElementById("toggle-rules");
        const dropdownToggle = document.getElementById("toggle-dropdown");
        const scrollBtn = document.getElementById("scrollBtn");
        const aboutBtn = document.getElementById("aboutBtn");
        const aboutDiv = document.getElementById("about");
        const rulesDiv = document.getElementById("rules");
        const dropdownDiv = document.getElementById("dropdown");
        const disqualified = localStorage.getItem("isDisqualified") === "true";
        const alphabet = "EEEEEEEEEAAAARRRRIIIOOONNSSSTTTLLLLCCUUUDDDPPGGHHBBMMYYFFVVWWKKXJQZ".split("");
        const starterWords = ["ACE", "ACT", "ADD", "ADO", "ADS", "AFT", "AGE", "AGO", "AIR", "ALL", "AND", "ANT", "ANY", "APE", "APT", "ARC", "ARE", "ARK", "ARM", "ART", "ASH", "ASK", "AWE", "AWL", "AXE", "BAD", "BAG", "BAN", "BAR", "BAT", "BAY", "BED", "BEE", "BEG", "BET", "BIG", "BIN", "BIT", "BOA", "BOB", "BOG", "BOP", "BOW", "BOY", "BRA", "BRO", "BUD", "BUG", "BUM", "BUS", "BUT", "BUY", "BYE", "CAB", "CAD", "CAM", "CAN", "CAP", "CAR", "CAT", "CAW", "COB", "COD", "COG", "CON", "COO", "COP", "COT", "COW", "COY", "CRY", "CUB", "CUE", "CUP", "CUR", "CUT", "DAB", "DAD", "DAG", "DAM", "DAY", "DEB", "DEN", "DEW", "DID", "DIE", "DIG", "DIN", "DIP", "DOC", "DOE", "DOG", "DON", "DOT", "DRY", "DUB", "DUD", "DUE", "DUG", "EAR", "EAT", "EEL", "EGG", "EGO", "ELF", "ELL", "EMU", "END", "ERA", "EVE", "EWE", "EYE", "FAD", "FAN", "FAR", "FAT", "FAX", "FED", "FEE", "FEW", "FIB", "FIG", "FIN", "FIR", "FIT", "FLY", "FOE", "FOG", "FOR", "FRY", "FUN", "FUR", "GAG", "GAP", "GAS", "GAY", "GEL", "GEM", "GET", "GIG", "GIN", "GOT", "GUM", "GUN", "GUT", "GUY", "GAP", "HAD", "HAM", "HAS", "HAT", "HAW", "HAY", "HEW", "HEY", "HIM", "HIP", "HIS", "HIT", "HOG", "HOP", "HOT", "HOW", "HUB", "HUE", "HUG", "HUM", "HUT", "ICE", "ILL", "INK", "INN", "ION", "JAB", "JAM", "JAR", "JAW", "JAY", "JAW", "JIG", "JOB", "JOE", "JOG", "JOT", "JOY", "JUG", "KEY", "KIT", "LAB", "LAD", "LAG", "LAP", "LAW", "LAY", "LEA", "LED", "LEG", "LET", "LID", "LIE", "LOG", "LOT", "LOW", "MAD", "MAN", "MAP", "MAT", "MAX", "MAY", "MEN", "MET", "MID", "MIX", "MOB", "MOD", "MOM", "MOP", "MOW", "MUD", "MUG", "MUM", "NAB", "NAP", "NOD", "NOT", "NOW", "NUN", "NUT", "OAR", "OAT", "ODD", "OFF", "OIL", "OLD", "ONE", "OPT", "OUR", "OUT", "OVA", "OWE", "OWL", "OWN", "PAD", "PAL", "PAN", "PAR", "PAT", "PAW", "PAY", "PEG", "PEN", "PET", "PEW", "PHI", "PIE", "PIG", "PIN", "PIT", "PLY", "POD", "POP", "POT", "PRO", "PUB", "PUG", "PUP", "PUT", "RAM", "RAN", "RAP", "RAT", "RAW", "RAY", "RED", "REP", "REV", "RIB", "RID", "RIG", "RIM", "RIP", "ROB", "ROD", "ROE", "ROT", "ROW", "RUB", "RUE", "RUG", "RUN", "RUT", "SAC", "SAD", "SAG", "SAP", "SAT", "SAW", "SAX", "SAY", "SEA", "SEE", "SET", "SEW", "SEX", "SHY", "SIB", "SIC", "SIN", "SIP", "SIR", "SIS", "SIT", "SKY", "SOB", "SOD", "SOL", "SON", "SOP", "SOS", "SOW", "SOX", "SPA", "SPY", "SUB", "SUE", "SUM", "SUN", "SUP", "TAB", "TAD", "TAG", "TAP", "TAR", "TEA", "TEE", "TEN", "THE", "TIE", "TIN", "TIP", "TOE", "TOG", "TON", "TOO", "TOP", "TOT", "TOW", "TOY", "TRY", "TUB", "TUG", "TUX", "TWO", "URN", "USE", "VAN", "VAT", "VET", "VIA", "VIE", "WAR", "WAS", "WAY", "WEB", "WED", "WEE", "WET", "WHO", "WHY", "WIN", "WIT", "WOK", "WON", "WOO", "YAK", "YAM", "YAP", "YAW", "YES", "ABLE", "ACID", "ACRE", "BACK", "BALL", "BAND", "CALM", "CAMP", "CARD", "DAWN", "DAYS", "DEAL", "EACH", "EARN", "ELSE", "FACE", "FACT", "FINE", "GAIN", "GATE", "GAVE", "GIRD", "HAIR", "HALF", "HAND", "ICON", "IDEA", "IDLE", "JACK", "JAIL", "KING", "KIND", "LACK", "LAKE", "LIMP", "MADE", "MAIL", "NAME", "NAIL", "ONCE", "ODDS", "PACK", "PAGE", "RACE", "RAIN", "SAFE", "SAIL", "TAKE", "TALE", "TINE", "UNIT", "URGE", "VARY", "VAST", "WAGE", "WAIT", "YARD", "YARN", "ZAPS"];
        const allowList = [ "FLAP", "FLAPS", "FLAPPING", "FLAPPED", "FLAPPER", "FLAPPERS", "DOLLING", "DOLLED", "TOCK", "HELL", "FEWER", "YOUR", "PATTER", "DRAB", "LIVES", "LIVED", "LIVING", "HELLS", "TOW", "TOWS", "TOWED", "TOWING", "DUNK", "DUNKS", "DUNKING", "DUNKED", "TOW", "TOWS", "TOWING", "TOWED", "TIGHT", "SIFT", "DOSE", "DOSES", "DOSED", "DOSING", "KITE", "KITES", "NET", "CUE", "CUES", "CUED", "CUEING", "CUING", "RAPE", "RAPES", "RAPED", "SATES", "SATED", "SATING", "RAPING", "PEND", "PENDS", "PENDED", "PENDING", "BE", "LOOK", "LOOKS", "LOOKED", "LOOKING", "VEINY", "WEAN", "WEANS", "WEANED", "WEANING"];
        let isActiveGame = true;
        let playedWords = new Set();
        // let disallowedWords = new Set();
        let gameID = "";
        let bonusTicker = '';
        let bonusCounter = 0;
        let currentWord = "";
        let lastValidWord = "";
        let gridSize = 3;
        let grid = [];
        let gridFallback = [];
        let score = 0;
        let chain = 0;
        let selected = [];
        let bonusMovesAvailable = 0;
        let shuffleBonusesAvailable = 0;
        let asteriskEarned = 0; 
        let lastAsteriskThreshold = 0;
        let invalidAttempts = 0;
        let totalPenalty = 0;
        let lastSelectedType = null;
        let lastSelectedCell = null;
        // let lastUsedGridCell = null; // Track last used cell for invalid move rollback
        let specialModeActive = false; // Track bonus special mode
        let LOCAL_WORDS = null;

        async function loadLocalWords() {
            const response = await fetch('assets/merged-wordlists.json');
            const data = await response.json();

            // Flatten all buckets into one Set
            LOCAL_WORDS = new Set(
            Object.values(data).flatMap(list => list)
            );
            console.log(LOCAL_WORDS);
        }
//END OF DELARATIONS

//BUTTONS

        actionBtn.addEventListener('click', () => {
            playAnimation();
            completeMove(true);

        });

        dropdownToggle.addEventListener("click", () => {
            const dropdownHidden = dropdownDiv.style.display === "none";
            dropdownDiv.style.display = dropdownHidden ? "block" : "none";
            dropdownToggle.textContent = dropdownHidden ? "^" : "+";
            getHighScores();
            if (rulesDiv.style.display = "block") {
                rulesDiv.style.display = "none";
                rulesToggle.textContent = "HOW TO PLAY";
            }
            if (aboutDiv.style.display = "block") {
                aboutDiv.style.display = "none";
                aboutBtn.textContent = "about";
            }
            topFunction();
        });

        rulesToggle.addEventListener("click", () => {
            const rulesHidden = rulesDiv.style.display === "none";
            rulesDiv.style.display = rulesHidden ? "block" : "none";
            rulesToggle.textContent = rulesHidden ? "^" : "HOW TO PLAY";
            if (rulesDiv.style.display != "block") { dropdownToggle.click() };
            if (aboutDiv.style.display = "block") {
                aboutDiv.style.display = "none";
                aboutBtn.textContent = "about";
            }
        });

        aboutBtn.addEventListener("click", () => {
            const aboutHidden = aboutDiv.style.display === "none";
            aboutDiv.style.display = aboutHidden ? "block" : "none";
            aboutBtn.textContent = aboutHidden ? "^" : "about";
            if (aboutDiv.style.display != "block") { dropdownToggle.click() };
            if (rulesDiv.style.display = "block") {
                rulesDiv.style.display = "none";
                rulesToggle.textContent = "HOW TO PLAY";
            }
        });

        bonusBtn.addEventListener('click', () => {
            if (bonusMovesAvailable <= 0) {
                messageElement.textContent = "You get a bonus after every 5 words. Click + for guidance.";
                showTemporaryMessage();
                return;
            }
            if (selected.length === 0) {
                messageElement.textContent = "Select a playable move first";
                showTemporaryMessage();
                return;
            }


            let moved = applyMove();
            clearSelection();
            renderWord();
            // replenishGrid(); // MOVED TO THE END
            if (!moved) {
                messageElement.textContent = "Invalid move. Click + for guidance.";
                showTemporaryMessage();
                return;
            }
            bonusMovesAvailable--;
            updateBonusButton();
            bonusCounter++;
            bonusTicker = "||" + bonusCounter;
            playedWords.add(bonusTicker);
            updateHistory();
            bonusTicker = '';
            lastValidWord = currentWord;
            messageElement.innerHTML = `Bonus setup move played.`;
            showTemporaryMessage();
            activateSpecialMode(); //ADDED FOR BONUS MOVE EFFECT
            replenishGrid(); //MOVED TO HERE TO STOP GRID EXPAND FOR SETUP MOVE

            return;
        });

        shuffleBtn.addEventListener('click', () => {
            if (shuffleBonusesAvailable > 0) {
                shuffleBonusesAvailable--;
                bonusCounter++;
                bonusTicker = "#" + bonusCounter;
                playedWords.add(bonusTicker);
                updateHistory();
                bonusTicker = '';
                initGrid();
                updateShuffleButton();
                messageElement.textContent = "Grid refreshed!";
                showTemporaryMessage();                
                letterGrid.classList.add('anim-refresh');
                saveGameState();
                setTimeout(() => {
                    letterGrid.classList.remove('anim-refresh');
                }, 1000);
            }
        });

        newGameBtn.addEventListener('click', () => {

            if (isActiveGame == true && chain >= 5) {
                let text = "Are you sure you want to restart?";
                if (confirm(text) == false) {
                    return;
                }
            }
            sa_event("new_game");
            saveHighScore();
            getHighScores();
            localStorage.removeItem("stringChainState");
            localStorage.removeItem("isDisqualified");
            gameID = new Date().toISOString().slice(0, 19).replace('T', ' ');
            gridSize = 3;
            dummyBtn1.classList.add("span-0");
            dummyBtn3.classList.add("span-0");
            grid = [];
            score = 0;
            chain = 0;
            bonusMovesAvailable = 5;
            shuffleBonusesAvailable = 5;
            asteriskEarned = 0;
            lastAsteriskThreshold = 0;
            invalidAttempts = 0;
            totalPenalty = 0;
            playedWords.clear();
            bonusTicker = '';
            bonusCounter = 0;
            // disallowedWords.clear();
            gridElement.style.pointerEvents = 'auto';
            wordContainer.style.pointerEvents = 'auto';
            scoreElement.textContent = score;
            chainElement.textContent = chain;
            messageElement.textContent = '';
            // disallowedElement.textContent = '';
            updateBonusButton();
            updateShuffleButton();
            definitionsElement.textContent = '';
            specialModeActive = false;
            fitWordContainer();
            isActiveGame = true;
            previousWord = '';
            actionBtn.disabled = false;
            currentWord = randomWord();
            initGrid();
            renderWord();
            validateWord(previousWord);
            updateHistory();
            updateStatus();
            removeAnimation();
            clearSpecialMode();
            loadLocalWords();
            // localStorage.clear(); // FOR HARD RESET TO SEE NEW USER EXPERIENCE
            if (dropdownDiv.style.display = "block") { dropdownToggle.click(); }
        });
//END OF BUTTONS

//ANIMATIONS AND HIGHLIGHTS

        function highlightPlayed(currentWord) {
            historyElement.innerHTML = historyElement.innerHTML.replace(
                new RegExp(currentWord, 'gi'),
                '<mark class="highlight">$&</mark>'
            );

            const newMarks = historyElement.querySelectorAll('mark.highlight:not(.fade)');
            newMarks.forEach(mark => {
                // setTimeout(() => mark.classList.add('fade'), 18000);  // start fade
                setTimeout(() => mark.outerHTML = mark.innerText, 60000); // remove
            });
        }

        function highlightPlayed(currentWord) {
            // Escape any special regex characters in the word
            const safeWord = currentWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            // Match whole word only
            const regex = new RegExp(`\\b${safeWord}\\b`, 'gi');

            // Highlight the word
            historyElement.innerHTML = historyElement.innerHTML.replace(
                regex,
                '<mark class="highlight">$&</mark>'
            );

            // Keep highlight for 60s
            const newMarks = historyElement.querySelectorAll('mark.highlight:not(.fade)');
            newMarks.forEach(mark => {
                setTimeout(() => mark.outerHTML = mark.innerText, 60000);
            });
        }
        function playAnimation() { actionBtn.classList.add('anim-play'); }
        function redAnimation() { wordContainer.classList.add('anim-neg'); }
        function bonusAnimation() { bonusBtn.classList.add('anim-bonus'); }
        function shuffleAnimation() { shuffleBtn.classList.add('anim-bonus'); }
        function alreadyUsedAnimation() {
            wordContainer.classList.add("shake");
            // Remove class after animation so it can trigger again later
            wordContainer.addEventListener("animationend", () => {
                wordContainer.classList.remove("shake");
            }, { once: true });
        }
        function greenAnimation() {
            const elements = wordContainer.querySelectorAll('.letter, .insert-slot');
            const animationDuration = 500; // in ms (0.5s from CSS)
            const stagger = 30; // in ms (0.03s)

            elements.forEach((el, index) => {
                el.classList.remove('anim-pos');
                void el.offsetWidth; // reflow to restart animation

                el.style.animationDelay = `${index * stagger / 1000}s`;
                el.classList.add('anim-pos');

                // Calculate when to remove the class
                const totalDelay = animationDuration + index * stagger;
                setTimeout(() => {
                    el.classList.remove('anim-pos');
                    //   el.style.animationDelay = ''; // optional: clean up inline style
                }, totalDelay);
            });
        }

        function removeAnimation() {
            if (wordContainer.classList.contains('anim-neg')) { wordContainer.classList.remove('anim-neg'); }
            if (wordContainer.classList.contains('anim-pos')) { wordContainer.classList.remove('anim-pos'); }
            if (letterGrid.classList.contains('anim-refresh')) { letterGrid.classList.remove('anim-refresh'); }
            if (bonusBtn.classList.contains('anim-bonus')) { bonusBtn.classList.remove('anim-bonus'); }
            if (shuffleBtn.classList.contains('anim-bonus')) { shuffleBtn.classList.remove('anim-bonus'); }
            if (wordContainer.classList.contains('shake')) { wordContainer.classList.remove('shake'); }
            if (actionBtn.classList.contains('anim-play')) { actionBtn.classList.remove('anim-play'); }

        }

        function activateSpecialMode() {
            specialModeActive = true;
            wordContainer.classList.add('special');
            messageElement.classList.add('special-sauce');
            return;
        }
        function clearSpecialMode() {
            specialModeActive = false;
            wordContainer.classList.remove('special');
            messageElement.classList.remove('special-sauce');
            return;
        }

//END OF ANIMATIONS AND HIGHLIGHTS

//THEMES AND PRESENTATION

        //SCROLLING ETC
        window.onscroll = function () { scrollFunction() };
        function scrollFunction() {
            if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
                scrollBtn.style.display = "block";
            } else {
                scrollBtn.style.display = "none";
            }
        }
        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
            document.body.scrollTop = 0;
            document.documentElement.scrollTop = 0;
        }

        scrollBtn.addEventListener("click", () => {
            topFunction();
            if (dropdownDiv.style.display = "block") { dropdownToggle.click() };
        });
        //END OF SCROLLING ETC

        //THEMES
        const themeToggle = document.getElementById("themeToggle");
        const themes = ["default", "fruit-salad", "hi-contrast", "green-pops", "tannery", "dark-grey", "not-too-light", "winery", "minimal-liminal", "blue-pops", "pinko", "greenery", "minimal-animal", "yello-pops", "too-light"];
        let currentTheme = localStorage.getItem("theme") || "default";
        if (currentTheme !== "default") {
            document.documentElement.classList.add(currentTheme);
        }
        themeToggle.addEventListener("click", () => {
            // Remove current theme if not default
            if (currentTheme !== "default") {
                document.documentElement.classList.remove(currentTheme);
            }

            // Cycle to next theme
            const currentIndex = themes.indexOf(currentTheme);
            const nextIndex = (currentIndex + 1) % themes.length;

            currentTheme = themes[nextIndex];

            // Apply if not default
            if (currentTheme !== "default") {
                document.documentElement.classList.add(currentTheme);
            }

            // Save
            localStorage.setItem("theme", currentTheme);
        });
        //END OF THEMES

        //WORD CONTAINER
        function fitWordContainer() {
            let letterCount = wordContainer.querySelectorAll('.letter').length;
            let scaleCalc = 11 / (6 + letterCount);
            scaleCalc = Math.min(scaleCalc, 1.15);

            document.documentElement.style.setProperty('--scale-var', scaleCalc);
            return;
        }
        //END OF WORD CONTAINER

//END OF THEMES AND PRESENTATION

//SAVING, LOADING, HIGHSCORES

        function saveGameState() {
            const gameState = { isActiveGame, gameID, currentWord, lastValidWord, gridSize, grid, gridFallback, score, chain, bonusMovesAvailable, asteriskEarned, lastAsteriskThreshold, shuffleBonusesAvailable, invalidAttempts, totalPenalty, bonusCounter, playedWords: Array.from(playedWords)
                // , disallowedWords: Array.from(disallowedWords) 
            };
            localStorage.setItem("stringChainState", JSON.stringify(gameState));
        }

        // Load and restore directly
        function loadGameState() {
            // actionBtn.disabled = disqualified; 
            if (disqualified) {
                newGameBtn.click();
                return;
            }
            const saved = localStorage.getItem("stringChainState");
            if (!saved) {
                newGameBtn.click();
                return;
            }

            try {
                ({ isActiveGame, gameID, currentWord, lastValidWord, gridSize, grid, gridFallback, score, chain, bonusMovesAvailable, asteriskEarned, lastAsteriskThreshold, shuffleBonusesAvailable, invalidAttempts, totalPenalty, bonusCounter, playedWords
                    // , disallowedWords 
                } = JSON.parse(saved));
                // disallowedWords = new Set(disallowedWords);
                playedWords = new Set(playedWords);
                renderWord();
                renderGrid();
                updateHistory();
                // updateDisallowedWords();
                updateBonusButton();
                updateShuffleButton();
                showDefinitions(lastValidWord);
                updateStatus();
                loadLocalWords();
                if (gridSize == 3) { dummyBtn1.classList.add("span-0"); dummyBtn3.classList.add("span-0");}
                if (gridSize == 4) { dummyBtn1.classList.remove("span-0"); dummyBtn3.classList.remove("span-0");}
                scoreElement.textContent = score;
                chainElement.textContent = chain;
            } catch (err) {
                console.error("Error loading saved state", err);
                newGameBtn.click();
            }
        }


        
        function saveHighScore() {
            const stringchainHighScore = JSON.parse(localStorage.getItem("stringchainHighScore")) || [];
            const saveTime = new Intl.DateTimeFormat(undefined, {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false // forces 24-hour clock
            })
                .format(new Date())
                .replace(/,/g, ''); // strip commas
            const highlight = getHighlightReel();
            const newHighScore = { saveTime, score, chain, gameID, highlight };

            // Check if an entry already exists for this gameID
            const existingIndex = stringchainHighScore.findIndex(entry => entry.gameID === gameID);

            if (chain < 5) { return };
            if (existingIndex !== -1) {
                // Overwrite the existing record
                stringchainHighScore[existingIndex] = newHighScore;

                // Save and return early
                localStorage.setItem("stringchainHighScore", JSON.stringify(stringchainHighScore));
                return;
            }

            stringchainHighScore.push({
                saveTime: saveTime,
                score: score,
                chain: chain,
                gameID: gameID,
                highlight: highlight
            });
            
            //LOG HIGHSCORE EVENT
            let gameTracker = gameID.replace(/[^\d]/g, '');            
            sa_event(() => 
            `${gameTracker}_${score}_${chain}_${highlight.replace(/ /g, '_')}`
            );

            stringchainHighScore.sort((a, b) => b.score - a.score);

            const byScore = [...stringchainHighScore]
                .sort((a, b) => b.score - a.score)
                .slice(0, 9);
            const byChain = [...stringchainHighScore]
                .sort((a, b) => b.chain - a.chain)
                .slice(0, 9);

            const combined = [...byScore, ...byChain].filter((item, index, self) => index === self.findIndex(g => g.saveTime === item.saveTime));
            combined.sort((a, b) => b.chain - a.chain);
            localStorage.setItem('stringchainHighScore', JSON.stringify(combined));
        }

            function getHighScores() {
                const scoreTableParse = JSON.parse(localStorage.getItem('stringchainHighScore')) || [];
                let scoreTable = scoreTableParse
                scoreTable = scoreTable.filter(entry => !(entry.score === 0 && entry.chain === 0));
                const rows = scoreTable.map(entry => {
                    const highlightRow = entry.highlight && entry.highlight.trim()
                        ? `<tr><td colspan="3" class="highlight-reel">${entry.highlight}</td></tr>`
                        : "";
                    return `<tr><td>${entry.score}</td><td>${entry.chain}</td><td>${entry.saveTime}</td></tr>${highlightRow}`;
                }).join('');

                if (!rows) { return };
                highScoresElement.innerHTML = `<h4>YOUR BEST GAMES</h4><table class = "high-score-table"><tr><th>STRING</th><th>CHAIN</th><th>SAVED</th></tr>${rows}</table>`;
            }



         // >>> FINAL getHighlightReel
            function getHighlightReel() {
                let words = Array.from(playedWords)
                    .filter(w => /^[a-zA-Z]+$/.test(w)) // Exclude entries containing any non-alphabetic character
                    .map(w => w.replace(/[|#*]/g, "").trim());
                if (words.length === 0) return "";

                const longestWordLength = Math.max(...words.map(w => w.length));
                const runs = [];
                let currentRun = [];

                // Find all runs of longest word length
                for (let i = 0; i < words.length; i++) {
                    if (words[i].length === longestWordLength) {
                        currentRun.push(i); // Store the index of the word in the current run
                    } else if (currentRun.length > 0) {
                        runs.push([...currentRun]); // Save the current run
                        currentRun = []; // Reset for the next run
                    }
                }
                if (currentRun.length > 0) {
                    runs.push([...currentRun]); // Add the last run if it exists
                }

                // Find the best run (longest run, or the last one if tied)
                const bestRun = runs.reduce((best, current) => {
                    if (current.length > best.length) return current;
                    if (current.length === best.length) return current; // Use the last run in case of a tie
                    return best;
                }, []);

                // Determine the number of words to display based on the longest word length
                let displayCount;
                if (longestWordLength >= 10) {
                    displayCount = 4;
                } else if (longestWordLength >= 7) {
                    displayCount = 5;
                } else {
                    displayCount = 6;
                }

                // Calculate the slice range based on the best run's length
                let sliceStart, sliceEnd;
                if (bestRun.length >= displayCount) {
                    sliceStart = bestRun[0];
                    sliceEnd = bestRun[0] + displayCount;
                } else {
                    const runStart = bestRun[0];
                    const runEnd = bestRun[bestRun.length - 1];
                    const runLength = bestRun.length;

                    if (runLength === displayCount - 1) {
                        sliceStart = runStart - 1;
                        sliceEnd = runStart + displayCount - 1;
                    } else if (runLength === displayCount - 2) {
                        sliceStart = runStart - 1;
                        sliceEnd = runEnd + 2;
                    } else if (runLength === 1) {
                        sliceStart = runStart - (displayCount - 2);
                        sliceEnd = runStart + 2;
                    } else {
                        sliceStart = runStart - (displayCount - runLength);
                        sliceEnd = runEnd + 1;
                    }

                    // Adjust if no word after the run is available
                    if (sliceEnd > words.length) {
                        const overflow = sliceEnd - words.length;
                        sliceStart = Math.max(0, sliceStart - overflow);
                        sliceEnd = words.length;
                    }
                }

                // Ensure sliceStart and sliceEnd are within bounds
                sliceStart = Math.max(0, sliceStart);
                sliceEnd = Math.min(words.length, sliceEnd);

                return words.slice(sliceStart, sliceEnd).join(" ");
            }               
        // <<< END FINAL







        
//END OF SAVING, LOADING, HIGHSCORES

//CHANGING STATES MESSAGES TEXT
        function updateStatus() {
            let livesLeft = 5 - invalidAttempts;
            // let baseStr = "■ ■ ■ ■ ■"
            // let xStr = "□ □ □ □ □ "
            let baseStr = "| | | | |"
            let xStr = "- - - - - "
            // let base = '<big><big><big>' + xStr.slice(2 * left) + baseStr.slice((2 * invalidAttempts) - 1) + '</big></big></big>';
            let base = '<b>' + xStr.slice(2 * livesLeft) + baseStr.slice(2 * invalidAttempts) + '</b>';
            statusElement.innerHTML = base;
        }

        function updateBonusButton() {
            if (bonusMovesAvailable > 0) {
                bonusBtn.textContent = `${bonusMovesAvailable} ||`;
                bonusBtn.classList.remove('disabled');
                bonusBtn.disabled = false;
            } else {
                bonusBtn.textContent = `||`;
                bonusBtn.classList.add('disabled');
                bonusBtn.disabled = true;
            }
        }

        function updateShuffleButton() {
            if (shuffleBonusesAvailable > 0) {
                shuffleBtn.textContent = `# ${shuffleBonusesAvailable}`;
                shuffleBtn.classList.remove('disabled');
                shuffleBtn.disabled = false;
            } else {
                shuffleBtn.textContent = `#`;
                shuffleBtn.classList.add('disabled');
                shuffleBtn.disabled = true;
            }
        }

        function disableGame() {
            isActiveGame = false;
            localStorage.setItem("isDisqualified", "true");
            actionBtn.disabled = true;
            bonusBtn.disabled = true;
            shuffleBtn.disabled = true;
            gridElement.style.pointerEvents = 'none';
            wordContainer.style.pointerEvents = 'none';
        }

        function showTemporaryMessage(message) {
            messageElement.style.display = "block";
        }

        function updateHistory() {
            historyElement.innerHTML = [...playedWords]
                .reverse()
                .map(w => {
                    // Check if the entry is a bonus and strip the number
                    if (w.startsWith("||")) return "|| ";
                    if (w.startsWith("#")) return "# ";
                    if (w.startsWith("*")) return "* ";
                    
                    // Check if the entry is an incorrect attempt (contains "(")
                    if (w.includes("(")) return `<i>${w}</i> `;
                    
                    // For regular words, append a space
                    return w + " ";
                })
                .join('');
        }

        // function updateDisallowedWords() {
        //     disallowedElement.textContent = [...disallowedWords].reverse().map(w => w + " ").join('');
        // }


        function rollbackGrid() {
            const savedGridState = localStorage.getItem("stringChainState");
            const gridState = JSON.parse(savedGridState);
            grid = gridState.grid;
            gridSize = gridState.gridSize;
            // messageElement.textContent = `GRID ROLLBACK STATE: ${grid}`
            // grid = gridFallback; // ALT VERSION - ALSO NOT WORKING
            // renderGrid();
        }

        function showDefinitions(word) {
            // Fetch up to first 3 definitions and show them
            fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)
                .then(res => res.json())
                .then(data => {
                    if (!Array.isArray(data)) throw new Error();
                    let defs = [];
                    data.forEach(entry => {
                        entry.meanings?.forEach(meaning => {
                            meaning.definitions?.forEach(defObj => {
                                if (defs.length < 3) defs.push(defObj.definition);
                            });
                        });
                    });
                    definitionsElement.innerHTML = defs.length
                        ? `<strong>${word}</strong>:<br>${defs.map(d => `- ${d}`).join('<br>')}`
                        : `No definitions found for "${word}".`;
                })
                .catch(() => {
                    definitionsElement.textContent = `No definitions found for "${word}".`;
                });
        }
//END OF CHANGING STATES


//CORE GAMEPLAY
        function randomLetter() {
            return alphabet[Math.floor(Math.random() * alphabet.length)];
        }

        function randomWord() {
            return starterWords[Math.floor(Math.random() * starterWords.length)];
        }














        const asteriskModal = document.getElementById("asteriskModal");
const alphaGrid = asteriskModal.querySelector(".alpha-grid");

// Close modal if clicking outside content
asteriskModal.addEventListener("click", (e) => {
  if (e.target === asteriskModal) {
    pendingAsteriskCell = null;
    asteriskModal.classList.add("hidden");
  }
});





let pendingAsteriskCell = null; // the cell being replaced

// Build A–Z buttons + one asterisk
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ*?".split("");
letters.forEach(l => {
  const btn = document.createElement("button");
  btn.textContent = l;
  if (l === "?") {
    btn.id = "helpBtn"; // or btn.classList.add("helpBtn");
  }
  btn.addEventListener("click", () => chooseAsteriskLetter(l));
  alphaGrid.appendChild(btn);
});

// Called when a letter is chosen
function chooseAsteriskLetter(letter) {
  if (!pendingAsteriskCell) return;

  if (letter === "*") {
    // Exit: keep the bonus intact
    pendingAsteriskCell = null;
    asteriskModal.classList.add("hidden");
    return;
  }


  if (letter === "?") {
    //show basic instruction
    if ( wildcardOne.classList.contains('opacity-hide') && wildcardThree.classList.contains('opacity-hide') ) {
        wildcardOne.classList.remove('opacity-hide');
        wildcardTwo.classList.remove('opacity-hide');
        helpBtn.classList.add("selected");   // when showing instructions
        return;
    }

        //Show even more info
    if ( wildcardThree.classList.contains('opacity-hide') && !(wildcardOne.classList.contains('opacity-hide')) ) {
        wildcardThree.classList.remove('opacity-hide');
        helpBtn.classList.add("selected");   // when showing instructions
        return;
    }

    // Hide all info if already shown
    if ( !wildcardOne.classList.contains('opacity-hide') && !wildcardThree.classList.contains('opacity-hide') ) {
        wildcardOne.classList.add('opacity-hide');
        wildcardTwo.classList.add('opacity-hide');
        wildcardThree.classList.add('opacity-hide');
        helpBtn.classList.remove("selected");   // when showing instructions
        return;
    }

    // wildcardOne.classList.remove('opacity-hide');
    // wildcardTwo.classList.remove('opacity-hide');
    // wildcardThree.classList.remove('opacity-hide');
    // // alphaGrid.btn.classList.add('selected');
    // return;
  }








  // Replace board asterisk with chosen letter
  const cell = pendingAsteriskCell;
  const r = parseInt(cell.dataset.row, 10);
  const c = parseInt(cell.dataset.col, 10);

  grid[r][c] = letter;
  cell.textContent = letter;
  cell.dataset.type = "grid";

  pendingAsteriskCell = null;
  asteriskModal.classList.add("hidden");
  bonusCounter++;
  bonusTicker = "*" + bonusCounter;
  playedWords.add(bonusTicker);
  updateHistory();
  bonusTicker = '';
  saveGameState();
  // Auto-select this cell after replacement
  selectCell(cell);
}




        // Expose this function for selectCell
        function openAsteriskModal(cell) {
        pendingAsteriskCell = cell;
        asteriskModal.classList.remove("hidden");
        }




        function selectCell(cell) {
            removeAnimation();
            if (!specialModeActive) { messageElement.textContent = "" };




            // --- Handle Asterisk Bonus Early ---
            if (cell.textContent === "*") {
                openAsteriskModal(cell);
                return; // stop here, wait for modal choice
            }




            const type = cell.dataset.type;
            const isSelected = selected.includes(cell);
            // --- Helpers ---
            const getSelectedOfType = (t) => selected.filter(c => c.dataset.type === t);
            const deselect = (c) => {
                c.classList.remove('selected');
                selected = selected.filter(s => s !== c);
            };
            const updateLastSelected = () => {
                if (selected.length === 1) {
                    lastSelectedCell = selected[0];
                    lastSelectedType = lastSelectedCell.dataset.type;
                }
            };
            const dropFirstOf = (t) => deselect(getSelectedOfType(t)[0]);

            // --- Toggle Off ---
            if (isSelected) {
                deselect(cell);
                updateLastSelected();
                return;
            }

            // --- Count current types ---
            let count = {
                word: getSelectedOfType('word').length,
                grid: getSelectedOfType('grid').length,
                insert: getSelectedOfType('insert').length
            };

            // --- Determine legality and resolve conflicts ---
            if (type === 'grid') {
                if (count.grid === 1) {
                    dropFirstOf('grid');
                    // Recalculate counts after change
                    count = {
                        word: getSelectedOfType('word').length,
                        grid: getSelectedOfType('grid').length,
                        insert: getSelectedOfType('insert').length
                    };
                    // Hard early exit from branch logic
                } else if (count.word === 1 && count.insert === 1) {
                    dropFirstOf(lastSelectedType === 'word' ? 'insert' : 'word');
                    // Recalculate counts after change
                    count = {
                        word: getSelectedOfType('word').length,
                        grid: getSelectedOfType('grid').length,
                        insert: getSelectedOfType('insert').length
                    };
                } else if (count.word === 2) {
                    dropFirstOf('word');
                    // Recalculate counts after change
                    count = {
                        word: getSelectedOfType('word').length,
                        grid: getSelectedOfType('grid').length,
                        insert: getSelectedOfType('insert').length
                    };
                }
            }
            else if (type === 'insert') {
                if (count.insert === 1) {
                    dropFirstOf('insert');
                    count = {
                        word: getSelectedOfType('word').length,
                        grid: getSelectedOfType('grid').length,
                        insert: getSelectedOfType('insert').length
                    };
                } else if (count.word === 1 && count.grid === 1) {
                    dropFirstOf(lastSelectedType === 'grid' ? 'word' : 'grid');
                    // Recalculate counts after change
                    count = {
                        word: getSelectedOfType('word').length,
                        grid: getSelectedOfType('grid').length,
                        insert: getSelectedOfType('insert').length
                    };
                } else if (count.word === 2) {
                    dropFirstOf('word');
                    // Recalculate counts after change
                    count = {
                        word: getSelectedOfType('word').length,
                        grid: getSelectedOfType('grid').length,
                        insert: getSelectedOfType('insert').length
                    };
                }
            }
            else if (type === 'word') {
                if (count.word === 2) {
                    dropFirstOf('word');
                    // Recalculate counts after change
                    count = {
                        word: getSelectedOfType('word').length,
                        grid: getSelectedOfType('grid').length,
                        insert: getSelectedOfType('insert').length
                    };
                } else if (count.grid === 1 && count.insert === 1) {
                    dropFirstOf(lastSelectedType === 'grid' ? 'insert' : 'grid');
                    // Recalculate counts after change
                    count = {
                        word: getSelectedOfType('word').length,
                        grid: getSelectedOfType('grid').length,
                        insert: getSelectedOfType('insert').length
                    };
                }
            }

            // --- Limit total selections to 2 ---
            if (selected.length === 2) {
                selected.forEach(c => {
                    if (c !== lastSelectedCell) deselect(c);
                });
            }

            // --- Finalize Selection ---
            cell.classList.add('selected');
            selected.push(cell);
            lastSelectedCell = cell;
            lastSelectedType = type;
        }


        function renderWord() {
            wordContainer.innerHTML = '';

            const insertSlotStart = document.createElement('div');
            insertSlotStart.className = 'insert-slot';
            insertSlotStart.dataset.type = 'insert';
            insertSlotStart.dataset.index = 0;

            insertSlotStart.addEventListener('click', () => selectCell(insertSlotStart));
            wordContainer.appendChild(insertSlotStart);

            for (let i = 0; i < currentWord.length; i++) {
                const letterDiv = document.createElement('div');
                letterDiv.className = 'letter';
                letterDiv.textContent = currentWord[i];
                letterDiv.dataset.type = 'word';
                letterDiv.dataset.index = i;
                // fitWordContainer();

                // Highlight if selected (selected is an array of indices)

                if (selected.includes(i)) {
                    letterDiv.classList.add('selected');
                }

                letterDiv.addEventListener('click', () => selectCell(letterDiv));
                wordContainer.appendChild(letterDiv);

                const insertSlot = document.createElement('div');
                insertSlot.className = 'insert-slot';
                insertSlot.dataset.type = 'insert';
                insertSlot.dataset.index = i + 1;
                // fitWordContainer();


                // if (specialModeActive) insertSlot.classList.add('special');


                if (selected.includes(i + 1)) {
                    insertSlot.classList.add('selected');
                }

                insertSlot.addEventListener('click', () => selectCell(insertSlot));
                wordContainer.appendChild(insertSlot);

            }
            fitWordContainer();
        }

        function renderGrid() {
            // maybePlaceAsterisk();
            gridElement.innerHTML = '';
            // gridElement.style.gridTemplateColumns = `repeat(${gridSize}, 45px)`;
            gridElement.style.gridTemplateColumns = `repeat(${gridSize}, 45px)`;
            // gridElement.style.gridTemplateRows = `repeat(${gridSize}, var(--cell-size)px)`;

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = grid[r][c] || '';

                    // Mark empty cells as 'used' (meaning no letter present)
                    if (!grid[r][c]) cell.classList.add('used');

                    cell.dataset.type = 'grid';
                    cell.dataset.row = r;
                    cell.dataset.col = c;


                    const cellId = `${r},${c}`;
                    if (selected.includes(cellId)) {
                        cell.classList.add('selected');
                    }


                    cell.addEventListener('click', (event) => {
                        if (cell.classList.contains("used")) {
                            event.stopPropagation(); // optional
                            return; // ignore click
                        }
                        selectCell(cell);
                    });
                    gridElement.appendChild(cell);
                }
            }
        }

        function initGrid() {
    for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
            // If cell is not already an asterisk, replace it with a new letter
            if (grid[r] && grid[r][c] === "*" && chain > 0) {
                continue; // keep existing bonus
            }
            if (!grid[r]) grid[r] = [];
            grid[r][c] = randomLetter();
        }
    }
    renderGrid();
    gridFallback = grid;
}

//#region replenishGrid Function working

        // function replenishGrid() {
        //     for (let r = 0; r < gridSize; r++) {
        //         if (grid[r].every(cell => cell === null)) {
        //             for (let c = 0; c < gridSize; c++) {
        //                 grid[r][c] = randomLetter();
        //             }
        //         }
        //     }

        //     for (let c = 0; c < gridSize; c++) {
        //         if (grid.every(row => row[c] === null)) {
        //             for (let r = 0; r < gridSize; r++) {
        //                 grid[r][c] = randomLetter();
        //             }
        //         }
        //     }

        //     if (currentWord.length >= 6 && gridSize === 3 && !specialModeActive) {
        //         const oldGrid = grid.map(row => row.slice()); // copy current 3x3

        //         // Build new 4x4 grid, start as null
        //         const newSize = 4;
        //         const newGrid = Array.from({ length: newSize }, () => Array(newSize).fill(null));

        //         // Preserve existing letters/empties in top-left 3x3
        //         for (let r = 0; r < 3; r++) {
        //             for (let c = 0; c < 3; c++) {
        //                 newGrid[r][c] = oldGrid[r][c]; // may be a letter or null
        //             }
        //         }

        //         // Refresh ONLY the used cells (nulls) inside the original 3x3
        //         for (let r = 0; r < 3; r++) {
        //             for (let c = 0; c < 3; c++) {
        //                 if (newGrid[r][c] === null) {
        //                     newGrid[r][c] = randomLetter();
        //                 }
        //             }
        //         }

        //         // Populate the new right column (c = 3) and bottom row (r = 3)
        //         for (let r = 0; r < 4; r++) newGrid[r][3] = randomLetter();
        //         for (let c = 0; c < 4; c++) newGrid[3][c] = randomLetter();

        //         // Commit expansion
        //         gridSize = 4;
        //         grid = newGrid;
        //     }

        //     renderGrid();
        // }

//#endregion


        // Track earned bonuses

        function checkAsteriskBonus(chain) {
            if (chain >= 128) {
                // Calculate the most recent threshold
                const threshold = 128 + Math.floor((chain - 128) / 32) * 32;
                // const threshold = Math.floor((chain) / 5) * 5; //test mode
                if (threshold > lastAsteriskThreshold) {
                    asteriskEarned++;
                    lastAsteriskThreshold = threshold;
                }
            }
        }

        function maybePlaceAsterisk(refreshedCells) {
            if (asteriskEarned > 0 && refreshedCells.length > 0) {
                const [r, c] = refreshedCells[Math.floor(Math.random() * refreshedCells.length)];
                grid[r][c] = "*";
                asteriskEarned--;
            }
        }

        function replenishGrid() {
            let refreshedCells = [];

            // Refill empty rows
            for (let r = 0; r < gridSize; r++) {
                if (grid[r].every(cell => cell === null)) {
                    for (let c = 0; c < gridSize; c++) {
                        grid[r][c] = randomLetter();
                        refreshedCells.push([r, c]);
                    }
                }
            }

            // Refill empty columns
            for (let c = 0; c < gridSize; c++) {
                if (grid.every(row => row[c] === null)) {
                    for (let r = 0; r < gridSize; r++) {
                        grid[r][c] = randomLetter();
                        refreshedCells.push([r, c]);
                    }
                }
            }

            // Place asterisk if earned
            maybePlaceAsterisk(refreshedCells);

            // Handle 3x3 → 4x4 expansion
            if (currentWord.length >= 6 && gridSize === 3 && !specialModeActive) {
                const oldGrid = grid.map(row => row.slice());
                const newSize = 4;
                const newGrid = Array.from({ length: newSize }, () => Array(newSize).fill(null));

                // Preserve old 3x3
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 3; c++) {
                        newGrid[r][c] = oldGrid[r][c];
                    }
                }

                // Refill used/nulls inside old 3x3
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 3; c++) {
                        if (newGrid[r][c] === null) {
                            newGrid[r][c] = randomLetter();
                            refreshedCells.push([r, c]);
                        }
                    }
                }

                // Populate new row + col
                for (let r = 0; r < 4; r++) {
                    newGrid[r][3] = randomLetter();
                    refreshedCells.push([r, 3]);
                }
                for (let c = 0; c < 4; c++) {
                    newGrid[3][c] = randomLetter();
                    refreshedCells.push([3, c]);
                }

                gridSize = 4;
                grid = newGrid;
                // dummyBtn1.classList.remove("span-0");
                dummyBtn1.classList.remove("span-0");
                dummyBtn3.classList.remove("span-0");

                playedWords.add("(4x4)");
                updateHistory();

                // Place asterisk if earned (again for expansion refresh)
                maybePlaceAsterisk(refreshedCells);
            }
            saveGameState();
            renderGrid();
        }



















        function clearSelection() {
            selected.forEach(s => s.classList.remove('selected'));
            selected = [];
        }


        function applyMove() {
            if (selected.length === 0) return false;
            let moveHappened = false;

            if (selected.length === 1 && selected[0].dataset.type === 'word') {
                const idx = parseInt(selected[0].dataset.index);
                currentWord = currentWord.slice(0, idx) + currentWord.slice(idx + 1);
                moveHappened = true;
            } else if (selected.length === 2) {
                const types = selected.map(s => s.dataset.type);
                if (types.includes('grid') && types.includes('word')) {
                    const gridCell = selected.find(s => s.dataset.type === 'grid');


                    const wordCell = selected.find(s => s.dataset.type === 'word');
                    const idx = parseInt(wordCell.dataset.index);
                    currentWord = currentWord.slice(0, idx) + gridCell.textContent + currentWord.slice(idx + 1);
                    grid[gridCell.dataset.row][gridCell.dataset.col] = null;
                    moveHappened = true;
                } else if (types.every(t => t === 'word')) {
                    const [a, b] = selected.map(s => parseInt(s.dataset.index));
                    let arr = currentWord.split('');
                    [arr[a], arr[b]] = [arr[b], arr[a]];
                    currentWord = arr.join('');
                    moveHappened = true;
                } else if (types.includes('grid') && types.includes('insert')) {
                    const gridCell = selected.find(s => s.dataset.type === 'grid');


                    const insertSlot = selected.find(s => s.dataset.type === 'insert');
                    const pos = parseInt(insertSlot.dataset.index);
                    let arr = currentWord.split('');
                    arr.splice(pos, 0, gridCell.textContent);
                    currentWord = arr.join('');
                    grid[gridCell.dataset.row][gridCell.dataset.col] = null;
                    moveHappened = true;
                } else if (types.includes('word') && types.includes('insert')) {
                    const wordCell = selected.find(s => s.dataset.type === 'word');
                    const insertSlot = selected.find(s => s.dataset.type === 'insert');
                    let fromIdx = parseInt(wordCell.dataset.index);
                    let toIdx = parseInt(insertSlot.dataset.index);
                    if (fromIdx < toIdx) toIdx--;
                    let arr = currentWord.split('');
                    let [char] = arr.splice(fromIdx, 1);
                    arr.splice(toIdx, 0, char);
                    currentWord = arr.join('');
                    moveHappened = true;


                }
            }
            return moveHappened;
        }


        function validateWord(previousWord) {
            const lower = currentWord.toLowerCase();
            if (playedWords.has(lower)) {
                messageElement.textContent = `${currentWord} already used!`;
                highlightPlayed(currentWord);
                alreadyUsedAnimation();
                activateSpecialMode();
                currentWord = previousWord;
                renderWord();
                rollbackGrid();
                // grid = gridFallback;
                // renderGrid();
                showTemporaryMessage();
                saveGameState();
                return;
            }

            if ( 
                starterWords.includes(currentWord.toUpperCase()) || 
                allowList.includes(currentWord.toUpperCase()) ||
                LOCAL_WORDS.has(lower)
            ) {
                playedWords.add(lower);
                updateHistory();
                lastValidWord = currentWord;
                score += currentWord.length;
                chain++;
                checkAsteriskBonus(chain);
                if ((chain % 5 === 0) && chain > 4) {
                    bonusMovesAvailable++;
                    updateBonusButton();
                    bonusAnimation();

                }
                if (Math.floor(score / 30) > Math.floor((score - currentWord.length) / 30) && score > 29) {
                    shuffleBonusesAvailable++;
                    updateShuffleButton();
                    shuffleAnimation();
                }
                scoreElement.textContent = score;
                chainElement.textContent = chain;
                if (chain != 1) { messageElement.textContent = "Valid word!" }; //FROM LOCAL LIST
                showTemporaryMessage();
                clearSpecialMode(); // Nov 4 EDIT
                greenAnimation();
                showDefinitions(lower);
                replenishGrid();
                gridFallback = grid;
                saveGameState();
                return;
            }

            fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${lower}`)
            // fetch(`https://cors.isomorphic-git.org/https://api.dictionaryapi.dev/api/v2/entries/en/${lower}`)
                .then(res => {
                    if (!res.ok) throw new Error();
                    return res.json();
                })
                .then(() => {
                    playedWords.add(lower);
                    updateHistory();
                    lastValidWord = currentWord;
                    score += currentWord.length;
                    chain++;
                    checkAsteriskBonus(chain);
                    if ((chain % 5 === 0) && chain > 4) {
                        bonusMovesAvailable++;
                        updateBonusButton();
                        bonusAnimation();
                    }
                    if (Math.floor(score / 30) > Math.floor((score - currentWord.length) / 30) && score > 29) {
                        shuffleBonusesAvailable++;
                        updateShuffleButton();
                        shuffleAnimation();
                    }
                    scoreElement.textContent = score;
                    chainElement.textContent = chain;
                    messageElement.textContent = "Yes, valid word!";
                    sa_event(() => "api_" + currentWord); //LOG API-VALIDATED WORDS (NOT ON LOCAL LIST)
                    clearSpecialMode(); // SEP 1 EDIT
                    greenAnimation();
                    showDefinitions(lower);
                    replenishGrid();
                    gridFallback = grid;
                    saveGameState();
                    showTemporaryMessage();
                    return;
                })
                .catch(() => {
                    invalidAttempts++;
                    sa_event(() => "invalid_" + currentWord); //LOG INVALID WORDS
                    let penalty = currentWord.length * invalidAttempts;
                    totalPenalty += penalty;
                    score -= penalty;
                    // chain = chain - 1;
                    // disallowedWords.add(lower + `(-${penalty})`);
                    playedWords.add(lower + `(-${penalty})`);
                    updateHistory();
                    messageElement.textContent = `(-${penalty}) ` + currentWord + ` - unknown word.`;
                    currentWord = lastValidWord;
                    renderWord();
                    rollbackGrid();
                    // grid = gridFallback;
                    // renderGrid();
                    updateBonusButton();
                    updateShuffleButton();
                    redAnimation();
                    

                    if (invalidAttempts >= 5) {
                        messageElement.textContent += " - and you're out of lives!";
                        saveHighScore();
                        disableGame();
                        saveGameState();
                    }
                    scoreElement.textContent = score;
                    chainElement.textContent = chain;

                    updateStatus();
                    // updateDisallowedWords();
                    saveGameState();
                    showTemporaryMessage();
                });
        }

        function completeMove(validate = true) {
            let originalWord = currentWord;
            let moved = applyMove();
            clearSelection();
            renderWord();
            if (!moved) {
                messageElement.textContent = "Not a valid move. Click + for guidance"; //MAX 42 chars
                showTemporaryMessage();
                return;
            }
            if (validate) validateWord(originalWord);
            // clearSpecialMode();
            // replenishGrid();
        }
//END OF CORE GAMEPLAY
        loadGameState();
        



    </script>


<script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>

</html>
