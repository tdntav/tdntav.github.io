<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Stringchain is a word game. Replace, add, swap, or delete a letter to make a new word. How long can you make your chain of words?">
    <title>stringchain - word game</title>
    <link rel="icon" href="/favicon.ico">
    <script>window.sa_event = window.sa_event || function () { var a = [].slice.call(arguments); window.sa_event.q ? window.sa_event.q.push(a) : window.sa_event.q = [a] };</script>
    <style>
        :root {
            --grid-size: 3;
            /* will be overwritten by JS */
            --cell-size: 48px;
            --gap: 9px;
            /* --rail-width: ((360 - ((var(--grid-size)*(var(--cell-size)+var(--gap))) + var(--gap)))/2)px; */

            --rail-width: 67.5px;
            /* 48, 9, 61.5 */



            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #123;
            --text: #cde;

            --accent: #456;
            --accent-text: #9ab;

            --positive-feedback: #7da;
            --pos-fb-text: var(--bg);

            --negative-feedback: #a77;
            --disabled: #234;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--positive-feedback);
            --selected-text: var(--pos-fb-text);
            --selected-border: 2px solid var(--selected-cell);


        }

        .not-too-light {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #9ab;
            --text: #123;

            --accent: #def;
            --accent-text: #456;

            --positive-feedback: #396;

            --disabled: #789;
            --negative-feedback: #721;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: #fde;
            --selected-text: var(--accent-text);
            --selected-border: 2px solid var(--selected-cell);


        }

        .green-pops {
            --rounding: 18px;
            --rounding-small: 12px;

            --bg: #111;
            --text: #fff;

            --accent: #6c9;
            --accent-text: #000;

            --positive-feedback: #396;

            --disabled: #666;
            --negative-feedback: #721;

            --wordcell: #ccc;
            --wordcell-text: #333;
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: #ea1;
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .winery {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #312;
            --text: #fde;

            --accent: #645;
            --accent-text: #cab;

            --positive-feedback: #5b8;
            --pos-fb-text: var(--bg);

            --disabled: #435;
            --negative-feedback: #500;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--disabled);
            --selected-border: 2px solid var(--selected-cell);

        }

        .tannery {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #fed;
            --text: #321;

            --accent: #cba;
            --accent-text: #654;

            --positive-feedback: #396;

            --negative-feedback: #833;
            --disabled: #a98;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .yello-pops {
            --rounding: 20px;
            --rounding-small: 10px;

            --bg: #111;
            --text: #fff;

            --accent: #ca2;
            --accent-text: #000;

            --positive-feedback: #6c9;

            --disabled: #860;
            --negative-feedback: #800;

            --wordcell: #444;
            --wordcell-text: #fff;
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--accent);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--accent);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .too-light {
            --rounding: 4px;
            --rounding-small: 2px;

            --bg: #fff;
            --text: #666;

            --accent: #eee;
            --accent-text: #555;

            --positive-feedback: #5b8;

            --negative-feedback: #321;
            --disabled: #aaa;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--gridcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);



        }

        .greenery {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #020;
            --text: #dfb;

            --accent: #0c0;
            --accent-text: #000;

            --positive-feedback: #dfb;

            --negative-feedback: #000;
            --disabled: #372;

            --wordcell: #6a5;
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--wordcell-text);
            --gridcell-border: 2px solid var(--gridcell);

            --selected-cell: var(--positive-feedback);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);



        }

        .pinko {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #fdf;
            --text: #606;

            --accent: #faf;
            --accent-text: #606;

            --positive-feedback: #5b8;

            --negative-feedback: #a02;
            --disabled: #a4a;

            --wordcell: #fff;
            --wordcell-text: var(--disabled);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--accent);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--accent);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--text);



            /* --button-border: 3px inset #000; */
        }

        .minimal-animal {
            --rounding: 24px;
            --rounding-small: 12px;

            --bg: #eee;
            --text: #555;

            --accent: #f87;
            --accent-text: #eee;

            --positive-feedback: #0c6;

            --negative-feedback: #000;
            --disabled: #333;

            --wordcell: #999;
            --wordcell-text: var(--bg);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--wordcell-text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--text);



        }

        .minimal-liminal {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #ddd;
            --text: #456;

            --accent: #abc;
            --accent-text: #text;

            --positive-feedback: #7da;

            --negative-feedback: #a66;
            --disabled: #89a;

            --wordcell: #fff;
            --wordcell-text: var(--text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--text);


        }

        .dark-grey {
            --rounding: 2px;
            --rounding-small: 2px;

            --bg: #000;
            --text: #ccc;

            --accent: #777;
            --accent-text: #text;

            --positive-feedback: #5b8;

            --negative-feedback: #c66;
            --disabled: #444;

            --wordcell: var(--accent);
            --wordcell-text: var(--text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--accent);
            --gridcell-text: var(--wordcell-text);
            --gridcell-border: 2px solid var(--accent);

            --selected-cell: var(--bg);
            --selected-text: var(--text);
            --selected-border: 2px solid var(--text);


        }

        .blue-pops {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #033;
            --text: #fff;

            --accent: #2aa;
            --accent-text: var(--bg);

            --positive-feedback: #0ff;

            --negative-feedback: #815;
            --disabled: #477;

            --wordcell: #cff;
            --wordcell-text: var(--bg);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--disabled);

            --selected-cell: #055;
            --selected-text: var(--text);
            --selected-border: 2px solid #0ff;
        }

        .hi-contrast {
            --rounding: 6px;
            --rounding-small: 3px;

            --bg: #101;
            --text: #fff;

            --accent: #a7f;
            --accent-text: var(--bg);

            --positive-feedback: #daf;

            --negative-feedback: #f00;
            --disabled: #645;

            --wordcell: var(--text);
            --wordcell-text: var(--bg);
            --wordcell-border: 2px solid var(--text);

            --gridcell: var(--text);
            --gridcell-text: var(--bg);
            --gridcell-border: 2px solid var(--text);

            --selected-cell: var(--bg);
            --selected-text: var(--positive-feedback);
            --selected-border: 2px solid var(--positive-feedback);
        }

        .fruit-salad {
            --rounding: 26px;
            --rounding-small: 14px;

            --bg: #fef;
            --text: #606;

            --accent: #fab;
            --accent-text: #606;

            --positive-feedback: #adf;

            --disabled: #b8b;
            --negative-feedback: #800;

            --wordcell: var(--accent);
            --wordcell-text: #fff;
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--accent);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--accent-text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        /* END OF THEMES*/
        html, body { overflow-x: hidden;
            /* height: 100%; */
        }

        body {
            font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif;
            background: var(--bg);
            max-width: 400px;
            margin: auto;
            /* margin: 0; */
            /* overflow-x: hidden; */
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            /* padding: 10px; */
            font-size: 20pt;
        }

        h1,
        h3 {
            font-family: "Courier New", monospace;
            margin: 0 0 5px 0;
            text-align: center;
        }

        h4,
        h5,
        h6 {
            /* font-family: "Courier New", monospace; */
            margin: 0 0 5px 0;
            text-align: center;
        }

        .scores {
            position: relative;
            padding-block: 10px;
            /* padding-right:22px; */
            font-size: 15pt;
            flex-wrap: wrap;
            text-align: center;
            width: 100%;
            height: 22px;
            font-family: 'Courier New', Courier, monospace;
            z-index: 1;
            /* font-weight: bold; */
            /* background-image: linear-gradient(to top, var(--wordcell), var(--bg)); */
        }

        .message {
            /* position: relative; */
            /* bottom: 2px; */
            font-size: 11pt;
            border-radius: var(--rounding) var(--rounding) 0px 0px;
            font-family: 'Courier New', Courier, monospace;
            flex-wrap: wrap;
            text-align: center;
            color: var(--text);
            height: 66px;
            width: 100%;
            background-image: linear-gradient(to top, var(--bg), var(--accent));
            padding-block: 15px;
            opacity: 75%;
            z-index: -1;
        }

        .scale-wrapper {
            transform: scale(var(--scale-var));
            object-fit: contain;
            display: flex;
            width:100%;
            justify-content: center;
            /* overflow: hidden; */
            background: transparent;
            padding: 10px;
            transform-origin: center;
            transition: transform 1s ease;
            border-radius: var(--rounding);
            z-index: 2;
        }

        .word-container {
            /* transform: scale(var(--scale-var)); */
            background: transparent;
            display: flex;
            align-items: center;
            /* flex-wrap: wrap; */
            justify-content: center;
            margin-bottom: 10px;
            padding: 2px;
            border-radius: var(--rounding);
        }

        .letter,
        .insert-slot {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--rounding-small);
            text-transform: uppercase;
            cursor: pointer;
            margin: 5px;
            background-color: var(--wordcell);
            color: var(--wordcell-text);
            border: var(--wordcell-border);
        }

        .letter {
            width: 28px;
            height: 60px;
            margin: 3px;
        }

        .insert-slot {
            width: 12px;
            height: 30px;
        }

        .selected {
            animation-name: animate-selected;
            animation-duration: 0.2s;
            /* animation-timing-function: ease-out; */
            border: var(--selected-border);
            color: var(--selected-text);
            background: var(--selected-cell);
            filter: none;
        }

        @keyframes animate-selected {
            0% {
                transform: scaleY(0%);
            }

            100% {
                transform: scaleY(100%);
            }
        }

        .special {
            background: linear-gradient(var(--bg), var(--accent));
        }

        .special-sauce {
            background: none;
            background-color: none;
        }



















        .game-area {
            width: 360px;
            margin: 20px 50px 15px;
            box-sizing: border-box;
        }

        .play-grid-layout {
            display: grid;
            grid-template-columns:
                63.5px /* rail-width minus 4px*/
                /* 0px  */
                auto
                /* var(--gap)  */
                var(--rail-width);
            column-gap: 0px;
            /*   
  justify-content: center;
  align-content:center; */
        }

        /* LETTER GRID (auto-adjusts with JS) */
        .grid {
            display: grid;
            /* box-sizing: border-box; */
            grid-template-columns: repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: var(--gap);
            justify-content: center;
            align-content: center;
        }

        /* RAILS (rows match grid) */
        .rail {
            display: grid;
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: var(--gap);
            width: var(--rail-width);
            margin: none;
            padding: none;
        }

        /* BUTTONS */
        .rail-btn {
            width: 100%;
            height: 100%;
            border: none;
            margin: none;
            /* border: var(--gridcell-border); */
            color: var(--accent-text);
            box-sizing: border-box;
            background: var(--accent);

            /* margin:none;
  padding:none; */
        }

        /*spans all rows*/
        .rail-btn.span {
            grid-row: span var(--grid-size);
        }

        /*spans 2 rows*/
        .rail-btn.span-2 {
            grid-row: span 2;
        }

        /*spans 3 rows*/
        .rail-btn.span-3 {
            grid-row: span 3;
        }

        .rail-btn.span-0 {
            display: none;
        }




































        /* 
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(12vw, 100vw));
            margin: auto;
            row-gap: 7px;
            column-gap: 10px;
            padding: auto;
        } */


        .grid-cell {
            box-sizing: border-box;
            border: var(--gridcell-border);
            color: var(--gridcell-text);
            width: var(--cell-size);
            /* this also needs to be edited in renderGrid function */
            height: var(--cell-size);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--gridcell);
            border-radius: var(--rounding);
            text-transform: uppercase;
            cursor: pointer;
            font-size: 16pt;
        }

        .grid-cell.used {
            background: transparent;
            cursor: default;
            border: 2px solid transparent;
        }

        .grid-cell.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
        }

        .button-row {
            display: flex;
            gap: 0.5px;
            justify-content: center;
            width: 90%;
            flex-wrap: wrap;
            z-index: 1;
        }




        .button-row button {
            margin: 3px;
            padding: 10px;
            font-family: inherit;
            color: var(--accent-text);
            border-radius: var(--rounding);
            border: 2px solid var(--selected-cell);
            flex: 1 1 30%;
            min-width: 80px;
        }






        button {
            background: var(--accent);
            /* margin: 10px 0px; */
            /* padding: 0px 10px; */
            color: var(--accent-text);
            border-radius: var(--rounding);
            /* border: 2px solid var(--accent); */
            border: none;
            margin: none;
            font-size: 11pt;
            height: var(--cell-size);
        }


        #scrollBtn {
            display: none;
            position: fixed;
            top: 300px;
            align-self: center;
            justify-self: center;
            /* transform: translateY(200px); */
            border-radius: var(--rounding);
            background: var(--wordcell-text);
            color: var(--wordcell);
            margin-top: 15px;
            height: var(--cell-size);
            width: var(--rail-width);
            border: 2px solid var(--wordcell);
            opacity: 50%;
            font-size: 18pt;
            z-index: 99;
        }

        .newgame {
            width: 90%;
            padding: 10px 10px;
            margin: 10px 0px;
            display: block;
            background-image: linear-gradient(to right, var(--text), var(--accent), var(--accent-text));
            border: 2px solid var(--accent-text);
            height: var(--cell-size);
        }

        .help {
            border-radius: 23px;
            /* margin: 0.5px; */
            /* border: 2px solid var(--selected-cell); */
            height: 44px;
            width: 44px;
            align-items: center;
            text-align: center;
            margin-block: 0px;
            margin-inline: 4px;
            padding: auto;
        }

        .help-dark {
            border-radius: var(--rounding);
            background: var(--bg);
            color: var(--text);
            margin-top: 15px;
            min-height: 40px;
            min-width: 40px;
            opacity: 50%;
        }

        button:disabled,
        .disabled {
            background: var(--disabled);
            color: var(--accent-text);
            cursor: default;
            border: 2px solid transparent;
            /* filter:blur(1px); */
            /* opacity:67%; */

        }





        #anti-move-wrapper {
            height: 36px;
            /* font-size: 10pt; */
            /* margin: 5px 0; */
            /* color: var(--text); */
            /* text-align: top; */
            align-items: top;
            /* opacity: 45%; */
            padding: auto;
            margin: 0;
            width: 100%;
        }



        #status {
            font-size: 13pt;
            font-family: 'Courier New', Courier, monospace;
            margin: -10px 0px 8px 0px;
            color: var(--accent);
            /* text-align:end; */
            /* align-items: top; */
            /* opacity: 66%; */
            max-height: 6px;
            width: 100%;
            text-align: center;
            /* letter-spacing: 0.5em; */
            /* padding-top:-5px; */
            /* margin-top: -15px; */
        }


        #history {
            display: block;
            white-space: normal;
            word-wrap: break-word;
            text-align: justify;
            width: 85%;
            min-height: 22px;
            font-size: 12pt;
            font-family: "Courier New", monospace;
            color: var(--accent-text);
            border: 2px solid var(--accent);
            /* box-sizing: border-box; */
            background: var(--accent);
            padding-inline: 2.5%;
            padding-block: 10px;
            margin: 0px;
            border-radius: var(--rounding);
        }


        mark.highlight {
            background: var(--wordcell-text);
            /* text-decoration: underline 3px solid var(--wordcell); */
            color: var(--wordcell);
            /* padding: 4px; */
            border: 2px solid var(--bg);
            border-radius: var(--rounding);
            /* font-weight: bold; */
            /* opacity:75%; */
            transition: font-color text-decoration 5s ease;
        }

        mark.highlight.fade {
            color: transparent;
        }




        #definitions {
            font-size: 10pt;
            color: var(--text);
            margin-bottom: 20px;
            width: 85%;
            background: var(--gridcell);
            color: var(--gridcell-text);
            border: var(--gridcell-border);
            padding-inline: 2.5%;
            padding-block: 10px;
            border-radius: var(--rounding);
            opacity: 66%
        }

        #rules,
        #about {
            background: var(--wordcell);
            padding: 10px;
            margin: 10px;
            /* border-radius: 5px; */

            color: var(--wordcell-text);
            /* width: 80%; */
            font-size: 15px;
        }

        #dropdown {
            background: var(--wordcell);
            padding-block: 20px;
            margin: 0px 10px 0px;
            border-radius: 0 0 var(--rounding) var(--rounding);

            margin: 0px 0px 10px;

            color: var(--wordcell-text);
            width: 100%;
            font-size: 14px;
            text-align: center;
        }

        .high-score-table {
            border: 5px solid;
            border-collapse: collapse;
            border-color: var(--wordcell-text);
            font-size: 11pt;
            margin-inline: auto;


            width: 94%;

        }

        th,
        tr,
        td {
            padding: 8px;
            border: 2px solid;
            border-collapse: collapse;
            border-color: var(--wordcell-text);
            text-align: center;
        }

        .highlight-reel {
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            /* font-size: 9pt; */
            width: auto;
            /* padding:8px; */
            height: 10px;
            /* background-image: linear-gradient(to top, var(--word-cell), var(--accent)); */
            /* background: var(--wordcell-text); */
            /* color: var(--wordcell); */
        }

        .demo-div {
            width: 100%;
            background: var(--bg);
            font-size: 22pt;
            border-radius: var(--rounding);
            display: flex;
            flex-direction: column;
            padding-block: 20px;
            /* align-items: center; */
            /* justify-content: center; */
            /* gap: 0rem; */
            /* margin: 0; */
            /* padding: 0; */
            /* box-sizing: border-box; */
            /* height:min-content; */
            /* overflow:unset; */
        }

        .demo-board {
            width: 100%;
            /* transform: scale(1); */
            overflow: hidden;

            transform-origin: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            /* <— don’t vertically center entire board */
            gap: 0rem;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            height: fit-content;
        }

        .demo-para {
            margin-block: 0px;
            /* remove top margin */
            font-size: 10pt;
            color: var(--text);
            text-align: center;
            /* line-height: 1.4; */
        }

        .grid-demo {
            display: grid;
            grid-template-columns: repeat(3, 36px);
            grid-auto-rows: 36px;
            /* Make cells square */
            gap: 7px;
            padding: 5px;
            margin: 20px;
            justify-items: center;
            /* center content in each cell */
            align-items: center;
            /* vertically center */
            justify-content: center;
            /* center entire grid in container */
            align-content: center;
            border-radius: 5px;
        }

        .grid-demo-four {
            display: grid;
            grid-template-columns: repeat(4, 36px);
            grid-auto-rows: 36px;
            /* Make cells square */
            gap: 7px;
            padding: 5px;
            margin: 20px;
            justify-items: center;
            /* center content in each cell */
            align-items: center;
            /* vertically center */
            justify-content: center;
            /* center entire grid in container */
            align-content: center;
            border-radius: 5px;
        }

        .demo {
            justify-content: center;
            align-content: center;
            text-justify: center;
            text-align: center;
            margin: auto;
        }

        .demo-cell {
            cursor: auto;
        }

        .demoscale {
            transform: scale(0.8);
            transform-origin: center;
            overflow: hidden;
        }


        .grid-cell-demo {
            border: var(--gridcell-border);
            color: var(--gridcell-text);
            width: 36px;
            height: 36px;
            font-size: 11pt;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--gridcell);
            border-radius: var(--rounding-small);
            text-transform: uppercase;
            cursor: auto;
        }

        .grid-cell-demo.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
        }

        .grid-cell-demo.used {
            background: var(--bg);
            border: var(--bg);
        }


        .modal {
            position: fixed;
            top: 0px;
            left: 0;
            /* bottom: -500px; */
            width: 100vw;
            height: 100dvh; 
            
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;

            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }

/* 
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        } */

        .modal-content-1 {
            background: var(--accent);
            color: var(--accent-text);
            /* background-image: linear-gradient(to bottom, var(--accent), var(--bg));  */

            padding-block: 12px;
            padding-inline:0px;
            border-radius: var(--rounding);
            border: var(--accent) solid 2px;
            text-align: center;
            /* overflow-y:scroll; */

            /* CHANGE 1: Remove scrolling from here */
            overflow-y: hidden; 
            
            /* CHANGE 2: Use flexbox to organize the header and scroll area */
            display: flex;
            flex-direction: column;
            max-height: 80vh;
            width: 400px;
            /* z-index: 1; */
            /* opacity: unset; */
        }

        .modal-content-2 {
            background: var(--accent);
            color: var(--accent-text);
            /* background-image: linear-gradient(to bottom, var(--accent), var(--bg));  */

            padding-block: 12px;
            padding-inline:30px;
            border-radius: var(--rounding);
            border: var(--bg) solid 2px;
            text-align: center;
            /* overflow-y:scroll; */

            /* CHANGE 1: Remove scrolling from here */
            overflow:hidden;
            
            /* CHANGE 2: Use flexbox to organize the header and scroll area */
            display: flex;
            flex-direction: column;
            max-height: 80vh;
            width: 340px;
            /* z-index: 1; */
            /* opacity: unset; */
        }



        .milestones-1 {
            background: var(--bg);
            color: var(--text);
            font-size: 12pt;
            overflow-y: auto; 
            padding-inline: auto;
            border-radius: var(--rounding);
        }



        .sq-word {
            font-size: 15pt;
            font-family: "Courier New", monospace;
        }

        .sq-para {
            font-size: 12pt;
        }

        /* #streakinfo {
            margin-top:10px;
            font-size: 9pt;
        } */


        .alpha-grid {
            display: grid;
            /* line-height: 0.1;  */
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin: 20px 0px;
            align-items: center;
            justify-content: center;
        }


        .alpha-grid button {
            /* padding: 30px 12px; */
            /* font-weight: bold; */
            /* border: 1px solid #ccc; */
            /* border-radius: var(--rounding-small); */
            /* cursor: pointer; */
            border: var(--gridcell-border);
            color: var(--gridcell-text);
            width: 42px;
            height: var(--cell-size);
            font-size: 18pt;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--gridcell);
            border-radius: var(--rounding-small);
            text-transform: uppercase;
            cursor: auto;
        }

        .alpha-grid button.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
        }


        .alphagrid-1 {
            background: var(--bg);
            color: var(--text);
            font-size: 12pt;
            overflow:hidden;
            /* overflow-y: auto;  */
            /* disable scrolling*/
            /* scroll-behavior: initial;             */
            border-radius: var(--rounding);
            width:344px;
            padding: 0px 28px 48px 28px;
            align-self:center;
        }








        /* ANIMATIONS AND ANIMATION CLASSES*/

        .anim-pos {
            animation-name: animate-positive;
            animation-duration: 0.5s;
        }

        @keyframes animate-positive {
            0% {
                background-color: var(--positive-feedback);
                border-color: var(--positive-feedback);
                color: var(--bg);

                transform: scaleY(100%);
                transform: scaleX(-100%);
            }
          
            50% {
                transform: scaleY(50%);
                transform: scaleX(100%);
            }

            100% {
                background-color: var(--wordcell);
                border: var(--wordcell-border);
                color: var(--wordcell-text);

                transform: scaleY(100%);
                transform: scaleX(100%);
            }
        }


        .anim-neg {
            animation-name: animate-negative;
            animation-duration: 1s;
        }

        @keyframes animate-negative {
            0% {
                background-color: var(--negative-feedback);
            }

            100% {
                background-color: var(--bg);
            }
        }


        .anim-bonus {
            animation-name: animate-bonus;
            animation-duration: 2s;
        }

        @keyframes animate-bonus {
            0% {
                background-color: var(--positive-feedback);
                transform: scale(75%);
            }

            100% {
                background-color: var(--accent);
                transform: scale(100%);
            }
        }


        .anim-play {
            animation-name: animate-play;
            animation-duration: 0.3s;
        }

        @keyframes animate-play {
            0% {
                background-color: var(--positive-feedback);
                border-color: var(--positive-feedback);
                color: var(--bg);
                transform: scale(100%);
                /* transform: scaleX(-200%); */
                /* filter: blur(0%) */

            }
          
            50% {
                transform: scale(50%);
                /* transform: scaleX(100%); */
                /* filter: blur(50%) */

            }

            100% {
                background-color: var(--wordcell);
                border: var(--wordcell-border);
                color: var(--wordcell-text);
                transform: scale(100%);
                /* transform: scaleX(100%); */
                /* filter: blur(0%) */

            }
        }

        .anim-refresh {
            animation-name: animate-refresh;
            animation-duration: 0.5s;
        }

        @keyframes animate-refresh {
            0% {
                /* background-color: var(--positive-feedback); */
                transform: scale(75%);
            }

            100% {
                /* background-color: var(--bg); */
                transform: scale(100%);
            }
        }


        .anim-used {
            animation-name: animate-already-used;
            animation-duration: 5s;
        }

        @keyframes animate-already-used {
            0% {
                background-color: var(--disabled);
            }

            100% {
                background-color: var(--bg);
            }
        }


        .shake {
            animation: shake 0.2s ease;
        }

        @keyframes shake {
            0% {
                transform: translateX(0px);
            }

            25% {
                transform: translateX(-10px);
            }

            50% {
                transform: translateX(10px);
            }

            75% {
                transform: translateX(-10px);
            }

            100% {
                transform: translateX(0);
            }
        }

        .blur {
            filter: blur(50%)
        }

        .hidden {
            display: none;
        }

        .opacity-hide {
            opacity: 0%;
        }
    </style>
</head>

<body>

    <!-- <div style="height:60px;"><br></div> -->
    <div id="dropdown" style="display:none;">
        <h1>stringchain</h1>

        <div id="highScores"></div>
        <button id="themeToggle" class="help-dark">change</button> <button id="toggle-rules" class="help-dark">HOW TO
            PLAY</button> <button id="aboutBtn" class="help-dark">about</button>
        <div id="rules" style="display: none;">
            <h1>how to play stringchain</h1>
            <h2>PLAYABLE MOVES</h2>

            <div class="demo-div">
                <!-- EXAMPLE 1: SWAP -->
                <div class="demo-board">
                    <p class="demo-para">Swap two <b><i>word</i></b> letters by selecting both.</p>
                    <div class="word-container demoscale">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">M</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Hit the <b><i>PLAY</i></b> button to complete the move.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> 
                        <button class="bonusBtn disabled" style="border:2px solid transparent;">||</button>
                        <button class="actionBtn" style="border:var(--selected-border);">PLAY</button>
                        <button class="gridRefreshBtn disabled" style="border:2px solid transparent;">#</button>
                        </div> -->

                    <div class="word-container demoscale"
                        style="width:75%;background:var(--positive-feedback);margin-top:5px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">M</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div><br>
            <div class="demo-div">
                <!-- EXAMPLE 2: REARRANGE -->
                <div class="demo-board">
                    <p class="demo-para">Place a <b><i>word</i></b> letter in a <b><i>slot</i></b><br>to rearrange
                        the word.</p>
                    <div class="word-container demoscale" style="margin-top:10px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">M</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">E</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Hit <b><i>PLAY</i></b> to complete the move.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="gridRefreshBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->
                    <div class="word-container demoscale" style="background:var(--positive-feedback);margin-top:5px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">M</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div>
            <br>
            <div class="demo-div">
                <!-- EXAMPLE 3: DELETE -->
                <div class="demo-board">
                    <p class="demo-para">Select a single <b><i>word</i></b> letter.</p>
                    <div class="word-container demoscale">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">M</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Hit <b><i>PLAY</i></b> to delete it<br>and make a new valid word.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="gridRefreshBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->

                    <div class="word-container demoscale" style="background:var(--positive-feedback);margin-top:5px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div>

            <p><br>A move can also use a letter from the grid.<br><br></p>


            <div class="demo-div"><!-- EXAMPLE 4: REPLACE -->
                <div class="demo-board">
                    <p class="demo-para">Select a <b><i>word</i></b> letter</p>
                    <div class="word-container demoscale" style="width:100%">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">A</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">and a <b><i>grid</i></b> letter to replace it.</p>
                    <div class="grid-demo">
                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo selected">N</div>

                        <div class="grid-cell-demo">R</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo used"></div>

                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">H</div>
                        <div class="grid-cell-demo">T</div>
                    </div>
                    <p class="demo-para">Hit <b><i>PLAY</i></b> to confirm.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="gridRefreshBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->
                    <div class="word-container demoscale"
                        style="width:75%;background:var(--positive-feedback);margin-top:5px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div>
            <br>


            <div class="demo-div">
                <!-- EXAMPLE 5: INSERT -->
                <div class="demo-board">
                    <p class="demo-para">Select a <b><i>slot</i></b></p>
                    <div class="word-container demoscale" style="width:100%">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell selected"></div>
                    </div>
                    <p class="demo-para">and a <b><i>grid</i></b> letter to put there</p>


                    <div class="grid-demo">
                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo used"></div>

                        <div class="grid-cell-demo">R</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo used"></div>

                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">H</div>
                        <div class="grid-cell-demo selected">T</div>
                    </div>
                    <p class="demo-para">Engage <b><i>PLAY</i></b> to make it so<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="gridRefreshBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->

                    <div class="word-container demoscale"
                        style="width:75%;background:var(--positive-feedback);margin-top:5px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div>
            <br>
            <h2>BONUSES</h2>
            <div class="demo-div">
                <!-- EXAMPLE 6: BONUS -->
                <div class="demo-board">
                    <p class="demo-para">A bonus no-penalty setup move is earned<br>for every 5 words
                        added to the chain.<br><br></p>
                    <div class="button-row demo demoscale"> <button class="bonusBtn"
                            style="border:var(--selected-border);">1
                            ||</button><button class="actionBtn disabled"
                            style="border:2px solid transparent;">PLAY</button><button class="gridRefreshBtn disabled"
                            style="border:2px solid transparent;">#</button></div>
                    <p class="demo-para"><br>To use it, select a move as normal but<br>hit the <b>BONUS ||</b> button
                        instead of <b><i>PLAY</i></b>.
                    </p>
                </div>
            </div>
            <br>
            <div class="demo-div">
                <!-- EXAMPLE 6: REFRESH BUTTON -->
                <div class="demo-board">
                    <p class="demo-para">A free grid refresh bonus is earned<br>for every 30 points (AKA
                        string).<br><br>Play the grid refresh bonus<br>by pressing the # button.<br><br></p>
                    <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn disabled"
                            style="border:2px solid transparent;">PLAY</button><button class="gridRefreshBtn"
                            style="border:var(--selected-border);"># 1</button></div>
                    <p class="demo-para"><br>Existing grid is replaced with a fresh one.</p>
                    <div class="grid-demo selected" style="background:var(--positive-feedback);border:none;">
                        <div class="grid-cell-demo">A</div>
                        <div class="grid-cell-demo">L</div>
                        <div class="grid-cell-demo">L</div>

                        <div class="grid-cell-demo">N</div>
                        <div class="grid-cell-demo">E</div>
                        <div class="grid-cell-demo">W</div>

                        <div class="grid-cell-demo">N</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">W</div>
                    </div>
                </div>
            </div>
            <br>
            <div class="demo-div">
                <!-- EXAMPLE 8: GRID EXPAND -->
                <div class="demo-board">
                    <div class="word-container demoscale" style="width:110%;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">B</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">L</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">L</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">S</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">Y</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Reach a six letter word once<br>and the grid expands to 4x4.</p>
                    <div class="grid-demo-four selected" style="background:var(--positive-feedback);border:none;">
                        <div class="grid-cell-demo">F</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo">R</div>

                        <div class="grid-cell-demo">F</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo">R</div>

                        <div class="grid-cell-demo">G</div>
                        <div class="grid-cell-demo">R</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo">D</div>

                        <div class="grid-cell-demo">C</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">L</div>
                    </div>

                </div>
            </div>
            <br>
            <h2>GOOD TO KNOW</h2>
            <p style="text-align:left;">If no grid refresh bonus is used, grid letters refresh when a row or column is
                completed.
                <br>
                <br>Attempting to play a previously played word does not incur a penalty. This word will be highlighted in your wordlist to help you plan your next moves.
                <br>
                <br>Words that fail dictionary validation are penalised. Using consecutive bonuses without playing a valid word also costs you a life. 
                You may use as many consecutive bonuses as your total number of lives (lost lives still count) before incurring a penalty.
                <br>
                <br>You can see your remaining lives under the current word.
            </p>
            <h2>DEEP KNOWLEDGE</h2>    
            <p style="text-align:left;"><b>Milestone</b> rewards are active from the start of the game, but only become visible when the 4x4 grid is unlocked for 6+ letters.<br>
                <br>Players get one-time rewards for these milestones:
                <br> String: 100, 200, 300, 400, 500, 600, 700, 800... 
                <br> Chain: 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024...
                <br> Word length: 6+, 7, 8, 9, 10, 11, 12, 13, 14, 15...
                <br> No-bonus streak: 10, 20, 30, 40, 50, 60, 70, 80...<br>
                <br>Rewards include bonus setup moves, grid refresh bonuses, extra lives for words 7+ letters, and a few surprises. 
                The penalty for invalid words, apart from losing a life, is losing half of all accrued setup moves and grid refresh bonuses. 
                Seems harsh, but the stakes keep it interesting.
                <br>
                <br>Enjoy!
            </p>
        </div>
        <div id="about" style="display: none;">
            <p style="text-align: left;"> <b>ABOUT</b>
                <br>
                <br>Big shoutout to <b><i>dictionaryapi.dev</i></b> and <b><i>wordgamedictionary.com</i></b> for
                providing free dictionary resources. This is
                the spirit of
                random collaboration that embodies the internet at its best.
                <br>
                <br>Without whoever they are, whoever I am couldn't have made this game for whoever you are.
                <br>
                <br>The internet is awash with bitesize daily puzzles. These are great, but Stringchain is more
                open-ended and user-driven.
                Play as much as you want, whenever you want. It's not a subscription, it's not an appointment. You
                choose when and how much. Take breaks, be healthy.
                <br>
                <br>Your highscores will include a sample of some consecutive words you played. Make yourself presentable.
                <br>
                <br>I've been tweaking the rewards and penalties to incentivise exciting gameplay.
                Your total lives (including lost lives) plus one is the penalty threshold for consecutive bonus use - that's any combination of grid refresh and setup moves without playing a valid word. 
                <br>
                <br>In early gameplay, it is important to use bonuses strategically. Word choice is crucial to creep up on longer words without running out of rope.
                You can unlock extra lives (and raise the consecutive bonus use penalty threshold) by playing 7+ letter words.
                <br>
                <br>You can rack up string and chain by finding new more efficient paths through all the obvious and convenient short words.
                Or you can revel in the long word space, stripmining rich veins of vocab, looking for opportunities in the grid to take your word to the next milestone.
                <br>
                <br>Get a high score.<br>Beat that high score. <br>Screenshot that high score and challenge your
                friends.<br>Show off your wordlist. You made that. Look at all the words you know.
                <br>
                <br>Future tweaks and updates are planned, including drag/drop UI. But the core game is in place, have at it.
                <br>
                <br>If you enjoy this game, consider buying me a coffee or putting my kids through college.
                <br>
                <br>Word nerd,<br>Dave
            </p>
        </div>




    </div>
    <div class="scores"><span id="score">0</span>&nbsp; <b>string</b><button id="toggle-dropdown"
            class="help toggle-dropdown">+</button><b>chain</b> &nbsp;<span id="chain">0</span></div>
    <div id="anti-move-wrapper">
        <div id="message" class="message"></div>
    </div>
    <div class="scale-wrapper" id="scaleWrapper">
        <div class="word-container" id="wordContainer"></div>
    </div>
    <div id="status">...</div>

    <!-- <div class="button-row">
        <button id="bonusBtn">||</button>
        <button id="actionBtn">PLAY</button>
        <button id="gridRefreshBtn">#</button>
    </div> -->
    <!-- <div id="message" class="message"></div> -->
    <!-- <table class="no-spaces">
    <tr class="no-spaces">
        <td class="button-col">
            <button id="dummyBtn" style="opacity:0%;">?</button>
                <button id="bonusBtn">||</button>
        </td>
        <td style="border:none;margin-top:0px;">
            <div class="grid" id="letterGrid"></div>
        </td>
        <td class="button-col">
            <button id="actionBtn">PLAY</button>
            <button id="gridRefreshBtn">#</button>
        </td>
    </tr>
</table> -->
    <!-- <div id="status">...</div> -->

    <div class="game-area"> <!-- Fixed width matching your history area -->

        <div class="play-grid-layout">

            <div class="rail left-rail">
                <button id="dummyBtn1" class="rail-btn span-0 opacity-hide">?</button>
                <button id="bonusBtn" class="rail-btn span-2">||</button>
                <button id="milestonesBtn" class="rail-btn hidden">...</button>
            </div>
            <!-- <div></div>             -->
            <div class="grid" id="letterGrid"></div>
            <!-- <div></div> -->
            <div class="rail right-rail">
                <button id="actionBtn" class="rail-btn span-2">PLAY</button>
                <!-- <button id="dummyBtn3" class="rail-btn span-0 opacity-hide">?</button> -->
                <button id="gridRefreshBtn" class="rail-btn">#</button>
                <button id="scrollBtn" class="scrollBtn">^</button>
            </div>

        </div>
    </div>
    <div id="history"></div>
    <!-- <div id="disallowed"></div> -->

    <button id="newGameBtn" class="newgame">RESTART</button>

    <div id="definitions"></div>
    <!-- <button id="scrollBtn" class="scrollBtn">^</button> -->
    <!-- Asterisk Letter Picker Modal -->
    <div id="asteriskModal" class="modal hidden">
        <div class="modal-content-2">
            <h6>WILDCARD</h6>
                <div class="alphagrid-1">
                <p class="demo-para opacity-hide" style="text-align:left;font-size:13pt;" id="wildcard-1"><br><br>Pick a
                    letter...</p>
                <div class="alpha-grid"></div>
                <p class="demo-para opacity-hide" style="text-align:right;font-size:13pt;" id="wildcard-2">...or save for
                    later with *</p>
            </div>
                <!-- First wildcard when chain reaches 128, another for every additional 32 words. They appear when grid rows and columns are cleared.<br><br> -->
                <p class="demo-para opacity-hide" style="text-align:justify;font-size:12pt;" id="wildcard-3">
                <br>After 128 words, a wildcard is awarded. It appears the next time a grid row or column refreshes.
                Another wildcard is earned for every 32 additional words.<br>
                <br>
            </p>
        </div>
    </div>










    <!-- Milestones Modal -->
    <div id="milestonesModal" class="modal hidden">
        <div class="modal-content-1">
            <h6>MILESTONES</h6>
            <div id="milestones-1" class="milestones-1">
                <!-- Milestone content will be dynamically inserted here -->
            </div>
            <!-- <span id="streakinfo"></span> -->
            <div id="nextMilestoneInfo" style="padding-left:20px;"></div>

        </div>
    </div>



        <script>









            //DECLARATIONS
            const scaleWrapper = document.getElementById('scaleWrapper');
            const wordContainer = document.getElementById('wordContainer');
            const highScoresElement = document.getElementById('highScores');
            const gridElement = document.getElementById('letterGrid');
            const actionBtn = document.getElementById('actionBtn');
            const newGameBtn = document.getElementById('newGameBtn');
            const bonusBtn = document.getElementById('bonusBtn');
            const gridRefreshBtn = document.getElementById('gridRefreshBtn');
            const milestonesBtn = document.getElementById('milestonesBtn');
            const milestonesModal = document.getElementById('milestonesModal');
            const milestonesContent = document.getElementById('milestones-1');
            const nextMilestoneInfo = document.getElementById('nextMilestoneInfo');
            // const streakinfo = document.getElementById('streakinfo');
            const wildcardOne = document.getElementById('wildcard-1');
            const wildcardTwo = document.getElementById('wildcard-2');
            const wildcardThree = document.getElementById('wildcard-3');
            const messageElement = document.getElementById('message');
            const scoreElement = document.getElementById('score');
            const chainElement = document.getElementById('chain');
            const historyElement = document.getElementById('history');
            // const disallowedElement = document.getElementById('disallowed');
            const statusElement = document.getElementById('status');
            const definitionsElement = document.getElementById('definitions');
            const rulesToggle = document.getElementById("toggle-rules");
            const dropdownToggle = document.getElementById("toggle-dropdown");
            const scrollBtn = document.getElementById("scrollBtn");
            const aboutBtn = document.getElementById("aboutBtn");
            const aboutDiv = document.getElementById("about");
            const rulesDiv = document.getElementById("rules");
            const dropdownDiv = document.getElementById("dropdown");
            const disqualified = localStorage.getItem("isDisqualified") === "true";
            const alphabet = "EEEEEEEEEAAAARRRRIIIOOONNSSSTTTLLLLCCUUUDDDPPGGHHBBMMYYFFVVWWKKXJQZ".split("");
            const starterWords = ["ACE", "ACT", "ADD", "ADO", "ADS", "AFT", "AGE", "AGO", "AIR", "ALL", "AND", "ANT", "ANY", "APE", "APT", "ARC", "ARE", "ARK", "ARM", "ART", "ASH", "ASK", "AWE", "AWL", "AXE", "BAD", "BAG", "BAN", "BAR", "BAT", "BAY", "BED", "BEE", "BEG", "BET", "BIG", "BIN", "BIT", "BOA", "BOB", "BOG", "BOP", "BOW", "BOY", "BRA", "BRO", "BUD", "BUG", "BUM", "BUS", "BUT", "BUY", "BYE", "CAB", "CAD", "CAM", "CAN", "CAP", "CAR", "CAT", "CAW", "COB", "COD", "COG", "CON", "COO", "COP", "COT", "COW", "COY", "CRY", "CUB", "CUE", "CUP", "CUR", "CUT", "DAB", "DAD", "DAG", "DAM", "DAY", "DEB", "DEN", "DEW", "DID", "DIE", "DIG", "DIN", "DIP", "DOC", "DOE", "DOG", "DON", "DOT", "DRY", "DUB", "DUD", "DUE", "DUG", "EAR", "EAT", "EEL", "EGG", "EGO", "ELF", "ELL", "EMU", "END", "ERA", "EVE", "EWE", "EYE", "FAD", "FAN", "FAR", "FAT", "FAX", "FED", "FEE", "FEW", "FIB", "FIG", "FIN", "FIR", "FIT", "FLY", "FOE", "FOG", "FOR", "FRY", "FUN", "FUR", "GAG", "GAP", "GAS", "GAY", "GEL", "GEM", "GET", "GIG", "GIN", "GOT", "GUM", "GUN", "GUT", "GUY", "GAP", "HAD", "HAM", "HAS", "HAT", "HAW", "HAY", "HEW", "HEY", "HIM", "HIP", "HIS", "HIT", "HOG", "HOP", "HOT", "HOW", "HUB", "HUE", "HUG", "HUM", "HUT", "ICE", "ILL", "INK", "INN", "ION", "JAB", "JAM", "JAR", "JAW", "JAY", "JAW", "JIG", "JOB", "JOE", "JOG", "JOT", "JOY", "JUG", "KEY", "KIT", "LAB", "LAD", "LAG", "LAP", "LAW", "LAY", "LEA", "LED", "LEG", "LET", "LID", "LIE", "LOG", "LOT", "LOW", "MAD", "MAN", "MAP", "MAT", "MAX", "MAY", "MEN", "MET", "MID", "MIX", "MOB", "MOD", "MOM", "MOP", "MOW", "MUD", "MUG", "MUM", "NAB", "NAP", "NOD", "NOT", "NOW", "NUN", "NUT", "OAR", "OAT", "ODD", "OFF", "OIL", "OLD", "ONE", "OPT", "OUR", "OUT", "OVA", "OWE", "OWL", "OWN", "PAD", "PAL", "PAN", "PAR", "PAT", "PAW", "PAY", "PEG", "PEN", "PET", "PEW", "PHI", "PIE", "PIG", "PIN", "PIT", "PLY", "POD", "POP", "POT", "PRO", "PUB", "PUG", "PUP", "PUT", "RAM", "RAN", "RAP", "RAT", "RAW", "RAY", "RED", "REP", "REV", "RIB", "RID", "RIG", "RIM", "RIP", "ROB", "ROD", "ROE", "ROT", "ROW", "RUB", "RUE", "RUG", "RUN", "RUT", "SAC", "SAD", "SAG", "SAP", "SAT", "SAW", "SAX", "SAY", "SEA", "SEE", "SET", "SEW", "SEX", "SHY", "SIB", "SIC", "SIN", "SIP", "SIR", "SIS", "SIT", "SKY", "SOB", "SOD", "SOL", "SON", "SOP", "SOS", "SOW", "SOX", "SPA", "SPY", "SUB", "SUE", "SUM", "SUN", "SUP", "TAB", "TAD", "TAG", "TAP", "TAR", "TEA", "TEE", "TEN", "THE", "TIE", "TIN", "TIP", "TOE", "TOG", "TON", "TOO", "TOP", "TOT", "TOW", "TOY", "TRY", "TUB", "TUG", "TUX", "TWO", "URN", "USE", "VAN", "VAT", "VET", "VIA", "VIE", "WAR", "WAS", "WAY", "WEB", "WED", "WEE", "WET", "WHO", "WHY", "WIN", "WIT", "WOK", "WON", "WOO", "YAK", "YAM", "YAP", "YAW", "YES", "ABLE", "ACID", "ACRE", "BACK", "BALL", "BAND", "CALM", "CAMP", "CARD", "DAWN", "DAYS", "DEAL", "EACH", "EARN", "ELSE", "FACE", "FACT", "FINE", "GAIN", "GATE", "GAVE", "GIRD", "HAIR", "HALF", "HAND", "ICON", "IDEA", "IDLE", "JACK", "JAIL", "KING", "KIND", "LACK", "LAKE", "LIMP", "MADE", "MAIL", "NAME", "NAIL", "ONCE", "ODDS", "PACK", "PAGE", "RACE", "RAIN", "SAFE", "SAIL", "TAKE", "TALE", "TINE", "UNIT", "URGE", "VARY", "VAST", "WAGE", "WAIT", "YARD", "YARN", "ZAPS"];
            const allowList = ["FLAP", "FLAPS", "FLAPPING", "FLAPPED", "FLAPPER", "FLAPPERS", "DOLLING", "DOLLED", "TOCK", "HELL", "FEWER", "YOUR", "PATTER", "DRAB", "LIVES", "LIVED", "LIVING", "HELLS", "TOW", "TOWS", "TOWED", "TOWING", "DUNK", "DUNKS", "DUNKING", "DUNKED", "TOW", "TOWS", "TOWING", "TOWED", "TIGHT", "SIFT", "DOSE", "DOSES", "DOSED", "DOSING", "KITE", "KITES", "NET", "CUE", "CUES", "CUED", "CUEING", "CUING", "RAPE", "RAPES", "RAPED", "SATES", "SATED", "SATING", "RAPING", "PEND", "PENDS", "PENDED", "PENDING", "BE", "LOOK", "LOOKS", "LOOKED", "LOOKING", "VEINY", "WEAN", "WEANS", "WEANED", "WEANING"];
            let isActiveGame = true;
            let playedWords = new Set();
            // let disallowedWords = new Set();
            let gameID = "";
            let bonusTicker = '';
            let bonusCounter = 0;
            let currentWord = "";
            let lastValidWord = "";
            let gridSize = 3;
            let grid = [];
            let gridFallback = [];
            let score = 0;
            let chain = 0;
            let selected = [];
            let setupMovesAvailable = 0;
            let gridRefreshBonusesAvailable = 0;
            let asteriskEarned = 0;
            let lastAsteriskThreshold = 0;
            let wordLengthMilestones = [ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50 ];
            let chainMilestones = [ 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576 ];
            let stringMilestones = [ 100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000 ];
            let streakMilestones = [ 10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600 ];
            let milestones = [];
            let noBonusStreak = 0;
            let bestNoBonusStreak = 0;
            let consecutiveBonuses = 0;
            let livesLost = 0;
            let totalLives = 3;
            let lastSelectedType = null;
            let lastSelectedCell = null;
            // let lastUsedGridCell = null; // Track last used cell for invalid move rollback
            let specialModeActive = false; // Track bonus special mode
            let LOCAL_WORDS = null;

            async function loadLocalWords() {
                const response = await fetch('assets/merged-wordlists.json');
                const data = await response.json();

                // Flatten all buckets into one Set
                LOCAL_WORDS = new Set(
                    Object.values(data).flatMap(list => list)
                );
                console.log(LOCAL_WORDS);
            }
            //END OF DELARATIONS

            //BUTTONS

            actionBtn.addEventListener('click', () => {
                // playAnimation();
                completeMove(true);
            });

            dropdownToggle.addEventListener("click", () => {
                const dropdownHidden = dropdownDiv.style.display === "none";
                dropdownDiv.style.display = dropdownHidden ? "block" : "none";
                dropdownToggle.textContent = dropdownHidden ? "^" : "+";
                getHighScores();
                if (rulesDiv.style.display = "block") {
                    rulesDiv.style.display = "none";
                    rulesToggle.textContent = "HOW TO PLAY";
                }
                if (aboutDiv.style.display = "block") {
                    aboutDiv.style.display = "none";
                    aboutBtn.textContent = "about";
                }
                topFunction();
            });

            rulesToggle.addEventListener("click", () => {
                const rulesHidden = rulesDiv.style.display === "none";
                rulesDiv.style.display = rulesHidden ? "block" : "none";
                rulesToggle.textContent = rulesHidden ? "^" : "HOW TO PLAY";
                if (rulesDiv.style.display != "block") { dropdownToggle.click() };
                if (aboutDiv.style.display = "block") {
                    aboutDiv.style.display = "none";
                    aboutBtn.textContent = "about";
                }
            });

            aboutBtn.addEventListener("click", () => {
                const aboutHidden = aboutDiv.style.display === "none";
                aboutDiv.style.display = aboutHidden ? "block" : "none";
                aboutBtn.textContent = aboutHidden ? "^" : "about";
                if (aboutDiv.style.display != "block") { dropdownToggle.click() };
                if (rulesDiv.style.display = "block") {
                    rulesDiv.style.display = "none";
                    rulesToggle.textContent = "HOW TO PLAY";
                }
            });

            bonusBtn.addEventListener('click', () => {
                if (setupMovesAvailable <= 0) {
                    messageElement.textContent = "You get a bonus after every 5 words. Click + for guidance.";
                    showTemporaryMessage();
                    return;
                }
                if (selected.length === 0) {
                    messageElement.textContent = "Select a playable move first";
                    showTemporaryMessage();
                    return;
                }


                let moved = applyMove();
                clearSelection();
                renderWord();
                // replenishGrid(); // MOVED TO THE END
                if (!moved) {
                    messageElement.textContent = "Invalid move. Click + for guidance.";
                    showTemporaryMessage();
                    return;
                }
                setupMovesAvailable--;
                updateBonusButton();
                bonusCounter++;
                bonusTicker = "||" + bonusCounter;
                playedWords.add(bonusTicker);
                updateHistory();
                bonusTicker = '';
                lastValidWord = currentWord;
                messageElement.innerHTML = `Bonus setup move played.`;
                bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                noBonusStreak = 0;
                consecutiveBonuses++;
                updateStatus();
                penaliseConsecutiveBonuses();
                showTemporaryMessage();
                activateSpecialMode(); //ADDED FOR BONUS MOVE EFFECT
                replenishGrid(); //MOVED TO HERE TO STOP GRID EXPAND FOR SETUP MOVE

                return;
            });

            gridRefreshBtn.addEventListener('click', () => {
                if (gridRefreshBonusesAvailable > 0) {
                    gridRefreshBonusesAvailable--;
                    bonusCounter++;
                    bonusTicker = "#" + bonusCounter;
                    playedWords.add(bonusTicker);
                    updateHistory();
                    bonusTicker = '';
                    initGrid();
                    updateGridRefreshButton();
                    messageElement.textContent = "Grid refreshed!";
                    showTemporaryMessage();
                    bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                    noBonusStreak = 0;
                    consecutiveBonuses++;
                    updateStatus();
                    penaliseConsecutiveBonuses();
                    letterGrid.classList.add('anim-refresh');
                    saveGameState();
                    setTimeout(() => {
                        letterGrid.classList.remove('anim-refresh');
                    }, 1000);
                }
            });

            newGameBtn.addEventListener('click', () => {

                if (isActiveGame == true && chain >= 5) {
                    let text = "Are you sure you want to restart?";
                    if (confirm(text) == false) {
                        return;
                    }
                }
                sa_event("new_game");
                saveHighScore();
                getHighScores();
                localStorage.removeItem("stringChainState");
                localStorage.removeItem("isDisqualified");
                gameID = new Date().toISOString().slice(0, 19).replace('T', ' ');
                gridSize = 3;
                dummyBtn1.classList.add("span-0");
                // dummyBtn3.classList.add("span-0");
                gridRefreshBtn.classList.remove("span-2");
                grid = [];
                score = 0;
                chain = 0;
                setupMovesAvailable = 5;
                gridRefreshBonusesAvailable = 5;
                asteriskEarned = 0;
                lastAsteriskThreshold = 0;
                wordLengthMilestones = [ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50 ];
                chainMilestones = [ 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576 ];
                stringMilestones = [ 100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000 ];
                streakMilestones = [ 10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600 ];
                milestones = [];
                noBonusStreak = 0;
                bestNoBonusStreak = 0;
                consecutiveBonuses = 0;
                // milestonesSummary = "";
                milestonesBtn.classList.add('hidden');
                livesLost = 0;
                totalLives = 3;
                playedWords.clear();
                bonusTicker = '';
                bonusCounter = 0;
                // disallowedWords.clear();
                gridElement.style.pointerEvents = 'auto';
                wordContainer.style.pointerEvents = 'auto';
                scoreElement.textContent = score;
                chainElement.textContent = chain;
                messageElement.textContent = '';
                // disallowedElement.textContent = '';
                updateBonusButton();
                updateGridRefreshButton();
                definitionsElement.textContent = '';
                specialModeActive = false;
                fitWordContainer();
                isActiveGame = true;
                previousWord = '';
                actionBtn.disabled = false;
                currentWord = randomWord();
                initGrid();
                renderWord();
                validateWord(previousWord);
                updateHistory();
                updateStatus();
                removeAnimation();
                clearSpecialMode();
                loadLocalWords();
                // localStorage.clear(); // FOR HARD RESET TO SEE NEW USER EXPERIENCE
                if (dropdownDiv.style.display = "block") { dropdownToggle.click(); }
            });

            milestonesBtn.addEventListener('click', () => {
                milestonesModal.classList.remove('hidden');
                renderMilestones();
            });


            milestonesModal.addEventListener("click", (e) => {
                if (e.target === milestonesModal) {
                    milestonesModal.classList.add("hidden");
                }
            });

            function showMilestonesModal() {
                milestonesModal.classList.remove('hidden');
                // setTimeout(() => {
                //     milestonesModal.classList.add('hidden');
                // }, 4000); // Hide after 8 seconds
            }


            //END OF BUTTONS

            //ANIMATIONS AND HIGHLIGHTS

            function highlightPlayed(currentWord) {
                historyElement.innerHTML = historyElement.innerHTML.replace(
                    new RegExp(currentWord, 'gi'),
                    '<mark class="highlight">$&</mark>'
                );

                const newMarks = historyElement.querySelectorAll('mark.highlight:not(.fade)');
                newMarks.forEach(mark => {
                    // setTimeout(() => mark.classList.add('fade'), 18000);  // start fade
                    setTimeout(() => mark.outerHTML = mark.innerText, 60000); // remove
                });
            }

            function highlightPlayed(currentWord) {
                // Escape any special regex characters in the word
                const safeWord = currentWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

                // Match whole word only
                const regex = new RegExp(`\\b${safeWord}\\b`, 'gi');

                // Highlight the word
                historyElement.innerHTML = historyElement.innerHTML.replace(
                    regex,
                    '<mark class="highlight">$&</mark>'
                );

                // Keep highlight for 60s
                const newMarks = historyElement.querySelectorAll('mark.highlight:not(.fade)');
                newMarks.forEach(mark => {
                    setTimeout(() => mark.outerHTML = mark.innerText, 60000);
                });
            }

            function playAnimation() { 
                actionBtn.classList.remove('anim-play');
                void actionBtn.offsetWidth; // reflow to restart animation
                actionBtn.classList.add('anim-play');
            }

            function redAnimation() { wordContainer.classList.add('anim-neg'); }
            function bonusAnimation() { bonusBtn.classList.add('anim-bonus'); }
            function gridRefreshAnimation() { gridRefreshBtn.classList.add('anim-bonus'); }
            function alreadyUsedAnimation() {
                wordContainer.classList.add("shake");
                // Remove class after animation so it can trigger again later
                wordContainer.addEventListener("animationend", () => {
                    wordContainer.classList.remove("shake");
                }, { once: true });
            }
            function greenAnimation() {
                const elements = wordContainer.querySelectorAll('.letter, .insert-slot');
                const animationDuration = 500; // in ms (0.5s from CSS)
                const stagger = 30; // in ms (0.03s)

                elements.forEach((el, index) => {
                    el.classList.remove('anim-pos');
                    void el.offsetWidth; // reflow to restart animation

                    el.style.animationDelay = `${index * stagger / 1000}s`;
                    el.classList.add('anim-pos');

                    // Calculate when to remove the class
                    const totalDelay = animationDuration + index * stagger;
                    setTimeout(() => {
                        el.classList.remove('anim-pos');
                        //   el.style.animationDelay = ''; // optional: clean up inline style
                    }, totalDelay);
                });
            }

            function removeAnimation() {
                if (wordContainer.classList.contains('anim-neg')) { wordContainer.classList.remove('anim-neg'); }
                if (wordContainer.classList.contains('anim-pos')) { wordContainer.classList.remove('anim-pos'); }
                if (letterGrid.classList.contains('anim-refresh')) { letterGrid.classList.remove('anim-refresh'); }
                if (bonusBtn.classList.contains('anim-bonus')) { bonusBtn.classList.remove('anim-bonus'); }
                if (gridRefreshBtn.classList.contains('anim-bonus')) { gridRefreshBtn.classList.remove('anim-bonus'); }
                if (wordContainer.classList.contains('shake')) { wordContainer.classList.remove('shake'); }
                if (actionBtn.classList.contains('anim-play')) { actionBtn.classList.remove('anim-play'); }
                if (milestonesBtn.classList.contains('anim-bonus')) { milestonesBtn.classList.remove('anim-bonus'); }

            }

            function activateSpecialMode() {
                specialModeActive = true;
                wordContainer.classList.add('special');
                messageElement.classList.add('special-sauce');
                saveGameState();
                return;
            }
            function clearSpecialMode() {
                specialModeActive = false;
                wordContainer.classList.remove('special');
                messageElement.classList.remove('special-sauce');
                saveGameState();
                return;
            }

            //END OF ANIMATIONS AND HIGHLIGHTS

            //THEMES AND PRESENTATION

            //SCROLLING ETC
            window.onscroll = function () { scrollFunction() };
            function scrollFunction() {
                if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
                    scrollBtn.style.display = "block";
                } else {
                    scrollBtn.style.display = "none";
                }
            }
            // When the user clicks on the button, scroll to the top of the document
            function topFunction() {
                document.body.scrollTop = 0;
                document.documentElement.scrollTop = 0;
            }

            scrollBtn.addEventListener("click", () => {
                topFunction();
                if (dropdownDiv.style.display = "block") { dropdownToggle.click() };
            });
            //END OF SCROLLING ETC

            //THEMES
            const themeToggle = document.getElementById("themeToggle");
            const themes = ["default", "fruit-salad", "hi-contrast", "green-pops", "tannery", "dark-grey", "not-too-light", "winery", "minimal-liminal", "blue-pops", "pinko", "greenery", "minimal-animal", "yello-pops", "too-light"];
            let currentTheme = localStorage.getItem("theme") || "default";
            if (currentTheme !== "default") {
                document.documentElement.classList.add(currentTheme);
            }
            themeToggle.addEventListener("click", () => {
                // Remove current theme if not default
                if (currentTheme !== "default") {
                    document.documentElement.classList.remove(currentTheme);
                }

                // Cycle to next theme
                const currentIndex = themes.indexOf(currentTheme);
                const nextIndex = (currentIndex + 1) % themes.length;

                currentTheme = themes[nextIndex];

                // Apply if not default
                if (currentTheme !== "default") {
                    document.documentElement.classList.add(currentTheme);
                }

                // Save
                localStorage.setItem("theme", currentTheme);
            });
            //END OF THEMES

            //WORD CONTAINER
            function fitWordContainer() {
                let letterCount = wordContainer.querySelectorAll('.letter').length;

                // let scaleCalc = 11 / (6 + letterCount);
                let scaleCalc = 330 / ((33 * letterCount) + (17 * (letterCount + 1)) + (10 * letterCount));
                scaleCalc = Math.min(scaleCalc, 1.3);

                document.documentElement.style.setProperty('--scale-var', scaleCalc);
                return;
            }
            //END OF WORD CONTAINER

            //END OF THEMES AND PRESENTATION

            //SAVING, LOADING, HIGHSCORES

            function saveGameState() {
                const gameState = {
                    isActiveGame, 
                    gameID, 
                    currentWord, 
                    lastValidWord, 
                    gridSize, 
                    grid, 
                    gridFallback, 
                    score, 
                    chain, 
                    setupMovesAvailable, 
                    asteriskEarned, 
                    lastAsteriskThreshold, 
                    gridRefreshBonusesAvailable, 
                    wordLengthMilestones, 
                    chainMilestones, 
                    stringMilestones, 
                    noBonusStreak,
                    bestNoBonusStreak,
                    consecutiveBonuses,
                    streakMilestones, 
                    milestones, 
                    totalLives, 
                    livesLost, 
                    specialModeActive, 
                    bonusCounter, 
                    playedWords: Array.from(playedWords)
                };
                localStorage.setItem("stringChainState", JSON.stringify(gameState));
            }

            // Load and restore directly
            function loadGameState() {
                // actionBtn.disabled = disqualified; 
                if (disqualified) {
                    newGameBtn.click();
                    return;
                }
                const saved = localStorage.getItem("stringChainState");

                if (!saved) {
                    newGameBtn.click();
                    return;
                }

                try {
                    ({
                        isActiveGame, 
                        gameID, 
                        currentWord, 
                        lastValidWord, 
                        gridSize, 
                        grid, 
                        gridFallback, 
                        score, 
                        chain, 
                        setupMovesAvailable, 
                        asteriskEarned, 
                        lastAsteriskThreshold, 
                        gridRefreshBonusesAvailable, 
                        wordLengthMilestones, 
                        chainMilestones, 
                        stringMilestones, 
                        noBonusStreak,
                        bestNoBonusStreak,
                        consecutiveBonuses,
                        streakMilestones, 
                        milestones, 
                        totalLives, 
                        livesLost, 
                        specialModeActive, 
                        bonusCounter, 
                        playedWords
                    } = JSON.parse(saved));
                    // disallowedWords = new Set(disallowedWords);
                    playedWords = new Set(playedWords);
                    renderWord();
                    renderGrid();
                    updateHistory();
                    // updateDisallowedWords();
                    updateBonusButton();
                    updateGridRefreshButton();
                    showDefinitions(lastValidWord);
                    updateStatus();
                    loadLocalWords();
                    if (gridSize == 3) { dummyBtn1.classList.add("span-0"); gridRefreshBtn.classList.remove("span-2"); milestonesBtn.classList.add("hidden"); }
                    if (gridSize == 4) { dummyBtn1.classList.remove("span-0"); gridRefreshBtn.classList.add("span-2"); milestonesBtn.classList.remove("hidden"); }
                    scoreElement.textContent = score;
                    chainElement.textContent = chain;
                    if (specialModeActive == true) {
                        activateSpecialMode();
                    }
                } catch (err) {
                    console.error("Error loading saved state", err);
                    newGameBtn.click();
                }
            }



            function saveHighScore() {
                const stringchainHighScore = JSON.parse(localStorage.getItem("stringchainHighScore")) || [];
                const saveTime = new Intl.DateTimeFormat(undefined, {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false // forces 24-hour clock
                })
                    .format(new Date())
                    .replace(/,/g, ''); // strip commas
                const highlight = getHighlightReel();
                const newHighScore = { saveTime, score, chain, gameID, highlight };

                // Check if an entry already exists for this gameID
                const existingIndex = stringchainHighScore.findIndex(entry => entry.gameID === gameID);

                if (chain < 5) { return };
                if (existingIndex !== -1) {
                    // Overwrite the existing record
                    stringchainHighScore[existingIndex] = newHighScore;

                    // Save and return early
                    localStorage.setItem("stringchainHighScore", JSON.stringify(stringchainHighScore));
                    return;
                }

                stringchainHighScore.push({
                    saveTime: saveTime,
                    score: score,
                    chain: chain,
                    gameID: gameID,
                    highlight: highlight
                });

                //LOG HIGHSCORE EVENT
                let gameTracker = gameID.replace(/[^\d]/g, '');
                sa_event(() =>
                    `${gameTracker}_${score}_${chain}_${highlight.replace(/ /g, '_')}`
                );

                stringchainHighScore.sort((a, b) => b.score - a.score);

                const byScore = [...stringchainHighScore]
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 9);
                const byChain = [...stringchainHighScore]
                    .sort((a, b) => b.chain - a.chain)
                    .slice(0, 9);

                const combined = [...byScore, ...byChain].filter((item, index, self) => index === self.findIndex(g => g.saveTime === item.saveTime));
                combined.sort((a, b) => b.chain - a.chain);
                localStorage.setItem('stringchainHighScore', JSON.stringify(combined));
            }

            function getHighScores() {
                const scoreTableParse = JSON.parse(localStorage.getItem('stringchainHighScore')) || [];
                let scoreTable = scoreTableParse
                scoreTable = scoreTable.filter(entry => !(entry.score === 0 && entry.chain === 0));
                const rows = scoreTable.map(entry => {
                    const highlightRow = entry.highlight && entry.highlight.trim()
                        ? `<tr><td colspan="3" class="highlight-reel">${entry.highlight}</td></tr>`
                        : "";
                    return `<tr><td>${entry.score}</td><td>${entry.chain}</td><td>${entry.saveTime}</td></tr>${highlightRow}`;
                }).join('');

                if (!rows) { return };
                highScoresElement.innerHTML = `<h4>YOUR BEST GAMES</h4><table class = "high-score-table"><tr><th>STRING</th><th>CHAIN</th><th>SAVED</th></tr>${rows}</table>`;
            }



            // >>> FINAL getHighlightReel
            function getHighlightReel() {
                let words = Array.from(playedWords)
                    .filter(w => /^[a-zA-Z]+$/.test(w)) // Exclude entries containing any non-alphabetic character
                    .map(w => w.replace(/[|#*]/g, "").trim());
                if (words.length === 0) return "";

                const longestWordLength = Math.max(...words.map(w => w.length));
                const runs = [];
                let currentRun = [];

                // Find all runs of longest word length
                for (let i = 0; i < words.length; i++) {
                    if (words[i].length === longestWordLength) {
                        currentRun.push(i); // Store the index of the word in the current run
                    } else if (currentRun.length > 0) {
                        runs.push([...currentRun]); // Save the current run
                        currentRun = []; // Reset for the next run
                    }
                }
                if (currentRun.length > 0) {
                    runs.push([...currentRun]); // Add the last run if it exists
                }

                // Find the best run (longest run, or the last one if tied)
                const bestRun = runs.reduce((best, current) => {
                    if (current.length > best.length) return current;
                    if (current.length === best.length) return current; // Use the last run in case of a tie
                    return best;
                }, []);

                // Determine the number of words to display based on the longest word length
                let displayCount;
                if (longestWordLength >= 10) {
                    displayCount = 3;
                } else if (longestWordLength >= 7) {
                    displayCount = 4;
                } else {
                    displayCount = 5;
                }

                // Calculate the slice range based on the best run's length
                let sliceStart, sliceEnd;
                if (bestRun.length >= displayCount) {
                    sliceStart = bestRun[0];
                    sliceEnd = bestRun[0] + displayCount;
                } else {
                    const runStart = bestRun[0];
                    const runEnd = bestRun[bestRun.length - 1];
                    const runLength = bestRun.length;

                    if (runLength === displayCount - 1) {
                        sliceStart = runStart - 1;
                        sliceEnd = runStart + displayCount - 1;
                    } else if (runLength === displayCount - 2) {
                        sliceStart = runStart - 1;
                        sliceEnd = runEnd + 2;
                    } else if (runLength === 1) {
                        sliceStart = runStart - (displayCount - 2);
                        sliceEnd = runStart + 2;
                    } else {
                        sliceStart = runStart - (displayCount - runLength);
                        sliceEnd = runEnd + 1;
                    }

                    // Adjust if no word after the run is available
                    if (sliceEnd > words.length) {
                        const overflow = sliceEnd - words.length;
                        sliceStart = Math.max(0, sliceStart - overflow);
                        sliceEnd = words.length;
                    }
                }

                // Ensure sliceStart and sliceEnd are within bounds
                sliceStart = Math.max(0, sliceStart);
                sliceEnd = Math.min(words.length, sliceEnd);

                return words.slice(sliceStart, sliceEnd).join(" ");
            }
            // <<< END FINAL








            //END OF SAVING, LOADING, HIGHSCORES

            //CHANGING STATES MESSAGES TEXT
            // function updateStatus() {
            //     let livesLeft = totalLives - livesLost;
            //     // let baseStr = "■ ■ ■ ■ ■"
            //     // let xStr = "□ □ □ □ □ "
            //     let baseStr = "| | | | |"
            //     let xStr = "- - - - - "
            //     // let base = '<big><big><big>' + xStr.slice(2 * left) + baseStr.slice((2 * livesLost) - 1) + '</big></big></big>';
            //     let base = '<b>' + xStr.slice(2 * livesLeft) + baseStr.slice(2 * livesLost) + '</b>';
            //     statusElement.innerHTML = base;
            // }







            // function updateStatus() {
            //     const livesLeft = totalLives - livesLost;

            //     let output = "";

            //     // Lost lives
            //     for (let i = 0; i < livesLost; i++) {
            //         output += "- ";
            //     }

            //     // Remaining lives
            //     for (let i = 0; i < livesLeft; i++) {
            //         output += "| ";
            //     }

            //     statusElement.innerHTML = `<b>${output.trim()}</b>`;
            // }


            // Enhanced updateStatus with bonus highlighting WORK IN PROGRESS

            function updateStatus() {
                const livesLeft = totalLives - livesLost;
                let output = "";

                // We loop through the total number of lives/slots
                for (let i = 0; i < totalLives; i++) {
                    // 1. Determine the character (- for lost, | for remaining)
                    const char = (i < livesLost) ? "-" : "|";
                    
                    // 2. Check if this specific slot should be highlighted by a bonus
                    // i < consecutiveBonuses means this slot is "active" or "used"
                    const isHighlighted = i < consecutiveBonuses;
                    const color = isHighlighted ? "var(--text)" : "var(--accent)";

                    // 3. Wrap in a span with the color
                    output += `<span style="color: ${color}">${char}</span> `;
                }

                statusElement.innerHTML = `<b>${output.trim()}</b>`;
                if (consecutiveBonuses == totalLives - 1) {
                messageElement.textContent = `One more bonus can be used without penalty`;
                }
                if (consecutiveBonuses == totalLives) {
                messageElement.textContent = `Play a valid word!`;
                }
            }


            function penaliseConsecutiveBonuses() {
                if ((consecutiveBonuses < (totalLives + 1))) { return; }
                livesLost++;
                consecutiveBonuses = 0;
                messageElement.textContent = `-1 life for bonus overuse`;
                milestones.push({
                                word: `(${currentWord})`,
                                penalty: true,
                                penaltyNumber: livesLost,
                                penaltyReason: `${totalLives + 1} consecutive bonuses`,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    livesPenalty: 1
                                }
                            });
                if (livesLost >= totalLives) {
                            messageElement.textContent += ", GAME OVER.";
                            saveHighScore();
                            disableGame();
                            saveGameState();
                        }
                showTemporaryMessage();
                updateStatus();
                }


            function updateBonusButton() {
                if (setupMovesAvailable > 0) {
                    bonusBtn.textContent = `${setupMovesAvailable} ||`;
                    bonusBtn.classList.remove('disabled');
                    bonusBtn.disabled = false;
                } else {
                    bonusBtn.textContent = `||`;
                    bonusBtn.classList.add('disabled');
                    bonusBtn.disabled = true;
                }
            }

            function updateGridRefreshButton() {
                if (gridRefreshBonusesAvailable > 0) {
                    gridRefreshBtn.textContent = `# ${gridRefreshBonusesAvailable}`;
                    gridRefreshBtn.classList.remove('disabled');
                    gridRefreshBtn.disabled = false;
                } else {
                    gridRefreshBtn.textContent = `#`;
                    gridRefreshBtn.classList.add('disabled');
                    gridRefreshBtn.disabled = true;
                }
            }

            function disableGame() {
                isActiveGame = false;
                localStorage.setItem("isDisqualified", "true");
                actionBtn.disabled = true;
                bonusBtn.disabled = true;
                gridRefreshBtn.disabled = true;
                gridElement.style.pointerEvents = 'none';
                wordContainer.style.pointerEvents = 'none';
            }

            function showTemporaryMessage(message) {
                messageElement.style.display = "block";
            }

            function updateHistory() {
                historyElement.innerHTML = [...playedWords]
                    .reverse()
                    .map(w => {
                        // Check if the entry is a bonus and strip the number
                        if (w.startsWith("||")) return "|| ";
                        if (w.startsWith("#")) return "# ";
                        if (w.startsWith("*")) return "* ";

                        // Check if the entry is an incorrect attempt (contains "(")

                        if (w.includes("4x4")) return `<i>${w}</i> `;
                        if (w.includes("(")) 
                        //strip numeric characters
                            return `<i>${w.replace(/\d+/g, '')}</i> `;
                        // For regular words, append a space
                        return w + " ";
                    })
                    .join('');
            }





            function updateMilestones() {
                // Check if milestone exists for latest game state
                if (!wordLengthMilestones.includes(currentWord.length) && !chainMilestones.includes(chain) && !(stringMilestones[0] <= score) && !(streakMilestones.includes(noBonusStreak))) {
                    return;
                }

                //Apply bonuses in this order
                try {
                    //Applies string length milestones first
                    if (stringMilestones[0] <= score) {
                        //this one works a little differently, score can be exceeded
                        // Remove it so it can't trigger again
                        const stringMilestoneAmount = stringMilestones[0];
                        stringMilestones.splice(0, 1);
                        // Apply reward
                        if (stringMilestoneAmount % 200 === 0) {
                            milestones.push({
                                word: currentWord,
                                stringQuest: true,
                                chain: chain,
                                string: score,
                                stringMilestoneAmount: stringMilestoneAmount,
                                length: currentWord.length,
                                rewards: { setupStringQuest: 10, setupBeforeStringQuest: setupMovesAvailable }
                            });
                            setupMovesAvailable = 10 + setupMovesAvailable;
                        } else if (stringMilestoneAmount % 200 !== 0) {
                            milestones.push({
                                word: currentWord,
                                stringQuest: true,
                                chain: chain,
                                string: score,
                                stringMilestoneAmount: stringMilestoneAmount,
                                length: currentWord.length,
                                rewards: { gridRefreshStringQuest: 10, gridRefreshBeforeStringQuest: gridRefreshBonusesAvailable }
                            });
                            gridRefreshBonusesAvailable = 10 + gridRefreshBonusesAvailable;
                        }
                        updateBonusButton();
                        updateGridRefreshButton();
                    };
                } catch (e) {
                    console.error("String milestone failed", e);
                }

                try {
                    // Applies chain milestones
                    if (chainMilestones.includes(chain)) { 
                        const chainQuestIndex = chainMilestones.indexOf(chain); 
                        // Remove it so it can't trigger again
                        chainMilestones.splice(chainQuestIndex, 1); 
                        // Apply reward 
                        if (chain != 128) {
                            milestones.push({ 
                                word: currentWord, 
                                chainQuest: true, 
                                chain: chain, 
                                length: currentWord.length, 
                                rewards: { setupChainQuest: (0.5 * chain), 
                                    gridRefreshChainQuest: (0.5 * chain), 
                                    setupBeforeChainQuest: setupMovesAvailable, 
                                    gridRefreshBeforeChainQuest: gridRefreshBonusesAvailable } }); 
                            setupMovesAvailable = setupMovesAvailable + (0.5 * chain);
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + (0.5 * chain);
                        }
                        if (chain == 128) { 
                            milestones.push({ 
                                word: currentWord, 
                                chainQuest: true, 
                                chain: chain, 
                                length: currentWord.length, 
                                rewards: { setupChainQuest: (0.5 * chain), 
                                    gridRefreshChainQuest: (0.5 * chain), 
                                    setupBeforeChainQuest: setupMovesAvailable, 
                                    gridRefreshBeforeChainQuest: gridRefreshBonusesAvailable,
                                    wildcardUnlocked: true } });
                            setupMovesAvailable = setupMovesAvailable + (0.5 * chain);
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + (0.5 * chain);
                        } 
                        updateBonusButton(); 
                        updateGridRefreshButton(); 
                    };          
                } catch (e) {
                    console.error("Chain milestone failed", e);
                }

                try {
                    // Applies word length milestones
                    if (wordLengthMilestones.includes(currentWord.length)) {
                        const wordQuestIndex = wordLengthMilestones.indexOf(currentWord.length);
                        // Remove it so it can't trigger again
                        wordLengthMilestones.splice(wordQuestIndex, 1);


                        //Applies bonus or shuffle for word length milestones
                        if (currentWord.length % 2 === 0 && currentWord.length >= 7) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    setupWordQuest: currentWord.length, 
                                    setupBeforeWordQuest: setupMovesAvailable,
                                    lives: 1 
                                }
                            });
                            setupMovesAvailable = setupMovesAvailable + currentWord.length;
                            updateBonusButton();
                            totalLives++;
                            updateStatus();
                        } else if (currentWord.length % 2 !== 0 && currentWord.length >= 7) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    gridRefreshWordQuest: currentWord.length,
                                    gridRefreshBeforeWordQuest: gridRefreshBonusesAvailable,
                                    lives: 1 
                                }
                            });
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + currentWord.length;
                            updateGridRefreshButton();
                            totalLives++;
                            updateStatus();
                        } else if (currentWord.length % 2 === 0 && currentWord.length > 6) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    setupWordQuest: currentWord.length, 
                                    setupBeforeWordQuest: setupMovesAvailable 
                                }
                            });
                            setupMovesAvailable = setupMovesAvailable + currentWord.length;
                            updateBonusButton();
                        } else if (currentWord.length % 2 !== 0 && currentWord.length > 6) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    gridRefreshWordQuest: currentWord.length, 
                                    gridRefreshBeforeWordQuest: gridRefreshBonusesAvailable 
                                }
                            });
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + currentWord.length;
                            updateGridRefreshButton();
                        }
                    };
                } catch (e) {
                    console.error("Word milestone failed", e);
                }

                try {
                    //Applies no-bonus streak milestones
                    if (streakMilestones.includes(noBonusStreak)) {
                        const streakQuestIndex = streakMilestones.indexOf(noBonusStreak);
                        // Remove it so it can't trigger again
                        streakMilestones.splice(streakQuestIndex, 1);
                        // Apply reward
                        milestones.push({
                            word: currentWord,
                            streakQuest: true,
                            length: currentWord.length,
                            rewards: {
                                setupStreakQuest: noBonusStreak,
                                gridRefreshStreakQuest: noBonusStreak,
                                setupBeforeStreakQuest: setupMovesAvailable,
                                gridRefreshBeforeStreakQuest: gridRefreshBonusesAvailable
                            }
                        });
                        setupMovesAvailable = setupMovesAvailable + noBonusStreak;
                        gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + noBonusStreak;
                        updateBonusButton();
                        updateGridRefreshButton();
                    };
                } catch (e) {
                    console.error("Streak milestone failed", e);
                }

                milestonesBtn.classList.add('anim-bonus');

                renderMilestones();
                saveGameState();
            }

            function nextMileStones() {
                const nextString = stringMilestones[0];
                const nextStringToGo = nextString - score;
                const nextChain = chainMilestones[0];
                const nextChainToGo = nextChain - chain;
                const nextWordLength = `${wordLengthMilestones[0]}, ${wordLengthMilestones[1]}, ${wordLengthMilestones[2]}, ${wordLengthMilestones[3]}`; // show next 4 word lengths
                const nextStreak = streakMilestones[0];

                let milestoneSummary = `<p class="sq-para" style="font-size:8pt; text-align:left;">Shooting for:
                    <br>${nextString}+ string // ${nextStringToGo} to go
                    <br>chain ${nextChain} // ${nextChainToGo} to go
                    <br>${nextWordLength} letter words
                    <br>no-bonus streak of ${nextStreak} // currently at ${noBonusStreak}, best ${bestNoBonusStreak}</p>`;

                if (isActiveGame == false) { 
                    milestoneSummary = `<p class="sq-para" style="font-size:8pt; text-align:left;">GAME OVER! 
                    <br>${score} string chain ${chain}
                    <br>best no-bonus streak of ${bestNoBonusStreak}</p>`;
                }
                
                document.getElementById("nextMilestoneInfo").innerHTML = milestoneSummary;
                // return milestoneSummary;
            }







            function getOrdinal(n) {
                const s = ["th", "st", "nd", "rd"];
                const v = n % 100;
                return n + (s[(v - 20) % 10] || s[v] || s[0]);
            }


            function renderRewards(q) {
                nextMileStones();
                const headerParts = [];
                const rewardLines = [];

                if (q.stringQuest) headerParts.push(`${q.stringMilestoneAmount}+ string`);
                if (q.chainQuest) headerParts.push(`chain ${q.chain}`);
                if (q.wordQuest) headerParts.push(`${q.length} letters`);
                if (q.streakQuest) headerParts.push(`no-bonus streak of ${q.rewards.setupStreakQuest}`);
                if (q.penalty) {
                    const ordinalPenalty = getOrdinal(q.penaltyNumber);
                    headerParts.push(`${ordinalPenalty} penalty`);
                }

                const headerLine =
                        `${headerParts.join(", ")}<br><span class="sq-word">${q.word.toLowerCase()}</span>`
                ;

                //STRING QUEST REWARDS
                if (q.rewards?.setupStringQuest) {
                    rewardLines.push(`+${q.rewards.setupStringQuest} makes ${(q.rewards.setupStringQuest + q.rewards.setupBeforeStringQuest)} ||`);
                }
                if (q.rewards?.gridRefreshStringQuest) {
                    rewardLines.push(`+${q.rewards.gridRefreshStringQuest} makes # ${(q.rewards.gridRefreshStringQuest + q.rewards.gridRefreshBeforeStringQuest)}`);
                }

                //CHAIN QUEST REWARDS
                if (q.rewards?.gridExpanded) {
                    rewardLines.push(`4x4 grid unlocked`);
                    // rewardLines.push(`milestones unlocked`);
                }
                if (q.rewards?.setupChainQuest) {
                    rewardLines.push(`+${q.rewards.setupChainQuest} makes ${(q.rewards.setupBeforeChainQuest + q.rewards.setupChainQuest)} ||`);
                }
                if (q.rewards?.gridRefreshChainQuest) {
                    rewardLines.push(`+${q.rewards.gridRefreshChainQuest} makes # ${(q.rewards.gridRefreshBeforeChainQuest + q.rewards.gridRefreshChainQuest)}`);
                }
                if (q.rewards?.wildcardUnlocked) {
                    rewardLines.push(`wildcard unlocked`);
                }

                //WORD QUEST REWARDS
                if (q.rewards?.lives) {
                    rewardLines.push(`+1 life for ${q.length} letters`);
                }
                if (q.rewards?.setupWordQuest) {
                    rewardLines.push(`+${q.rewards.setupWordQuest} makes ${(q.rewards.setupBeforeWordQuest + q.rewards.setupWordQuest)} ||`);
                }
                if (q.rewards?.gridRefreshWordQuest) {
                    rewardLines.push(`+${q.rewards.gridRefreshWordQuest} makes # ${(q.rewards.gridRefreshBeforeWordQuest + q.rewards.gridRefreshWordQuest)}`);
                }

                //STREAK QUEST REWARDS
                if (q.rewards?.setupStreakQuest) {
                    rewardLines.push(`+${q.rewards.setupStreakQuest} makes ${(q.rewards.setupStreakQuest + q.rewards.setupBeforeStreakQuest)} ||`);
                }
                if (q.rewards?.setupStreakQuest) {
                    rewardLines.push(`+${q.rewards.gridRefreshStreakQuest} makes # ${(q.rewards.gridRefreshStreakQuest + q.rewards.gridRefreshBeforeStreakQuest)}`);
                }

                //PENALTIES
                if (q.rewards?.setupPenalty) {
                    rewardLines.push(`-${q.rewards.setupPenalty} makes ${(q.rewards.setupBeforePenalty - q.rewards.setupPenalty)} ||`);
                }
                if (q.rewards?.gridRefreshPenalty) {
                    rewardLines.push(`-${q.rewards.gridRefreshPenalty} makes # ${(q.rewards.gridRefreshBeforePenalty - q.rewards.gridRefreshPenalty)}`);
                }
                if (q.rewards?.livesPenalty) {
                    rewardLines.push(`-${q.rewards.livesPenalty} life for ${q.penaltyReason}`);
                }
                // if (q.rewards?.consecThreshold) {
                //     rewardLines.push(`next bonus overuse penalty at ${q.rewards.consecThreshold} in a row`);
                // }



                // --- Assemble ---
                return `
                    <p class="sq-para">
                    ${headerLine}
                    ${rewardLines.length ? `<br><small>${rewardLines.join("<br>")}</small>` : ""}
                    </p>
                `;
            }




            function renderMilestones() {
                const merged = Object.values(
                    milestones.reduce((map, quest) => {
                        const key = `${quest.word}|${quest.chain}`;

                        if (!map[key]) {
                            map[key] = {
                                ...quest,
                                rewards: { ...quest.rewards }
                            };
                        } else {
                            // merge reasons
                            map[key].wordQuest ||= quest.wordQuest;
                            map[key].chainQuest ||= quest.chainQuest;
                            map[key].stringQuest ||= quest.stringQuest;
                            map[key].streakQuest ||= quest.streakQuest;
                            map[key].penalty ||= quest.penalty;

                            // preserve max / meaningful values
                            map[key].length = Math.max(map[key].length ?? 0, quest.length ?? 0);
                            map[key].stringMilestoneAmount = Math.max(
                                map[key].stringMilestoneAmount ?? 0,
                                quest.stringMilestoneAmount ?? 0
                            );

                            // merge rewards
                            map[key].rewards = {
                                ...map[key].rewards,
                                ...quest.rewards
                            };
                        }

                        return map;
                    }, {})
                );

                milestonesContent.innerHTML = merged
                    .reverse()
                    .map(q => renderRewards(q))
                    .join("");

                // streakinfo.innerHTML = `best no-bonus streak is ${bestNoBonusStreak} words`;
            }


            // function renderMilestones() {
            //     const merged = Object.values(
            //         milestones.reduce((map, quest) => {
            //             const key = `${quest.word}|${quest.rewards}`;

            //             if (!map[key]) {
            //                 map[key] = {
            //                     ...quest,
            //                     rewards: { ...quest.rewards }
            //                 };
            //             } else {
            //                 map[key].rewards = {
            //                     ...map[key].rewards,
            //                     ...quest.rewards
            //                 };
            //             }

            //             return map;
            //         }, {})
            //     );

            //     milestonesContent.innerHTML = merged
            //         .map(q => renderRewards(q))
            //         .join("");
            // }

            function rollbackGrid() {
                const savedGridState = localStorage.getItem("stringChainState");
                const gridState = JSON.parse(savedGridState);
                grid = gridState.grid;
                gridSize = gridState.gridSize;
                // messageElement.textContent = `GRID ROLLBACK STATE: ${grid}`
                // grid = gridFallback; // ALT VERSION - ALSO NOT WORKING
                // renderGrid();
            }

            function showDefinitions(word) {
                // Fetch up to first 3 definitions and show them
                fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)
                    .then(res => res.json())
                    .then(data => {
                        if (!Array.isArray(data)) throw new Error();
                        let defs = [];
                        data.forEach(entry => {
                            entry.meanings?.forEach(meaning => {
                                meaning.definitions?.forEach(defObj => {
                                    if (defs.length < 3) defs.push(defObj.definition);
                                });
                            });
                        });
                        definitionsElement.innerHTML = defs.length
                            ? `<strong>${word}</strong>:<br>${defs.map(d => `- ${d}`).join('<br>')}`
                            : `No definitions found for "${word}".`;
                    })
                    .catch(() => {
                        definitionsElement.textContent = `No definitions found for "${word}".`;
                    });
            }
            //END OF CHANGING STATES


            //CORE GAMEPLAY
            function randomLetter() {
                return alphabet[Math.floor(Math.random() * alphabet.length)];
            }

            function randomWord() {
                return starterWords[Math.floor(Math.random() * starterWords.length)];
            }














            const asteriskModal = document.getElementById("asteriskModal");
            const alphaGrid = asteriskModal.querySelector(".alpha-grid");

            // Close modal if clicking outside content
            asteriskModal.addEventListener("click", (e) => {
                if (e.target === asteriskModal) {
                    pendingAsteriskCell = null;
                    asteriskModal.classList.add("hidden");
                }
            });




            let pendingAsteriskCell = null; // the cell being replaced

            // Build A–Z buttons + one asterisk
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ*?".split("");
            letters.forEach(l => {
                const btn = document.createElement("button");
                btn.textContent = l;
                if (l === "?") {
                    btn.id = "helpBtn"; // or btn.classList.add("helpBtn");
                }
                btn.addEventListener("click", () => chooseAsteriskLetter(l));
                alphaGrid.appendChild(btn);
            });

            // Called when a letter is chosen
            function chooseAsteriskLetter(letter) {
                if (!pendingAsteriskCell) return;

                if (letter === "*") {
                    // Exit: keep the bonus intact
                    pendingAsteriskCell = null;
                    asteriskModal.classList.add("hidden");
                    return;
                }


                if (letter === "?") {
                    //show basic instruction
                    if (wildcardOne.classList.contains('opacity-hide') && wildcardThree.classList.contains('opacity-hide')) {
                        wildcardOne.classList.remove('opacity-hide');
                        wildcardTwo.classList.remove('opacity-hide');
                        helpBtn.classList.add("selected");   // when showing instructions
                        return;
                    }

                    //Show even more info
                    if (wildcardThree.classList.contains('opacity-hide') && !(wildcardOne.classList.contains('opacity-hide'))) {
                        wildcardThree.classList.remove('opacity-hide');
                        helpBtn.classList.add("selected");   // when showing instructions
                        return;
                    }

                    // Hide all info if already shown
                    if (!wildcardOne.classList.contains('opacity-hide') && !wildcardThree.classList.contains('opacity-hide')) {
                        wildcardOne.classList.add('opacity-hide');
                        wildcardTwo.classList.add('opacity-hide');
                        wildcardThree.classList.add('opacity-hide');
                        helpBtn.classList.remove("selected");   // when showing instructions
                        return;
                    }

                    // wildcardOne.classList.remove('opacity-hide');
                    // wildcardTwo.classList.remove('opacity-hide');
                    // wildcardThree.classList.remove('opacity-hide');
                    // // alphaGrid.btn.classList.add('selected');
                    // return;
                }








                // Replace board asterisk with chosen letter
                const cell = pendingAsteriskCell;
                const r = parseInt(cell.dataset.row, 10);
                const c = parseInt(cell.dataset.col, 10);

                grid[r][c] = letter;
                cell.textContent = letter;
                cell.dataset.type = "grid";

                pendingAsteriskCell = null;
                asteriskModal.classList.add("hidden");
                bonusCounter++;
                bonusTicker = "*" + bonusCounter;
                playedWords.add(bonusTicker);
                updateHistory();
                bonusTicker = '';
                saveGameState();
                // Auto-select this cell after replacement
                selectCell(cell);
            }




            // Expose this function for selectCell
            function openAsteriskModal(cell) {
                pendingAsteriskCell = cell;
                asteriskModal.classList.remove("hidden");
            }




            function selectCell(cell) {
                // cell.classList.remove('selected');
                if (!specialModeActive) { messageElement.textContent = "" };




                // --- Handle Asterisk Bonus Early ---
                if (cell.textContent === "*") {
                    openAsteriskModal(cell);
                    return; // stop here, wait for modal choice
                }




                const type = cell.dataset.type;
                const isSelected = selected.includes(cell);
                // --- Helpers ---
                const getSelectedOfType = (t) => selected.filter(c => c.dataset.type === t);
                const deselect = (c) => {
                    c.classList.remove('selected');
                    selected = selected.filter(s => s !== c);
                };
                const updateLastSelected = () => {
                    if (selected.length === 1) {
                        lastSelectedCell = selected[0];
                        lastSelectedType = lastSelectedCell.dataset.type;
                    }
                };
                const dropFirstOf = (t) => deselect(getSelectedOfType(t)[0]);

                // --- Toggle Off ---
                if (isSelected) {
                    deselect(cell);
                    updateLastSelected();
                    return;
                }

                // --- Count current types ---
                let count = {
                    word: getSelectedOfType('word').length,
                    grid: getSelectedOfType('grid').length,
                    insert: getSelectedOfType('insert').length
                };

                // --- Determine legality and resolve conflicts ---
                if (type === 'grid') {
                    if (count.grid === 1) {
                        dropFirstOf('grid');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                        // Hard early exit from branch logic
                    } else if (count.word === 1 && count.insert === 1) {
                        dropFirstOf(lastSelectedType === 'word' ? 'insert' : 'word');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    } else if (count.word === 2) {
                        dropFirstOf('word');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    }
                }
                else if (type === 'insert') {
                    if (count.insert === 1) {
                        dropFirstOf('insert');
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    } else if (count.word === 1 && count.grid === 1) {
                        dropFirstOf(lastSelectedType === 'grid' ? 'word' : 'grid');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    } else if (count.word === 2) {
                        dropFirstOf('word');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    }
                }
                else if (type === 'word') {
                    if (count.word === 2) {
                        dropFirstOf('word');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    } else if (count.grid === 1 && count.insert === 1) {
                        dropFirstOf(lastSelectedType === 'grid' ? 'insert' : 'grid');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    }
                }

                // --- Limit total selections to 2 ---
                if (selected.length === 2) {
                    selected.forEach(c => {
                        if (c !== lastSelectedCell) deselect(c);
                    });
                }

                // --- Finalize Selection ---
                cell.classList.add('selected');
                selected.push(cell);
                lastSelectedCell = cell;
                lastSelectedType = type;
            }


            function renderWord() {
                wordContainer.innerHTML = '';

                const insertSlotStart = document.createElement('div');
                insertSlotStart.className = 'insert-slot';
                insertSlotStart.dataset.type = 'insert';
                insertSlotStart.dataset.index = 0;

                insertSlotStart.addEventListener('click', () => selectCell(insertSlotStart));
                wordContainer.appendChild(insertSlotStart);

                for (let i = 0; i < currentWord.length; i++) {
                    const letterDiv = document.createElement('div');
                    letterDiv.className = 'letter';
                    letterDiv.textContent = currentWord[i];
                    letterDiv.dataset.type = 'word';
                    letterDiv.dataset.index = i;
                    // fitWordContainer();

                    // Highlight if selected (selected is an array of indices)

                    if (selected.includes(i)) {
                        letterDiv.classList.add('selected');
                    }

                    letterDiv.addEventListener('click', () => selectCell(letterDiv));
                    wordContainer.appendChild(letterDiv);

                    const insertSlot = document.createElement('div');
                    insertSlot.className = 'insert-slot';
                    insertSlot.dataset.type = 'insert';
                    insertSlot.dataset.index = i + 1;
                    // fitWordContainer();


                    // if (specialModeActive) insertSlot.classList.add('special');


                    if (selected.includes(i + 1)) {
                        insertSlot.classList.add('selected');
                    }

                    insertSlot.addEventListener('click', () => selectCell(insertSlot));
                    wordContainer.appendChild(insertSlot);

                }
                fitWordContainer();
            }

            function renderGrid() {
                // maybePlaceAsterisk();
                gridElement.innerHTML = '';
                // gridElement.style.gridTemplateColumns = `repeat(${gridSize}, 45px)`;
                gridElement.style.gridTemplateColumns = `repeat(${gridSize}, 45px)`;
                // gridElement.style.gridTemplateRows = `repeat(${gridSize}, var(--cell-size)px)`;

                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.textContent = grid[r][c] || '';

                        // Mark empty cells as 'used' (meaning no letter present)
                        if (!grid[r][c]) cell.classList.add('used');

                        cell.dataset.type = 'grid';
                        cell.dataset.row = r;
                        cell.dataset.col = c;


                        const cellId = `${r},${c}`;
                        if (selected.includes(cellId)) {
                            cell.classList.add('selected');
                        }


                        cell.addEventListener('click', (event) => {
                            if (cell.classList.contains("used")) {
                                event.stopPropagation(); // optional
                                return; // ignore click
                            }
                            selectCell(cell);
                        });
                        gridElement.appendChild(cell);
                    }
                }
            }

            function initGrid() {
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        // If cell is not already an asterisk, replace it with a new letter
                        if (grid[r] && grid[r][c] === "*" && chain > 0) {
                            continue; // keep existing bonus
                        }
                        if (!grid[r]) grid[r] = [];
                        grid[r][c] = randomLetter();
                    }
                }
                renderGrid();
                gridFallback = grid;
            }

            //#region replenishGrid Function working

            // function replenishGrid() {
            //     for (let r = 0; r < gridSize; r++) {
            //         if (grid[r].every(cell => cell === null)) {
            //             for (let c = 0; c < gridSize; c++) {
            //                 grid[r][c] = randomLetter();
            //             }
            //         }
            //     }

            //     for (let c = 0; c < gridSize; c++) {
            //         if (grid.every(row => row[c] === null)) {
            //             for (let r = 0; r < gridSize; r++) {
            //                 grid[r][c] = randomLetter();
            //             }
            //         }
            //     }

            //     if (currentWord.length >= 6 && gridSize === 3 && !specialModeActive) {
            //         const oldGrid = grid.map(row => row.slice()); // copy current 3x3

            //         // Build new 4x4 grid, start as null
            //         const newSize = 4;
            //         const newGrid = Array.from({ length: newSize }, () => Array(newSize).fill(null));

            //         // Preserve existing letters/empties in top-left 3x3
            //         for (let r = 0; r < 3; r++) {
            //             for (let c = 0; c < 3; c++) {
            //                 newGrid[r][c] = oldGrid[r][c]; // may be a letter or null
            //             }
            //         }

            //         // Refresh ONLY the used cells (nulls) inside the original 3x3
            //         for (let r = 0; r < 3; r++) {
            //             for (let c = 0; c < 3; c++) {
            //                 if (newGrid[r][c] === null) {
            //                     newGrid[r][c] = randomLetter();
            //                 }
            //             }
            //         }

            //         // Populate the new right column (c = 3) and bottom row (r = 3)
            //         for (let r = 0; r < 4; r++) newGrid[r][3] = randomLetter();
            //         for (let c = 0; c < 4; c++) newGrid[3][c] = randomLetter();

            //         // Commit expansion
            //         gridSize = 4;
            //         grid = newGrid;
            //     }

            //     renderGrid();
            // }

            //#endregion


            // Track earned bonuses

            function checkAsteriskBonus(chain) {
                if (chain >= 128) {
                    // Calculate the most recent threshold
                    const threshold = 128 + Math.floor((chain - 128) / 32) * 32;
                    // const threshold = Math.floor((chain) / 5) * 5; //test mode
                    if (threshold > lastAsteriskThreshold) {
                        asteriskEarned++;
                        lastAsteriskThreshold = threshold;
                    }
                }
            }

            function maybePlaceAsterisk(refreshedCells) {
                if (asteriskEarned > 0 && refreshedCells.length > 0) {
                    const [r, c] = refreshedCells[Math.floor(Math.random() * refreshedCells.length)];
                    grid[r][c] = "*";
                    asteriskEarned--;
                }
            }

            function replenishGrid() {
                let refreshedCells = [];

                // Refill empty rows
                for (let r = 0; r < gridSize; r++) {
                    if (grid[r].every(cell => cell === null)) {
                        for (let c = 0; c < gridSize; c++) {
                            grid[r][c] = randomLetter();
                            refreshedCells.push([r, c]);
                        }
                    }
                }

                // Refill empty columns
                for (let c = 0; c < gridSize; c++) {
                    if (grid.every(row => row[c] === null)) {
                        for (let r = 0; r < gridSize; r++) {
                            grid[r][c] = randomLetter();
                            refreshedCells.push([r, c]);
                        }
                    }
                }

                // Place asterisk if earned
                maybePlaceAsterisk(refreshedCells);

                // Handle 3x3 → 4x4 expansion
                if (currentWord.length >= 6 && gridSize === 3 && !specialModeActive) {
                    const oldGrid = grid.map(row => row.slice());
                    const newSize = 4;
                    const newGrid = Array.from({ length: newSize }, () => Array(newSize).fill(null));

                    // Preserve old 3x3
                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            newGrid[r][c] = oldGrid[r][c];
                        }
                    }

                    // Refill used/nulls inside old 3x3
                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            if (newGrid[r][c] === null) {
                                newGrid[r][c] = randomLetter();
                                refreshedCells.push([r, c]);
                            }
                        }
                    }

                    // Populate new row + col
                    for (let r = 0; r < 4; r++) {
                        newGrid[r][3] = randomLetter();
                        refreshedCells.push([r, 3]);
                    }
                    for (let c = 0; c < 4; c++) {
                        newGrid[3][c] = randomLetter();
                        refreshedCells.push([3, c]);
                    }

                    gridSize = 4;
                    grid = newGrid;
                    // dummyBtn1.classList.remove("span-0");
                    dummyBtn1.classList.remove("span-0");
                    // dummyBtn3.classList.remove("span-0");
                    gridRefreshBtn.classList.add("span-2");

                    playedWords.add("(4x4)");
                    updateHistory();
                    milestonesBtn.classList.remove("hidden");
                    wordLengthMilestones.splice(0, 1);
                    milestones.push({
                            word: currentWord,
                            wordQuest: true,
                            chain: chain,
                            length: currentWord.length,
                            rewards: { gridExpanded: true }
                        });
                    // milestonesSummary +=
                    //     `<p><small><small><small>4x4 grid unlocked for 6+ letters: <span style="font-family: 'Courier New', monospace;">${currentWord.toLowerCase()}</span></small></small></small><br>`;

                    // Place asterisk if earned (again for expansion refresh)
                    maybePlaceAsterisk(refreshedCells);
                }
                saveGameState();
                renderGrid();
            }



















            function clearSelection() {
                selected.forEach(s => s.classList.remove('selected'));
                selected = [];
            }


            function applyMove() {
                if (selected.length === 0) return false;
                let moveHappened = false;

                if (selected.length === 1 && selected[0].dataset.type === 'word') {
                    const idx = parseInt(selected[0].dataset.index);
                    currentWord = currentWord.slice(0, idx) + currentWord.slice(idx + 1);
                    moveHappened = true;
                } else if (selected.length === 2) {
                    const types = selected.map(s => s.dataset.type);
                    if (types.includes('grid') && types.includes('word')) {
                        const gridCell = selected.find(s => s.dataset.type === 'grid');


                        const wordCell = selected.find(s => s.dataset.type === 'word');
                        const idx = parseInt(wordCell.dataset.index);
                        currentWord = currentWord.slice(0, idx) + gridCell.textContent + currentWord.slice(idx + 1);
                        grid[gridCell.dataset.row][gridCell.dataset.col] = null;
                        moveHappened = true;
                    } else if (types.every(t => t === 'word')) {
                        const [a, b] = selected.map(s => parseInt(s.dataset.index));
                        let arr = currentWord.split('');
                        [arr[a], arr[b]] = [arr[b], arr[a]];
                        currentWord = arr.join('');
                        moveHappened = true;
                    } else if (types.includes('grid') && types.includes('insert')) {
                        const gridCell = selected.find(s => s.dataset.type === 'grid');


                        const insertSlot = selected.find(s => s.dataset.type === 'insert');
                        const pos = parseInt(insertSlot.dataset.index);
                        let arr = currentWord.split('');
                        arr.splice(pos, 0, gridCell.textContent);
                        currentWord = arr.join('');
                        grid[gridCell.dataset.row][gridCell.dataset.col] = null;
                        moveHappened = true;
                    } else if (types.includes('word') && types.includes('insert')) {
                        const wordCell = selected.find(s => s.dataset.type === 'word');
                        const insertSlot = selected.find(s => s.dataset.type === 'insert');
                        let fromIdx = parseInt(wordCell.dataset.index);
                        let toIdx = parseInt(insertSlot.dataset.index);
                        if (fromIdx < toIdx) toIdx--;
                        let arr = currentWord.split('');
                        let [char] = arr.splice(fromIdx, 1);
                        arr.splice(toIdx, 0, char);
                        currentWord = arr.join('');
                        moveHappened = true;


                    }
                }
                return moveHappened;
            }


            function validateWord(previousWord) {
                const lower = currentWord.toLowerCase();
                if (playedWords.has(lower)) {
                    messageElement.textContent = `${currentWord} already used!`;
                    highlightPlayed(currentWord);
                    rollbackGrid();
                    alreadyUsedAnimation();
                    activateSpecialMode();
                    currentWord = previousWord;
                    renderWord();
                    // grid = gridFallback;
                    // renderGrid();
                    showTemporaryMessage();
                    saveGameState();
                    return;
                }

                if (
                    starterWords.includes(currentWord.toUpperCase()) ||
                    allowList.includes(currentWord.toUpperCase()) ||
                    LOCAL_WORDS.has(lower)
                ) {
                    playedWords.add(lower);
                    updateHistory();
                    lastValidWord = currentWord;
                    score += currentWord.length;
                    chain++;
                    checkAsteriskBonus(chain);
                    if ((chain % 5 === 0) && chain > 4) {
                        setupMovesAvailable++;
                        updateBonusButton();
                        bonusAnimation();

                    }
                    if (Math.floor(score / 30) > Math.floor((score - currentWord.length) / 30) && score > 29) {
                        gridRefreshBonusesAvailable++;
                        updateGridRefreshButton();
                        gridRefreshAnimation();
                    }
                    scoreElement.textContent = score;
                    chainElement.textContent = chain;
                    if (chain != 1) { messageElement.textContent = "Valid word!" }; //FROM LOCAL LIST
                    showTemporaryMessage();
                    clearSpecialMode(); // Nov 4 EDIT
                    greenAnimation();
                    playAnimation();
                    showDefinitions(lower);
                    replenishGrid();
                    gridFallback = grid;
                    noBonusStreak++;
                    bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                    consecutiveBonuses = 0;
                    updateMilestones();
                    updateStatus();
                    saveGameState();
                    return;
                }

                fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${lower}`)
                    // fetch(`https://cors.isomorphic-git.org/https://api.dictionaryapi.dev/api/v2/entries/en/${lower}`)
                    .then(res => {
                        if (!res.ok) throw new Error();
                        return res.json();
                    })
                    .then(() => {
                        playedWords.add(lower);
                        updateHistory();
                        lastValidWord = currentWord;
                        score += currentWord.length;
                        chain++;
                        checkAsteriskBonus(chain);
                        if ((chain % 5 === 0) && chain > 4) {
                            setupMovesAvailable++;
                            updateBonusButton();
                            bonusAnimation();
                        }
                        if (Math.floor(score / 30) > Math.floor((score - currentWord.length) / 30) && score > 29) {
                            gridRefreshBonusesAvailable++;
                            updateGridRefreshButton();
                            gridRefreshAnimation();
                        }
                        scoreElement.textContent = score;
                        chainElement.textContent = chain;
                        messageElement.textContent = "Yes, valid word!";
                        sa_event(() => "api_" + currentWord); //LOG API-VALIDATED WORDS (NOT ON LOCAL LIST)
                        clearSpecialMode(); // SEP 1 EDIT
                        greenAnimation();
                        playAnimation();
                        showDefinitions(lower);
                        replenishGrid();
                        gridFallback = grid;
                        noBonusStreak++;
                        bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                        consecutiveBonuses = 0;
                        updateMilestones();
                        updateStatus();
                        saveGameState();
                        showTemporaryMessage();
                        return;
                    })
                    .catch(() => {
                        livesLost++;

                        noBonusStreak = 0;
                        sa_event(() => "invalid_" + currentWord); //LOG INVALID WORDS
                        // let penalty = currentWord.length * livesLost;
                        milestones.push({
                                word: `(${currentWord})`,
                                penalty: true,
                                penaltyNumber: livesLost,
                                penaltyReason: 'invalid word',
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    setupPenalty: Math.floor(0.5 * setupMovesAvailable),
                                    setupBeforePenalty: setupMovesAvailable,
                                    gridRefreshPenalty: Math.floor(0.5 * gridRefreshBonusesAvailable),
                                    gridRefreshBeforePenalty: gridRefreshBonusesAvailable,
                                    livesPenalty: 1
                                }
                            });
                        updateStatus();
                        setupMovesAvailable -= Math.floor(0.5 * setupMovesAvailable);
                        gridRefreshBonusesAvailable -= Math.floor(0.5 * gridRefreshBonusesAvailable);

                        playedWords.add(lower + `(-` + livesLost + `)`);

                        // bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                        // noBonusStreak = 0;
                        updateHistory();
                        messageElement.textContent = currentWord + `, unknown word`;
                        currentWord = lastValidWord;
                        renderWord();
                        rollbackGrid();
                        // grid = gridFallback;
                        // renderGrid();
                        updateBonusButton();
                        updateGridRefreshButton();
                        redAnimation();


                        if (livesLost >= totalLives) {
                            messageElement.textContent += ", GAME OVER.";
                            saveHighScore();
                            disableGame();
                            saveGameState();
                        }
                        scoreElement.textContent = score;
                        chainElement.textContent = chain;

                        // updateStatus();
                        // updateDisallowedWords();
                        saveGameState();
                        showTemporaryMessage();
                    });
            }

            function completeMove(validate = true) {
                let originalWord = currentWord;
                let moved = applyMove();
                clearSelection();
                renderWord();
                if (!moved) {
                    messageElement.textContent = "Not a valid move. Click + for guidance"; //MAX 42 chars
                    showTemporaryMessage();
                    return;
                }
                if (validate) validateWord(originalWord);
                // clearSpecialMode();
                // replenishGrid();
            }
            //END OF CORE GAMEPLAY
            loadGameState();




        </script>


        <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>

</html>
