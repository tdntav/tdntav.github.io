<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Stringchain is a word game. Replace, add, swap, or delete a letter to make a new word. How long can you make your chain of words?">
    <title>stringchain - word game</title>
    <link rel="icon" href="/favicon.ico">
    <script>window.sa_event = window.sa_event || function () { var a = [].slice.call(arguments); window.sa_event.q ? window.sa_event.q.push(a) : window.sa_event.q = [a] };</script>
    <style>
        :root {
            --grid-size: 3;
            /* will be overwritten by JS */
            --cell-size: 68px;

            --gap: 8px;
            --rail-width: 62px;
            --grid-width: 236px;

            --rounding: 8px;
            --rounding-small: 4px;


            /* document.documentElement.style.setProperty("--cell-size", "green"); */



            --bg: #123;
            --text: #cde;

            --accent: #456;
            --accent-text: #cde;

            --positive-feedback: #7da;
            --pos-fb-text: var(--bg);

            --negative-feedback: #a77;
            --disabled: #234;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--positive-feedback);
            --selected-text: var(--pos-fb-text);
            --selected-border: 2px solid var(--selected-cell);
        }

/* #REGION OUTLINE TESTING - REMOVE LATER */    
        /*
        * { outline: 2px dotted red }
        * * { outline: 2px dotted green }
        * * * { outline: 2px dotted orange }
        * * * * { outline: 2px dotted blue }
        * * * * * { outline: 1px solid red }
        * * * * * * { outline: 1px solid green }
        * * * * * * * { outline: 1px solid orange }
        * * * * * * * * { outline: 1px solid blue } 
        */
/* #ENDREGION OUTLINE TESTING - */        

/* * {box-sizing: border-box;} */

        .first-green {

            --rounding: 4px;
            --rounding-small: 2px;

            --bg: #021;
            --text: #6ea;

            --accent: #165;
            --accent-text: #6ea;

            --positive-feedback: #0f8;
            --pos-fb-text: var(--bg);

            --negative-feedback: #a7c;
            --disabled: #243;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--positive-feedback);
            --selected-text: var(--pos-fb-text);
            --selected-border: 2px solid var(--selected-cell);
        }

        .first-red {

            --rounding: 22px;
            --rounding-small: 11px;

            --bg: #310;
            --text: #f84;

            --accent: #621;
            --accent-text: #f84;

            --positive-feedback: #d7a;
            --pos-fb-text: var(--bg);

            --negative-feedback: #a77;
            --disabled: #410;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--text);

            --selected-cell: var(--positive-feedback);
            --selected-text: var(--pos-fb-text);
            --selected-border: 2px solid var(--selected-cell);
        }

        .not-too-light {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #9ab;
            --text: #123;

            --accent: #def;
            --accent-text: #456;

            --positive-feedback: #396;

            --disabled: #789;
            --negative-feedback: #721;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: #fde;
            --selected-text: var(--accent-text);
            --selected-border: 2px solid var(--selected-cell);


        }

        .green-pops {
            --rounding: 18px;
            --rounding-small: 12px;

            --bg: #111;
            --text: #fff;

            --accent: #6c9;
            --accent-text: #000;

            --positive-feedback: #396;

            --disabled: #666;
            --negative-feedback: #721;

            --wordcell: #ccc;
            --wordcell-text: #333;
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: #ea1;
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .winery {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #312;
            --text: #fde;

            --accent: #645;
            --accent-text: #cab;

            --positive-feedback: #5b8;
            --pos-fb-text: var(--bg);

            /* --disabled: #435; */
            --disabled: #435;
            
            --negative-feedback: #500;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--disabled);
            --selected-border: 2px solid var(--selected-cell);

        }

        .tannery {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #fed;
            --text: #321;

            --accent: #cba;
            --accent-text: #654;

            --positive-feedback: #396;

            --negative-feedback: #833;
            --disabled: #a98;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .yello-pops {
            --rounding: 20px;
            --rounding-small: 10px;

            --bg: #111;
            --text: #fff;

            --accent: #c92;
            --accent-text: #000;

            --positive-feedback: #6c9;

            --disabled: #860;
            --negative-feedback: #800;

            --wordcell: #444;
            --wordcell-text: #fff;
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--accent);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--accent);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .too-light {
            --rounding: 4px;
            --rounding-small: 2px;

            --bg: #fff;
            --text: #666;

            --accent: #eee;
            --accent-text: #555;

            --positive-feedback: #7cf;

            --negative-feedback: #321;
            --disabled: #aaa;

            --wordcell: var(--accent);
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--gridcell);

            --selected-cell: #6ad;
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);



        }

        .greenery {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #020;
            --text: #dfb;

            --accent: #0c0;
            --accent-text: #000;

            --positive-feedback: #dfb;

            --negative-feedback: #000;
            --disabled: #372;

            --wordcell: #6a5;
            --wordcell-text: var(--accent-text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--wordcell-text);
            --gridcell-border: 2px solid var(--gridcell);

            --selected-cell: var(--positive-feedback);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);



        }

        .pinko {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #fdf;
            --text: #606;

            --accent: #faf;
            --accent-text: #606;

            --positive-feedback: #5b8;

            --negative-feedback: #a02;
            --disabled: #a4a;

            --wordcell: #fff;
            --wordcell-text: var(--disabled);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--accent);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--accent);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);



            /* --button-border: 3px solid #000; */
        }

        .minimal-animal {
            --rounding: 24px;
            --rounding-small: 12px;

            --bg: #eee;
            --text: #555;

            --accent: #f87;
            --accent-text: #eee;

            --positive-feedback: #0c6;

            --negative-feedback: #000;
            --disabled: #333;

            --wordcell: #999;
            --wordcell-text: var(--bg);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--wordcell-text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);



        }

        .minimal-liminal {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #ddd;
            --text: #456;

            --accent: #abc;
            --accent-text: #text;

            --positive-feedback: #7da;

            --negative-feedback: #a66;
            --disabled: #89a;

            --wordcell: #fff;
            --wordcell-text: var(--text);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--wordcell);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .dark-grey {
            --rounding: 2px;
            --rounding-small: 2px;

            --bg: #111;
            --text: #ccc;

            --accent: #777;
            --accent-text: #text;

            --positive-feedback: #5b8;

            --negative-feedback: #c66;
            --disabled: #444;

            --wordcell: var(--accent);
            --wordcell-text: var(--text);
            --wordcell-border: 2px solid var(--accent);

            --gridcell: var(--accent);
            --gridcell-text: var(--wordcell-text);
            --gridcell-border: 2px solid var(--accent);

            --selected-cell: var(--text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);


        }

        .blue-pops {
            --rounding: 8px;
            --rounding-small: 4px;

            --bg: #033;
            --text: #fff;

            --accent: #2aa;
            --accent-text: var(--bg);

            --positive-feedback: #0ff;

            --negative-feedback: #815;
            --disabled: #477;

            --wordcell: #cff;
            --wordcell-text: var(--bg);
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--text);
            --gridcell-border: 2px solid var(--disabled);

            --selected-cell: #055;
            --selected-text: var(--text);
            --selected-border: 2px solid var(--selected-cell);
        }

        .hi-contrast {
            --rounding: 6px;
            --rounding-small: 3px;

            --bg: #101;
            --text: #ddd;

            --accent: #a7f;
            --accent-text: var(--bg);

            --positive-feedback: #daf;

            --negative-feedback: #b43;
            --disabled: #645;

            --wordcell: #fff;
            --wordcell-text: #000;
            --wordcell-border: 2px solid #fff;

            --gridcell: var(--text);
            --gridcell-text: var(--bg);
            --gridcell-border: 2px solid var(--text);

            --selected-cell: #a8f;
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);
        }

        .fruit-salad {
            --rounding: 26px;
            --rounding-small: 14px;

            --bg: #fef;
            --text: #606;

            --accent: #fab;
            --accent-text: #606;

            --positive-feedback: #adf;

            --disabled: #b8b;
            --negative-feedback: #800;

            --wordcell: var(--accent);
            --wordcell-text: #fff;
            --wordcell-border: 2px solid var(--wordcell);

            --gridcell: var(--bg);
            --gridcell-text: var(--accent);
            --gridcell-border: 2px solid var(--wordcell);

            --selected-cell: var(--accent-text);
            --selected-text: var(--bg);
            --selected-border: 2px solid var(--selected-cell);

        }

        /* END OF THEMES*/
        html, body { overflow-x: hidden;
            /* height: 100%; */
        }

        body {
            font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif;
            background: var(--bg);
            /* background-image: linear-gradient(to top, var(--accent), var(--bg)); */

            max-width: 400px;
            margin: auto;
            /* margin: 0; */
            /* overflow-x: hidden; */
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            /* padding: 10px; */
            font-size: 20pt;
        }

        h1,
        h3 {
            font-family: "Courier New", monospace;
            margin: 20px 0 5px 0;
            text-align: center;
        }

        h4,
        h5,
        h6 {
            /* font-family: "Courier New", monospace; */
            margin: 0 0 5px 0;
            text-align: center;
        }

        .scores {
            position: relative;
            padding-block: 10px;
            /* padding-right:22px; */
            font-size: 15pt;
            flex-wrap: wrap;
            text-align: center;
            width: 100%;
            height: 22px;
            font-family: 'Courier New', Courier, monospace;
            z-index: 1;
            /* font-weight: bold; */
            /* background-image: linear-gradient(to top, var(--wordcell), var(--bg)); */
        }

        .message {
            /* position: relative; */
            /* bottom: 2px; */
            font-size: 11pt;
            border-radius: var(--rounding) var(--rounding) 0px 0px;
            font-family: 'Courier New', Courier, monospace;
            flex-wrap: wrap;
            text-align: center;
            color: var(--text);
            height: 66px;
            width: 100%;
            background-image: linear-gradient(to top, var(--bg), var(--accent));
            padding-block: 15px;
            opacity: 75%;
            z-index: -1;
        }

        .scale-wrapper {
            transform: scale(var(--scale-var));
            object-fit: contain;
            display: flex;
            width:100%;
            justify-content: center;
            /* overflow: hidden; */
            background: transparent;
            padding: 10px;
            transform-origin: center;
            transition: transform 1s ease;
            border-radius: var(--rounding);
            z-index: 2;
        }

        .word-container {
            /* transform: scale(var(--scale-var)); */
            background: transparent;
            display: flex;
            align-items: center;
            /* flex-wrap: wrap; */
            justify-content: center;
            margin-bottom: 10px;
            padding: 2px;
            border-radius: var(--rounding);
        }

        .letter,
        .insert-slot {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--rounding-small);
            text-transform: uppercase;
            cursor: pointer;
            margin: 5px;
            background-color: var(--wordcell);
            color: var(--wordcell-text);
            border: var(--wordcell-border);
        }

        .letter {
            width: 28px;
            height: 60px;
            margin: 3px;
        }

        .insert-slot {
            width: 12px;
            height: 30px;
            opacity:50%;
        }

        .selected {
            /* animation-name: animate-selected; */
            /* animation-duration: 0.3s; */
            /* animation-timing-function: ease-out; */
            border: var(--selected-border);
            color: var(--selected-text);
            background: var(--selected-cell);
            filter: none;
            opacity:100%;
        }

        

        @keyframes animate-selected {
            0% {
                transform: scaleY(90%);
            }

            100% {
                transform: scaleY(100%);
            }
        }

        .special {
            background: linear-gradient(var(--bg), var(--accent));
        }

        .special-sauce {
            background: none;
            background-color: none;
        }



















        .game-area {
            width: 360px;
            margin: 20px 50px var(--gap);
            box-sizing: border-box;
        }

        .play-grid-layout {
            display: grid;
            grid-template-columns: var(--rail-width) var(--grid-width) var(--rail-width);
            /* column-gap: var(--gap); */
        }


        /* LETTER GRID (auto-adjusts with JS) */
        .grid {
            display: grid;
            box-sizing: border-box;
            justify-content: center;
            align-content: center;
            margin:none;
            /* grid-template-columns: repeat(var(--grid-size), var(--cell-size)); */
            /* grid-template-rows: repeat(var(--grid-size), var(--cell-size)); */
            row-gap: var(--gap);
            column-gap: var(--gap);
        }




        /* RAILS (rows match grid) */
        .rail {
            display: grid;
            margin: none;
            padding: none;
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: var(--gap);
            width: var(--rail-width);
        }
        






        /* BUTTONS */
        .rail-btn {
            width: 100%;
            height: 100%;
            border: none;
            margin: none;
            padding:none;
            /* border: var(--gridcell-border); */
            color: var(--accent-text);
            box-sizing: border-box;
            background: var(--accent);
        }

        /*spans all rows*/
        .rail-btn.span {
            grid-row: span var(--grid-size);
        }

        /*spans 2 rows*/
        .rail-btn.span-2 {
            grid-row: span 2;
        }

        /*spans 3 rows*/
        .rail-btn.span-3 {
            grid-row: span 3;
        }

        .rail-btn.span-0 {
            display: none;
        }




































        /* 
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(12vw, 100vw));
            margin: auto;
            row-gap: 7px;
            column-gap: 10px;
            padding: auto;
        } */


        .grid-cell {
            box-sizing: border-box;
            border: var(--gridcell-border);
            color: var(--gridcell-text);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--gridcell);
            border-radius: var(--rounding);
            text-transform: uppercase;
            cursor: pointer;
            font-size: 16pt;
            /* width: var(--cell-size); */
            /* this also needs to be edited in renderGrid function */
            /* height: var(--cell-size); */
        }

        .grid-cell.used {
            background: transparent;
            cursor: default;
            border: 2px solid transparent;
        }

        .grid-cell.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
        }

        .button-row {
            display: flex;
            gap: 0.5px;
            justify-content: center;
            width: 90%;
            flex-wrap: wrap;
            z-index: 1;
        }




        .button-row button {
            margin: 3px;
            padding: 10px;
            font-family: inherit;
            color: var(--accent-text);
            border-radius: var(--rounding);
            border: 2px solid var(--selected-cell);
            flex: 1 1 30%;
            min-width: 80px;
        }






        button {
            background: var(--accent);
            /* margin: 10px 0px; */
            /* padding: 0px 10px; */
            color: var(--accent-text);
            border-radius: var(--rounding);
            /* border: 2px solid var(--accent); */
            border: none;
            margin: none;
            font-size: 11pt;
            height: var(--cell-size);
        }


        .collapseModal {
            display: none;
            position: fixed;
            top: 377px;
            /* left:300px; */
            /* right:0px; */

            align-self: center;
            justify-self: center;
            align-items: center;
            text-align: center;
            margin-block: 0px;
            margin-inline: 4px;
            border-radius: var(--rounding);
            border: 2px solid var(--wordcell);
            background: var(--wordcell-text);
            color: var(--wordcell);
            font-size: 18pt;
            height: var(--cell-size);
            width: var(--rail-width);
            opacity: 50%;
            z-index: 1001;

        }

        .scrollBtn {
            display: none;
            position: fixed;
            top: 364px;
            /* left:0; */
            /* right:-24px; */
            align-self: center;
            justify-self: center;
            /* transform: translateY(200px); */
            border-radius: var(--rounding);
            background: var(--wordcell-text);
            color: var(--wordcell);
            margin-top: 15px;
            height: var(--cell-size);
            width: var(--rail-width);
            border: 2px solid var(--wordcell);
            opacity: 50%;
            font-size: 18pt;
            z-index: 999;
            /* border-radius: 23px; */
            /* margin: 0.5px; */
            /* border: 2px solid var(--selected-cell); */
        }



        .newgame {
            box-sizing: border-box;
            width: 360px;     
            padding: var(--gap);
            margin: var(--gap) 0px;
            display: block;
            background-image: linear-gradient(to right, var(--text), var(--accent), var(--accent-text));
            border: 2px solid var(--accent-text);
            height: var(--cell-size);
        }

        .help {
            border-radius: 22px;
            /* margin: 0.5px; */
            /* border: 2px solid var(--selected-cell); */
            height: 44px;
            width: 44px;
            align-items: center;
            text-align: center;
            margin-block: 0px;
            margin-inline: 4px;
            padding: auto;
        }

        .help-dark {
            border-radius: var(--rounding);
            background: var(--bg);
            color: var(--text);
            margin-top: 15px;
            min-height: 40px;
            min-width: 40px;
            opacity: 50%;
        }

        button:disabled,
        .disabled {
            background: var(--disabled);
            color: var(--accent-text);
            cursor: default;
            border: 2px solid transparent;
            /* filter:blur(1px); */
            /* opacity:67%; */

        }





        #anti-move-wrapper {
            height: 36px;
            /* font-size: 10pt; */
            /* margin: 5px 0; */
            /* color: var(--text); */
            /* text-align: top; */
            align-items: top;
            /* opacity: 45%; */
            padding: auto;
            margin: 0;
            width: 100%;
        }



        #status {
            font-size: 13pt;
            font-family: 'Courier New', Courier, monospace;
            margin: -10px 0px 8px 0px;
            color: var(--accent);
            /* text-align:end; */
            /* align-items: top; */
            /* opacity: 66%; */
            max-height: 6px;
            width: 100%;
            text-align: center;
            /* letter-spacing: 0.5em; */
            /* padding-top:-5px; */
            /* margin-top: -15px; */
        }
        /*
        .milestones-1 {
            background: var(--bg);
            color: var(--text);
            font-size: 12pt;
            overflow-y: auto; 
            padding-inline: auto;
            border-radius: var(--rounding);
        }
        */

        #highScores {
            box-sizing: border-box;
            margin-block: 10px 0px;
            padding-block: 0px 10px;
            margin-inline:auto;
            width:100%;
            background:var(--wordcell);
            color: var(--wordcell-text);
            border-radius: var(--rounding);
            /* border: 6px solid var(--positive-feedback); */
            /* opacity:50%; */
        }

        #allTimeBestDisplay {
            box-sizing: border-box;
            margin-block: 10px 0px;
            padding-block: 5px 0px;
            margin-inline:auto;
            width:100%;
            background:var(--accent);
            color: var(--accent-text);
            border-radius: var(--rounding);
            /* opacity:50%; */
        }

        #history {
            display: block;
            white-space: normal;
            word-wrap: break-word;
            text-align: justify;
            box-sizing: border-box;
            width: 360px;            
            overflow-y: auto; 
            overscroll-behavior: contain;
            min-height:10px;
            max-height: 132px;
            font-size: 12pt;
            font-family: "Courier New", monospace;
            color: var(--accent-text);
            /* border: 2px solid var(--accent); */
            /* box-sizing: border-box; */
            background: var(--accent);
            padding-inline: 20px;
            padding-block: var(--gap);
            /* margin-inline: 20px; */
            margin-block:0px;
            border-radius: var(--rounding);
        }


        mark.highlight {
            background: var(--wordcell-text);
            /* text-decoration: underline 3px solid var(--wordcell); */
            color: var(--wordcell);
            /* padding: 4px; */
            /* border: 2px solid var(--bg); */
            border-radius: var(--rounding);
            /* font-weight: bold; */
            /* opacity:75%; */
            transition: font-color text-decoration 5s ease;
        }

        mark.highlight.fade {
            color: transparent;
        }




        #definitions {
            font-size: 11pt;
            color: var(--text);
            margin-bottom: 20px;
            width: 85%;
            background: var(--gridcell);
            color: var(--gridcell-text);
            border: var(--gridcell-border);
            padding-inline: 2.5%;
            padding-block: 10px;
            border-radius: var(--rounding);
            opacity: 66%
        }

        #rules,
        #about {
            background: var(--wordcell);
            padding: 10px;
            margin: 10px;
            /* border-radius: 5px; */

            color: var(--wordcell-text);
            /* width: 80%; */
            font-size: 15px;
        }

        #dropdown {
            background: var(--wordcell);
            padding-block: 20px;
            margin: 0px 10px 0px;
            border-radius: 0 0 var(--rounding) var(--rounding);

            margin: 0px 0px 10px;

            color: var(--wordcell-text);
            width: 100%;
            font-size: 14px;
            text-align: center;
        }

        .high-score-table {
            border: 5px solid;
            border-collapse: collapse;
            border-color: var(--wordcell-text);
            font-size: 11pt;
            margin-inline: auto;


            width: 94%;

        }

        th,
        tr,
        td {
            padding: 8px;
            border: 2px solid;
            border-collapse: collapse;
            border-color: var(--wordcell-text);
            text-align: center;
        }

        .highlight-reel {
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            /* font-size: 9pt; */
            width: auto;
            /* padding:8px; */
            height: 10px;
            /* background-image: linear-gradient(to top, var(--word-cell), var(--accent)); */
            /* background: var(--wordcell-text); */
            /* color: var(--wordcell); */
        }

        .demo-div {
            box-sizing: border-box;
            width: 360px;
            background: var(--bg);
            font-size: 22pt;
            border-radius: var(--rounding);
            display: flex;
            flex-direction: column;
            padding-block: 20px;
            padding-inline:20px;
            /* background-image: linear-gradient(to top, var(--bg), var(--accent)); */
            /* border: 6px solid var(--accent); */
            /* align-items: center; */
            /* justify-content: center; */
            /* gap: 0rem; */
            /* margin: 0; */
            /* padding: 0; */
            /* box-sizing: border-box; */
            /* height:min-content; */
            /* overflow:unset; */
        }


        .demo-board {
            width: 100%;
            /* transform: scale(1); */
            overflow: hidden;

            transform-origin: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            /* <— don’t vertically center entire board */
            gap: 0rem;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            height: fit-content;
            background-image: linear-gradient(to bottom, var(--bg), var(--accent));
            border-radius:var(--rounding);
        }

        .demo-para {
            margin-block: 0px;
            /* remove top margin */
            font-size: 11pt;
            color: var(--text);
            text-align: center;
            /* line-height: 1.4; */
        }

        .grid-demo {
            display: grid;
            grid-template-columns: repeat(3, 36px);
            grid-auto-rows: 36px;
            /* Make cells square */
            gap: 7px;
            padding: 5px;
            margin: 20px;
            justify-items: center;
            /* center content in each cell */
            align-items: center;
            /* vertically center */
            justify-content: center;
            /* center entire grid in container */
            align-content: center;
            border-radius: 5px;
        }

        .grid-demo-four {
            display: grid;
            grid-template-columns: repeat(4, 36px);
            grid-auto-rows: 36px;
            /* Make cells square */
            gap: 7px;
            padding: 5px;
            margin: 20px;
            justify-items: center;
            /* center content in each cell */
            align-items: center;
            /* vertically center */
            justify-content: center;
            /* center entire grid in container */
            align-content: center;
            border-radius: 5px;
        }

        .demo {
            justify-content: center;
            align-content: center;
            text-justify: center;
            text-align: center;
            margin: auto;
        }

        .demo-cell {
            cursor: auto;
        }

        .demoscale {
            transform: scale(0.8);
            transform-origin: center;
            overflow: hidden;
        }


        .grid-cell-demo {
            border: var(--gridcell-border);
            color: var(--gridcell-text);
            width: 36px;
            height: 36px;
            font-size: 11pt;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--gridcell);
            border-radius: var(--rounding-small);
            text-transform: uppercase;
            cursor: auto;
        }

        .grid-cell-demo.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
        }

        .grid-cell-demo.used {
            /* background: var(--bg); */
            background:none;
            border: var(--bg);
        }


        .modal {
            position: fixed;
            top: 0;
            left: 0;            
            bottom: 0;
            right: 0;
            /* width: 100vw; */
            height: 100dvh; 
            
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;

            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }


        .modal-1 {
            position: fixed;
            top: 0;
            left: 0;            
            bottom: 0;
            right: 0;
            /* width: 100vw; */
            height: 100dvh; 
            
            display: flex;
            justify-content: center;
            align-items:center;
            z-index: 1000;

            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }

/* 
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        } */

        .modal-milestones {
            position: fixed;
            top: 43px;
            background: var(--accent);
            color: var(--accent-text);
            /* background-image: linear-gradient(to bottom, var(--accent), var(--bg));  */

            padding-block: 12px;
            padding-inline:0px;
            border-radius: var(--rounding);
            border: var(--accent) solid 2px;
            text-align: center;
            /* overflow-y:scroll; */

            /* CHANGE 1: Remove scrolling from here */
            overflow-y: hidden; 
            
            /* CHANGE 2: Use flexbox to organize the header and scroll area */
            display: flex;
            flex-direction: column;
            max-height: 80vh;
            min-height: 20vh;
            width: 400px;
            /* z-index: 1; */
            /* opacity: unset; */
        }

        .modal-wildcard {
            position: fixed;
            top: 43px;
            background: var(--accent);
            color: var(--accent-text);
            /* background-image: linear-gradient(to bottom, var(--accent), var(--bg));  */

            padding-block: 12px;
            padding-inline:30px;
            border-radius: var(--rounding);
            border: var(--accent) solid 2px;
            text-align: center;
            /* overflow-y:scroll; */

            /* CHANGE 1: Remove scrolling from here */
            overflow:hidden;
            
            /* CHANGE 2: Use flexbox to organize the header and scroll area */
            display: flex;
            flex-direction: column;
            max-height: 80vh;
            width: 340px;
            /* z-index: 1; */
            /* opacity: unset; */
        }

        .modal-missions {
            position: fixed;
            top: 43px;
            background: var(--accent);
            color: var(--accent-text);
            /* background-image: linear-gradient(to bottom, var(--accent), var(--bg));  */

            padding-block: 12px;
            /* padding-inline:30px; */
            border-radius: var(--rounding);
            border: var(--accent) solid 2px;
            text-align: center;
            /* overflow-y:scroll; */

            /* CHANGE 1: Remove scrolling from here */
            overflow:hidden;
            
            /* CHANGE 2: Use flexbox to organize the header and scroll area */
            display: flex;
            flex-direction: column;
            /* max-height:60vh; */
            max-height:300px;
            width: 400px;
            /* z-index: 1; */
            /* opacity: unset; */
        }


        .milestones-1 {
            background: var(--bg);
            color: var(--text);
            font-size: 12pt;
            overflow-y: auto; 
            padding-inline: auto;
            border-radius: var(--rounding);
            /* min-height: 60vh; */
        }



        .missions-1 {
            background: var(--bg);
            color: var(--text);
            font-size: 12pt;
            overflow-y: auto; 
            padding-inline: auto;
            border-radius: var(--rounding);
            max-height:250px; 
            /* height:auto; */
        }



        .missions-help-btn {
            display: none;
            position: fixed;
            top: 377px;
            /* left:300px; */
            /* right:0px; */

            align-self: center;
            justify-self: center;
            align-items: center;
            text-align: center;
            margin-block: 0px;
            margin-inline: 4px;
            border-radius: var(--rounding);
            border: 2px solid var(--wordcell);
            background: var(--wordcell-text);
            color: var(--wordcell);
            font-size: 18pt;
            height: var(--cell-size);
            width: var(--rail-width);
            opacity: 50%;
            z-index: 1001;

        }


/* 
        .scrollBtn {
            display: none;
            position: fixed;
            top: 364px;

            align-self: center;
            justify-self: center;

            border-radius: var(--rounding);
            background: var(--wordcell-text);
            border: 2px solid var(--wordcell);
            color: var(--wordcell);
            margin-top: 15px;
            height: var(--cell-size);
            width: var(--rail-width);
            opacity: 50%;
            font-size: 18pt;
            z-index: 999;
        } */

        .missions-help-btn.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
            opacity:100%;
        }







        .sq-word {
            font-size: 13pt;
            font-family: "Courier New", monospace;
        }

        .sq-para {
            font-size: 11pt;
        }

        .sq-para1 {
            font-size:11pt; 
            text-align:center;
            display: block;
            margin: 0;
            padding:0;
        }
        .sq-para2 {
            font-size:11pt; 
            text-align:center;
            display: block;
            margin: 0;
            padding:0;
        }


        /* #streakinfo {
            margin-top:10px;
            font-size: 9pt;
        } */


        .alpha-grid {
            display: grid;
            /* line-height: 0.1;  */
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin: 20px 0px;
            align-items: center;
            justify-content: center;
        }


        .alpha-grid button {
            /* padding: 30px 12px; */
            /* font-weight: bold; */
            /* border: 1px solid #ccc; */
            /* border-radius: var(--rounding-small); */
            /* cursor: pointer; */
            border: var(--gridcell-border);
            color: var(--gridcell-text);
            width: 42px;
            height: var(--cell-size);
            font-size: 18pt;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--gridcell);
            border-radius: var(--rounding-small);
            text-transform: uppercase;
            cursor: auto;
        }

        .alpha-grid button.selected {
            background: var(--selected-cell);
            color: var(--selected-text);
            border: var(--selected-border);
        }


        .alphagrid-1 {
            background: var(--bg);
            color: var(--text);
            font-size: 12pt;
            overflow:hidden;
            /* overflow-y: auto;  */
            /* disable scrolling*/
            /* scroll-behavior: initial;             */
            border-radius: var(--rounding);
            width:344px;
            padding: 0px 28px 48px 28px;
            align-self:center;
        }








        /* ANIMATIONS AND ANIMATION CLASSES*/

        .anim-pos {
            animation-name: animate-positive;
            animation-duration: 0.5s;
        }

        @keyframes animate-positive {
            0% {
                background-color: var(--positive-feedback);
                border-color: var(--positive-feedback);
                color: var(--bg);

                transform: scaleY(100%);
                transform: scaleX(-100%);
            }
          
            50% {
                transform: scaleY(50%);
                transform: scaleX(100%);
            }

            100% {
                background-color: var(--wordcell);
                border: var(--wordcell-border);
                color: var(--wordcell-text);

                transform: scaleY(100%);
                transform: scaleX(100%);
            }
        }


        .anim-neg {
            animation-name: animate-negative;
            animation-duration: 1s;
        }

        @keyframes animate-negative {
            0% {
                background-color: var(--negative-feedback);
            }

            100% {
                background-color: var(--bg);
            }
        }


        .anim-bonus {
            animation-name: animate-bonus;
            animation-duration: 2s;
        }

        @keyframes animate-bonus {
            0% {
                background-color: var(--positive-feedback);
                transform: scale(75%);
            }

            100% {
                background-color: var(--accent);
                transform: scale(100%);
            }
        }


        .anim-play {
            animation-name: animate-play;
            animation-duration: 0.3s;
        }

        @keyframes animate-play {
            0% {
                background-color: var(--positive-feedback);
                border-color: var(--positive-feedback);
                color: var(--bg);
                transform: scale(100%);
                /* transform: scaleX(-200%); */
                /* filter: blur(0%) */

            }
          
            50% {
                transform: scale(50%);
                /* transform: scaleX(100%); */
                /* filter: blur(50%) */

            }

            100% {
                background-color: var(--wordcell);
                border: var(--wordcell-border);
                color: var(--wordcell-text);
                transform: scale(100%);
                /* transform: scaleX(100%); */
                /* filter: blur(0%) */

            }
        }

        .anim-refresh {
            animation-name: animate-refresh;
            animation-duration: 0.5s;
        }

        @keyframes animate-refresh {
            0% {
                /* background-color: var(--positive-feedback); */
                transform: scale(75%);
            }

            100% {
                /* background-color: var(--bg); */
                transform: scale(100%);
            }
        }


        .anim-used {
            animation-name: animate-already-used;
            animation-duration: 5s;
        }

        @keyframes animate-already-used {
            0% {
                background-color: var(--disabled);
            }

            100% {
                background-color: var(--bg);
            }
        }


        .shake {
            animation: shake 0.2s ease;
        }

        @keyframes shake {
            0% {
                transform: translateX(0px);
            }

            25% {
                transform: translateX(-10px);
            }

            50% {
                transform: translateX(10px);
            }

            75% {
                transform: translateX(-10px);
            }

            100% {
                transform: translateX(0);
            }
        }

        .blur {
            filter: blur(50%)
        }

        .hidden {
            display: none;
        }

        .opacity-hide {
            opacity: 0%;
        }

        .rewards {
            font-size: 11pt;
            /* color: var(--text); */
            /* margin-top: 10px; */
            border-radius: var(--rounding);
            /* border: 1px solid var(--accent); */
            padding-block: 0px;
            padding-inline: 8px;
            margin-inline: 2px;
            background: var(--accent);
            color: var(--accent-text);
        }


        .rewards2 {
            font-size: 11pt;
            /* color: var(--text); */
            /* margin-top: 10px; */
            border-radius: var(--rounding);
            /* border: 1px solid var(--disabled); */
            padding-block: 0px;
            padding-inline: 8px;
            margin-inline: 2px;
            background: var(--text);
            color: var(--bg);
        }

        .missions-display {
            font-family: "Courier New", monospace;
            font-size: 12pt;
            /* color: var(--text); */
            /* margin-top: 10px; */
            border-radius: var(--rounding);
            /* border: 1px solid var(--accent-text); */
            /* padding-block: 4px; */
            padding: 2px;
            margin: 2px;
            background: var(--accent);
            color: var(--accent-text);
        }

        .completed {
            opacity: 40%;
        }



    </style>
</head>

<body>

    <!-- <div style="height:60px;"><br></div> -->
    <div id="dropdown" style="display:none;">
        <h1>stringchain</h1>
        <button id="themeToggle" class="help-dark">change</button> <button id="toggle-rules" class="help-dark">HOW TO
            PLAY</button> <button id="aboutBtn" class="help-dark">about</button>

        <div id="rules" style="display: none;">
            <!-- <h1>how to play</h1> -->
            <h2>PLAYABLE MOVES</h2>

            <div class="demo-div">
                <!-- EXAMPLE 1: SWAP -->
                <div class="demo-board">
                    <p class="demo-para">Swap two <b><i>word</i></b> letters by selecting both.</p>
                    <div class="word-container demoscale">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">M</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Hit the <b><i>PLAY</i></b> button to complete the move.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> 
                        <button class="bonusBtn disabled" style="border:2px solid transparent;">||</button>
                        <button class="actionBtn" style="border:var(--selected-border);">PLAY</button>
                        <button class="gridRefreshBtn disabled" style="border:2px solid transparent;">#</button>
                        </div> -->

                    <div class="word-container demoscale" style="width:75%;margin-top:5px;border:4px solid var(--positive-feedback);">
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">A</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">M</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">E</div>
                        <div class="insert-slot demo-cell selected"></div>
                    </div>
                </div>
            </div><br>
            <div class="demo-div">
                <!-- EXAMPLE 2: REARRANGE -->
                <div class="demo-board">
                    <p class="demo-para">Place a <b><i>word</i></b> letter in a <b><i>slot</i></b><br>to rearrange
                        the word.</p>
                    <div class="word-container demoscale" style="margin-top:10px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">M</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">E</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Hit <b><i>PLAY</i></b> to complete the move.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="gridRefreshBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->
                    <div class="word-container demoscale" style="width:75%;margin-top:5px;border:4px solid var(--positive-feedback);">
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">E</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">A</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">M</div>
                        <div class="insert-slot demo-cell selected"></div>
                    </div>
                </div>
            </div>
            <br>
            <div class="demo-div">
                <!-- EXAMPLE 3: DELETE -->
                <div class="demo-board">
                    <p class="demo-para">Select a single <b><i>word</i></b> letter.</p>
                    <div class="word-container demoscale">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">A</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">M</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">Hit <b><i>PLAY</i></b> to delete it<br>and make a new valid word.<br><br></p>
                    <!-- <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn"
                            style="border:var(--selected-border);">PLAY</button><button class="gridRefreshBtn disabled"
                            style="border:2px solid transparent;">#</button></div> -->

                    <div class="word-container demoscale" style="width:75%;margin-top:5px;border:4px solid var(--positive-feedback);">
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">E</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">A</div>
                        <div class="insert-slot demo-cell selected"></div>
                    </div>
                </div>
            </div>

            <p>A move can also use a letter from the grid.
            
            </p>


            <div class="demo-div"><!-- EXAMPLE 4: REPLACE -->
                <div class="demo-board">
                    <p class="demo-para">Select a <b><i>word</i></b> letter</p>
                    <div class="word-container demoscale" style="width:100%">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell selected">A</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">and a <b><i>grid</i></b> letter to replace it.</p>
                    <div class="grid-demo">
                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo selected">N</div>

                        <div class="grid-cell-demo">S</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo used"></div>

                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">E</div>
                        <div class="grid-cell-demo">T</div>
                    </div>
                    <p class="demo-para">Hit <b><i>PLAY</i></b> to confirm.<br><br></p>

                    <div class="word-container demoscale" style="width:75%;margin-top:5px;border:4px solid var(--positive-feedback);">
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">E</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">N</div>
                        <div class="insert-slot demo-cell selected"></div>
                    </div>
                </div>
            </div>
            <br>


            <div class="demo-div">
                <!-- EXAMPLE 5: INSERT -->
                <div class="demo-board">
                    <p class="demo-para">Select a <b><i>slot</i></b></p>
                    <div class="word-container demoscale" style="width:100%">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell selected"></div>
                    </div>
                    <p class="demo-para">and a <b><i>grid</i></b> letter to put there</p>
                    <div class="grid-demo">
                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo used"></div>

                        <div class="grid-cell-demo">S</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo used"></div>

                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">E</div>
                        <div class="grid-cell-demo selected">T</div>
                    </div>
                    <p class="demo-para">Engage <b><i>PLAY</i></b> to make it so<br><br></p>

                    <div class="word-container demoscale" style="width:75%;margin-top:5px;border:4px solid var(--positive-feedback);">
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">E</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">N</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                    </div>
                </div>
            </div>
            <br>

            <div class="demo-div">
                <!-- EXAMPLE: GRID COLUMN REFRESH -->
                <div class="demo-board" style="background:none;">
                    <p class="demo-para">That last move<br>completed a <b><i>grid</i></b> column.<br></p>
                    <div class="grid-demo">
                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo" style="border:4px solid var(--positive-feedback)">N</div>

                        <div class="grid-cell-demo">S</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo" style="border:4px solid var(--positive-feedback)">E</div>

                        <div class="grid-cell-demo used"></div>
                        <div class="grid-cell-demo">E</div>
                        <div class="grid-cell-demo" style="border:4px solid var(--positive-feedback)">W</div>
                    </div>
                    <p class="demo-para">New letters appear<br>in completed rows or columns.<br></p>
                </div>
            </div>









            <br>
            <h2>BONUSES</h2>
            <p>Bonuses are earned for passing milestones.</p>
            <div class="demo-div">
                <!-- EXAMPLE 6: REFRESH BUTTON -->
                <div class="demo-board" style="background:none;">
                    <p class="demo-para">
                        Play a grid refresh bonus<br>by pressing the <b>#</b> button.<br><br></p>
                    <div class="button-row demo demoscale"> <button class="bonusBtn disabled"
                            style="border:2px solid transparent;">||</button><button class="actionBtn disabled"
                            style="border:2px solid transparent;">PLAY</button><button class="gridRefreshBtn"
                            style="border:var(--selected-border);"># 1</button></div>
                    <p class="demo-para"><br>Existing grid is replaced with a fresh one.</p>
                    <div class="grid-demo selected" style="background:var(--positive-feedback);border:none;">
                        <div class="grid-cell-demo">A</div>
                        <div class="grid-cell-demo">L</div>
                        <div class="grid-cell-demo">L</div>

                        <div class="grid-cell-demo">N</div>
                        <div class="grid-cell-demo">E</div>
                        <div class="grid-cell-demo">W</div>

                        <div class="grid-cell-demo">N</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">W</div>
                    </div>
                </div>
            </div>
            <br>
            <div class="demo-div">
                <!-- EXAMPLE 6: SETUP BONUS -->
                <div class="demo-board" style="background:none;">
                    <div class="word-container demoscale" style="width:75%;margin-top:5px;">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                    <p class="demo-para">A bonus no-penalty setup move<br>is exactly what it sounds like.<br><br></p>
                    <div class="grid-demo">
                        <div class="grid-cell-demo">A</div>
                        <div class="grid-cell-demo">L</div>
                        <div class="grid-cell-demo">L</div>

                        <div class="grid-cell-demo selected">N</div>
                        <div class="grid-cell-demo">E</div>
                        <div class="grid-cell-demo">W</div>

                        <div class="grid-cell-demo">N</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">W</div>
                    </div>
                    <p class="demo-para"><br>To use one, select a move as normal but<br>hit the <b>||</b> button
                        instead of <b><i>PLAY</i></b>.<br><br><br>
                    </p>
                    <div class="button-row demo demoscale"> <button class="bonusBtn"
                        style="border:var(--selected-border);">1
                        ||</button><button class="actionBtn disabled"
                        style="border:2px solid transparent;">PLAY</button><button class="gridRefreshBtn disabled"
                        style="border:2px solid transparent;">#</button></div>
                    <!-- <div class="word-container demoscale" style="width:75%;margin-top:15px;border:5px solid var(--negative-feedback);background:var(--accent);"> -->
                        <p class="demo-para"><br>This allows you to use an invalid word
                            <br>to bridge the gap to your next word.<br>
                        </p>
                    <div class="word-container demoscale" style="width:75%;margin-top:15px;background:var(--selected-text);border:4px solid var(--selected-cell);">
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">E</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">N</div>
                        <div class="insert-slot demo-cell"></div>
                        <div class="letter demo-cell">T</div>
                        <div class="insert-slot demo-cell"></div>
                    </div>
                </div>
            </div>
            <br>
            <div class="demo-div">    
                <p class="demo-para">Consecutive bonuses up to 
                    <br>the player's total number of lives
                    <br>may be used before incurring a penalty.
                    <br><br>Lost lives still count.
                </p>
            </div>
            <br>
            <h2>MILESTONES</h2>    
            <div class="demo-div">
                <!-- EXAMPLE 8: GRID EXPAND -->
                <div class="demo-board">
                    <div class="word-container demoscale" style="width:110%;border:4px solid var(--positive-feedback);">
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">E</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">N</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">A</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">N</div>
                        <div class="insert-slot demo-cell selected"></div>
                        <div class="letter demo-cell selected">T</div>
                        <div class="insert-slot demo-cell selected"></div>
                    </div>
                    <p class="demo-para">Reach or exceed six letters<br>and the grid expands to 4x4.</p>
                    <div class="grid-demo-four selected" style="background:var(--positive-feedback);border:none;">
                        <div class="grid-cell-demo">F</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo">R</div>

                        <div class="grid-cell-demo">F</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">U</div>
                        <div class="grid-cell-demo">R</div>

                        <div class="grid-cell-demo">G</div>
                        <div class="grid-cell-demo">R</div>
                        <div class="grid-cell-demo">I</div>
                        <div class="grid-cell-demo">D</div>

                        <div class="grid-cell-demo">C</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">O</div>
                        <div class="grid-cell-demo">L</div>
                    </div>
                </div>
            </div>
            <br>
            <div class="demo-div">
            <p class="demo-para">
                <b>Milestone</b> rewards are
                <br>active from the start of the game,
                <br>but the milestones button only appears
                <br>when the 4x4 grid is unlocked for 6+ letters.
                <br><br>
            </p>
            <div class="button-row demo demoscale"> <button class="actionBtn"
                style="border:var(--selected-border);">...</button><button class="bonusBtn disabled"
                style="border:2px solid transparent;">||</button><button class="actionBtn disabled"
                style="border:2px solid transparent;">PLAY</button></div>

            <p class="demo-para">
                <br>Players get one-time rewards
                <br>for passing game milestones
                <br>and achieving no-bonus streaks.
                <br><br>Words 7+ letters are worth an extra life
                <br>until you reach the maximum of 12 lives.
                <br>
            </p>
           </div>
           <br>
           <h2>PENALTIES</h2> 
           <div class="demo-div">
            <p class="demo-para">
                <span class="sq-word">invalid word</span>
                <br><span class="rewards">-1 life</span> <span class="rewards">-half ||  # -half</span>
                <br><br>You lose one life and half your bonuses
                <br>for attempting to play an invalid word.<br><br>
                <span class="sq-word">consecutive bonus use</span>
                <br><span class="rewards">-1 life</span>
                <br><br>You can use consecutive bonuses up to
                <br>your total number of lives without penalty.
                <br><br>Even lost lives count towards
                <br>the consecutive bonus allowance.
                <br><br><b><i>Wildcards</i></b> are not bonuses.<br>Use them anytime if you have them.
                <br><br><b><i>What's a wildcard?</i></b>
                <br>Get past chain 128 to find out.  
            </p>
           </div>
            <br>
            <h2>ALSO GOOD TO KNOW</h2>
            <p style="text-align:left;">Attempting to play a previously played word does not incur a penalty. 
                This word will be highlighted in your wordlist to help you plan your next moves.
                <br>
                <br>You can see your remaining lives and track your consecutive bonus use under the current word.
                <br><br>Enjoy!
            </p>
        </div>
        <div id="about" style="display: none;">
            <p style="text-align: left;"> <b>ABOUT</b>
                <br>
                <br>Big shoutout to <b><i>dictionaryapi.dev</i></b>, <b><i>wiktionary.org</i></b> and <b><i>wordgamedictionary.com</i></b> for
                providing free dictionary resources. This is
                the spirit of
                random collaboration that embodies the internet at its best.
                <br>
                <br>Without whoever they are, whoever I am couldn't have made this game for whoever you are.
                <br>
                <br>The internet has lots of bitesize daily puzzles. These are great, but Stringchain is more
                open-ended and user-driven.<br><br>
                You can play as much as you want, whenever you want. It's not a subscription, it's not an appointment. You
                choose when and how much. Take breaks, be healthy.
                <br>
                <br>The core game, switching letters around, making words, it's really basic and simple. 
                <br>The mechanics around that should incentivise exciting gameplay. Find your flow. Complete a mission. Enjoy the scenery.
                <br>
                <br>Get a high score. Beat that high score. Screenshot that high score and challenge your
                friends. Look at your wordlist, you made that! Look at all the words you know, all these rhymes and connections! Writers, rappers, poets, word enthusiasts, this is your jam.
                <br>
                <br>Future tweaks and updates may happen, but the core game is in place now. Have at it!
                <br>
                <br>If you enjoy this game, consider buying me a coffee or putting my kids through college.
                <br>
                <br>Word nerd,<br>Dave
            </p>
        </div>
        <div id="highScores"></div>
    </div>
    <div class="scores"><span id="score">0</span>&nbsp; <b>string</b><button id="toggle-dropdown"
            class="help toggle-dropdown">+</button><b>chain</b> &nbsp;<span id="chain">0</span></div>
    <div id="anti-move-wrapper">
        <div id="message" class="message"></div>
    </div>
    <div class="scale-wrapper" id="scaleWrapper">
        <div class="word-container" id="wordContainer"></div>
    </div>
    <div id="status">...</div>

    <!-- <div class="button-row">
        <button id="bonusBtn">||</button>
        <button id="actionBtn">PLAY</button>
        <button id="gridRefreshBtn">#</button>
    </div> -->
    <!-- <div id="message" class="message"></div> -->
    <!-- <table class="no-spaces">
    <tr class="no-spaces">
        <td class="button-col">
            <button id="dummyBtn" style="opacity:0%;">?</button>
                <button id="bonusBtn">||</button>
        </td>
        <td style="border:none;margin-top:0px;">
            <div class="grid" id="letterGrid"></div>
        </td>
        <td class="button-col">
            <button id="actionBtn">PLAY</button>
            <button id="gridRefreshBtn">#</button>
        </td>
    </tr>
</table> -->
    <!-- <div id="status">...</div> -->

    <div class="game-area"> <!-- Fixed width matching your history area -->

        <div id="play-grid-layout" class="play-grid-layout">

            <div id="left-rail" class="rail left-rail">
                <!-- <button id="missionsBtn" class="rail-btn span-0 hidden">&</button> -->
                <button id="missionsBtn" class="rail-btn span-0 hidden">⇡⇡</button>

                

                <button id="bonusBtn" class="rail-btn span-2">||</button>
                <button id="milestonesBtn" class="rail-btn hidden">...</button>
                <button id="collapseModal" class="collapseModal">^</button>
                <button id="scrollBtn" class="scrollBtn">^</button>
            </div>
            <!-- <div></div>             -->
            <div class="grid" id="letterGrid"></div>
            <!-- <div></div> -->
            <div id="right-rail" class="rail right-rail">
                <button id="actionBtn" class="rail-btn span-2">PLAY</button>
                <!-- <button id="dummyBtn3" class="rail-btn span-0 opacity-hide">?</button> -->
                <button id="gridRefreshBtn" class="rail-btn">#</button>
                <button id="missions-help-btn" class="missions-help-btn">?</button>

            </div>

        </div>
    </div>
    <div id="history"></div>
    <!-- <div id="disallowed"></div> -->

    <button id="newGameBtn" class="newgame">RESTART</button>

    <div id="definitions" class="hidden"></div>
    <!-- <button id="scrollBtn" class="scrollBtn">^</button> -->
    <!-- Asterisk Letter Picker Modal -->
    <div id="asteriskModal" class="modal hidden">
        <div class="modal-wildcard">
            <h6>* WILDCARD *</h6>
                <div class="alphagrid-1">
                <p class="demo-para opacity-hide" style="text-align:left;font-size:13pt;" id="wildcard-1">
                    <br>Pick a letter...
                </p>
                <div class="alpha-grid"></div>
                <p class="demo-para opacity-hide" style="text-align:right;font-size:13pt;" id="wildcard-2">...or save for
                    later</p>
                </div>
            <!-- First wildcard when chain reaches 128, another for every additional 32 words. They appear when grid rows and columns are cleared.<br><br> -->
            <p class="demo-para hidden" style="justify-content:center;font-size:12pt;" id="wildcard-3">
                <br>After 128 words, a wildcard is awarded. It appears the next time a grid row or column refreshes.
                Another wildcard is earned for every 32 additional words.<br><br></p>
        </div>
    </div>










    <!-- Milestones Modal -->
    <div id="milestonesModal" class="modal-1 hidden">
        <div class="modal-milestones">
            

            <h6>… MILESTONES …</h6>
            <p class="demo-para" style="text-align:center;font-size:11pt;margin-top:-8px;">THIS GAME</p>
            <div id="nextMilestoneInfo"></div>
            <div id="milestones-1" class="milestones-1"></div>
            <div id="allTimeBestDisplay"></div>

        </div>
    </div>



<!--#region Missions Modal -->

<div id="missionsModal" class="modal hidden">
    <div class="modal-missions">
        <p class="demo-para hidden" style="text-align:center;font-size:11pt;" id="missions-help"></p>
        <h6>⇡⇡ MISSIONS ⇡⇡</h6><p class="demo-para" style="text-align:center;font-size:11pt;margin-top:-8px;">ALL TIME<br><br></p>
        <div id="missions-1" class="missions-1"></div>
    </div>
</div>

<!--#endregion Missions Modal -->



        <script>









            //DECLARATIONS
            const scaleWrapper = document.getElementById('scaleWrapper');
            const wordContainer = document.getElementById('wordContainer');
            const highScoresElement = document.getElementById('highScores');
            const allTimeBestElement = document.getElementById('allTimeBestDisplay');
            const gridElement = document.getElementById('letterGrid');
            const leftRail = document.getElementById('left-rail');
            const rightRail = document.getElementById('right-rail');
            const actionBtn = document.getElementById('actionBtn');
            const newGameBtn = document.getElementById('newGameBtn');
            const bonusBtn = document.getElementById('bonusBtn');
            const gridRefreshBtn = document.getElementById('gridRefreshBtn');
            const milestonesBtn = document.getElementById('milestonesBtn');
            const milestonesModal = document.getElementById('milestonesModal');
            const milestonesContent = document.getElementById('milestones-1');
            const nextMilestoneInfo = document.getElementById('nextMilestoneInfo');


            const missionsBtn = document.getElementById('missionsBtn');
            const missionsModal = document.getElementById('missionsModal');
            const missionsContent = document.getElementById('missions-1');
            const missionsHelpBtn = document.getElementById('missions-help-btn');
            const missionsHelp = document.getElementById('missions-help');


            // const streakinfo = document.getElementById('streakinfo');
            const wildcardOne = document.getElementById('wildcard-1');
            const wildcardTwo = document.getElementById('wildcard-2');
            const wildcardThree = document.getElementById('wildcard-3');
            const messageElement = document.getElementById('message');
            const scoreElement = document.getElementById('score');
            const chainElement = document.getElementById('chain');
            const historyElement = document.getElementById('history');
            // const disallowedElement = document.getElementById('disallowed');
            const statusElement = document.getElementById('status');
            const definitionsElement = document.getElementById('definitions');
            const rulesToggle = document.getElementById("toggle-rules");
            const dropdownToggle = document.getElementById("toggle-dropdown");
            const scrollBtn = document.getElementById("scrollBtn");
            const collapseModal = document.getElementById("collapseModal");
            const aboutBtn = document.getElementById("aboutBtn");
            const aboutDiv = document.getElementById("about");
            const rulesDiv = document.getElementById("rules");
            const dropdownDiv = document.getElementById("dropdown");
            const disqualified = localStorage.getItem("isDisqualified") === "true";
            const alphabet = "EEEEEEEEEAAAARRRRIIIOOONNSSSTTTLLLLCCUUUDDDPPGGHHBBMMYYFFVVWWKKXJQZ".split("");
            const starterWords = ["ACE", "ACT", "ADD", "ADO", "ADS", "AFT", "AGE", "AGO", "AIR", "ALL", "AND", "ANT", "ANY", "APE", "APT", "ARC", "ARE", "ARK", "ARM", "ART", "ASH", "ASK", "AWE", "AWL", "AXE", "BAD", "BAG", "BAN", "BAR", "BAT", "BAY", "BED", "BEE", "BEG", "BET", "BIG", "BIN", "BIT", "BOA", "BOB", "BOG", "BOP", "BOW", "BOY", "BRA", "BRO", "BUD", "BUG", "BUM", "BUS", "BUT", "BUY", "BYE", "CAB", "CAD", "CAM", "CAN", "CAP", "CAR", "CAT", "CAW", "COB", "COD", "COG", "CON", "COO", "COP", "COT", "COW", "COY", "CRY", "CUB", "CUE", "CUP", "CUR", "CUT", "DAB", "DAD", "DAG", "DAM", "DAY", "DEB", "DEN", "DEW", "DID", "DIE", "DIG", "DIN", "DIP", "DOC", "DOE", "DOG", "DON", "DOT", "DRY", "DUB", "DUD", "DUE", "DUG", "EAR", "EAT", "EEL", "EGG", "EGO", "ELF", "ELL", "EMU", "END", "ERA", "EVE", "EWE", "EYE", "FAD", "FAN", "FAR", "FAT", "FAX", "FED", "FEE", "FEW", "FIB", "FIG", "FIN", "FIR", "FIT", "FLY", "FOE", "FOG", "FOR", "FRY", "FUN", "FUR", "GAG", "GAP", "GAS", "GAY", "GEL", "GEM", "GET", "GIG", "GIN", "GOT", "GUM", "GUN", "GUT", "GUY", "GAP", "HAD", "HAM", "HAS", "HAT", "HAW", "HAY", "HEW", "HEY", "HIM", "HIP", "HIS", "HIT", "HOG", "HOP", "HOT", "HOW", "HUB", "HUE", "HUG", "HUM", "HUT", "ICE", "ILL", "INK", "INN", "ION", "JAB", "JAM", "JAR", "JAW", "JAY", "JAW", "JIG", "JOB", "JOE", "JOG", "JOT", "JOY", "JUG", "KEY", "KIT", "LAB", "LAD", "LAG", "LAP", "LAW", "LAY", "LEA", "LED", "LEG", "LET", "LID", "LIE", "LOG", "LOT", "LOW", "MAD", "MAN", "MAP", "MAT", "MAX", "MAY", "MEN", "MET", "MID", "MIX", "MOB", "MOD", "MOM", "MOP", "MOW", "MUD", "MUG", "MUM", "NAB", "NAP", "NOD", "NOT", "NOW", "NUN", "NUT", "OAR", "OAT", "ODD", "OFF", "OIL", "OLD", "ONE", "OPT", "OUR", "OUT", "OVA", "OWE", "OWL", "OWN", "PAD", "PAL", "PAN", "PAR", "PAT", "PAW", "PAY", "PEG", "PEN", "PET", "PEW", "PHI", "PIE", "PIG", "PIN", "PIT", "PLY", "POD", "POP", "POT", "PRO", "PUB", "PUG", "PUP", "PUT", "RAM", "RAN", "RAP", "RAT", "RAW", "RAY", "RED", "REP", "REV", "RIB", "RID", "RIG", "RIM", "RIP", "ROB", "ROD", "ROE", "ROT", "ROW", "RUB", "RUE", "RUG", "RUN", "RUT", "SAC", "SAD", "SAG", "SAP", "SAT", "SAW", "SAX", "SAY", "SEA", "SEE", "SET", "SEW", "SEX", "SHY", "SIB", "SIC", "SIN", "SIP", "SIR", "SIS", "SIT", "SKY", "SOB", "SOD", "SOL", "SON", "SOP", "SOS", "SOW", "SOX", "SPA", "SPY", "SUB", "SUE", "SUM", "SUN", "SUP", "TAB", "TAD", "TAG", "TAP", "TAR", "TEA", "TEE", "TEN", "THE", "TIE", "TIN", "TIP", "TOE", "TOG", "TON", "TOO", "TOP", "TOT", "TOW", "TOY", "TRY", "TUB", "TUG", "TUX", "TWO", "URN", "USE", "VAN", "VAT", "VET", "VIA", "VIE", "WAR", "WAS", "WAY", "WEB", "WED", "WEE", "WET", "WHO", "WHY", "WIN", "WIT", "WOK", "WON", "WOO", "YAK", "YAM", "YAP", "YAW", "YES", "ABLE", "ACID", "ACRE", "BACK", "BALL", "BAND", "CALM", "CAMP", "CARD", "DAWN", "DAYS", "DEAL", "EACH", "EARN", "ELSE", "FACE", "FACT", "FINE", "GAIN", "GATE", "GAVE", "GIRD", "HAIR", "HALF", "HAND", "ICON", "IDEA", "IDLE", "JACK", "JAIL", "KING", "KIND", "LACK", "LAKE", "LIMP", "MADE", "MAIL", "NAME", "NAIL", "ONCE", "ODDS", "PACK", "PAGE", "RACE", "RAIN", "SAFE", "SAIL", "TAKE", "TALE", "TINE", "UNIT", "URGE", "VARY", "VAST", "WAGE", "WAIT", "YARD", "YARN", "ZAPS"];
            const allowList = ["FLAP", "FLAPS", "FLAPPING", "FLAPPED", "FLAPPER", "FLAPPERS", "DOLLING", "DOLLED", "TOCK", "HELL", "FEWER", "YOUR", "PATTER", "DRAB", "LIVES", "LIVED", "LIVING", "HELLS", "TOW", "TOWS", "TOWED", "TOWING", "DUNK", "DUNKS", "DUNKING", "DUNKED", "TOW", "TOWS", "TOWING", "TOWED", "TIGHT", "SIFT", "DOSE", "DOSES", "DOSED", "DOSING", "KITE", "KITES", "NET", "CUE", "CUES", "CUED", "CUEING", "CUING", "RAPE", "RAPES", "RAPED", "SATES", "SATED", "SATING", "RAPING", "PEND", "PENDS", "PENDED", "PENDING", "BE", "LOOK", "LOOKS", "LOOKED", "LOOKING", "VEINY", "WEAN", "WEANS", "WEANED", "WEANING"];
            const missions = {
                "4": ["WAXY", "MEGA", "YUTZ", "PLOY", "JUNK", "FOWL", "ZINC"],
                "5": ["AUDIO", "DISCO", "NYMPH", "IRONY", "KUDOS", "WHARF"],
                "6": ["QUAINT", "JANGLY", "TERROR", "JOCKEY", "CRANKS"],
                "7": ["ROBOTIC", "NARWHAL", "FOXSKIN", "YODELER"],
                "8": ["ECLECTIC", "JUMPABLE", "VENEERED", "ICEBOXES"],
                "9": ["JUXTAPOSE", "GROTESQUE", "INJURIOUS", "YARDSTICK"],
                "10": ["CONGENITAL", "ACTIVEWEAR", "TIEBREAKER"],
                "11": ["LIGHTHEADED", "STANDOFFISH", "HUMMINGBIRD"],
                "12": ["QUANTIFIABLY", "INEXPLICABLY", "LIGHTHEARTED"],
                "13": ["DISAPPOINTING", "POSTMODERNISM"],
                "14": ["QUINTESSENTIAL", "THUNDERSHOWERS"],
                "15": ["UNDISPASSIONATE", "PICTURESQUENESS"],
                "16": ["INCOMPREHENSIBLE", "ELECTROMAGNETISM"],
                "17": ["NONRESURRECTIONAL", "INDESTRUCTIBILITY"],
                "18": ["EXTRATHERMODYNAMIC", "SUPERINDIVIDUALISM"],
                "19": ["COUNTERCONDITIONING", "UNSELFCONSCIOUSNESS"],
                "20": ["ANTIAUTHORITARIANISM"],
                "21": ["INDISTINGUISHABLENESS"],
                "22": ["HYPERCONSCIENTIOUSNESS"],
                "23": ["ANTHROPOMORPHOLOGICALLY"],
                "24": ["DISESTABLISHMENTARIANISM"],
                };
            let isActiveGame = true;
            let playedWords = new Set();
            // let disallowedWords = new Set();
            let gameID = "";
            let bonusTicker = '';
            let bonusCounter = 0;
            let currentWord = "";
            let lastValidWord = "";

            let gridSize = 3;
            let cellSize = 68;
            let grid = [];
            let gridFallback = [];
            let score = 0;
            let chain = 0;
            let selected = [];
            let setupMovesAvailable = 5;
            let gridRefreshBonusesAvailable = 5;
            let asteriskEarned = 0;
            let lastAsteriskThreshold = 0;
            let wordLengthMilestones = [ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50 ];
            let chainMilestones = [ 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576 ];
            let stringMilestones = [ 100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000 ];
            let streakMilestones = [ 10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600 ];
            let milestones = [];
            let noBonusStreak = 0;
            let bestNoBonusStreak = 0;
            let consecutiveBonuses = 0;

            let unlockedMissionTier = 4;          // highest word length revealed
            let completedMissions = new Set();    // words already completed
            let openMissions = [];                // derived, not persisted // missions currently open
            let clickNumber = 0;                 // track clicks for missions help
            let livesLost = 0;
            let totalLives = 3;
            let lastSelectedType = null;
            let lastSelectedCell = null;
            // let lastUsedGridCell = null; // Track last used cell for invalid move rollback
            let specialModeActive = false; // Track bonus special mode
            let LOCAL_WORDS = null;
            
            let allTimeString = 0;
            let allTimeChain = 0;
            let allTimeStreak = 0;
            let allTimeWordLength = 0;
            let allTimeWord = "";
            let allTimeSummary = "";

            async function loadLocalWords() {
                const response = await fetch('assets/merged-wordlists.json');
                const data = await response.json();

                // Flatten all buckets into one Set
                LOCAL_WORDS = new Set(
                    Object.values(data).flatMap(list => list)
                );
                console.log(LOCAL_WORDS);
            }
            //END OF DELARATIONS

            //BUTTONS

            actionBtn.addEventListener('click', () => {
                // playAnimation();
                completeMove(true);
            });

            dropdownToggle.addEventListener("click", () => {
                const dropdownHidden = dropdownDiv.style.display === "none";
                dropdownDiv.style.display = dropdownHidden ? "block" : "none";
                dropdownToggle.textContent = dropdownHidden ? "^" : "+";
                getHighScores();
                if (rulesDiv.style.display = "block") {
                    rulesDiv.style.display = "none";
                    rulesToggle.textContent = "HOW TO PLAY";
                }
                if (aboutDiv.style.display = "block") {
                    aboutDiv.style.display = "none";
                    aboutBtn.textContent = "about";
                }
                topFunction();
            });

            rulesToggle.addEventListener("click", () => {
                const rulesHidden = rulesDiv.style.display === "none";
                rulesDiv.style.display = rulesHidden ? "block" : "none";
                rulesToggle.textContent = rulesHidden ? "^" : "HOW TO PLAY";
                if (rulesDiv.style.display != "block") { dropdownToggle.click() };
                if (aboutDiv.style.display = "block") {
                    aboutDiv.style.display = "none";
                    aboutBtn.textContent = "about";
                }
            });

            aboutBtn.addEventListener("click", () => {
                const aboutHidden = aboutDiv.style.display === "none";
                aboutDiv.style.display = aboutHidden ? "block" : "none";
                aboutBtn.textContent = aboutHidden ? "^" : "about";
                if (aboutDiv.style.display != "block") { dropdownToggle.click() };
                if (rulesDiv.style.display = "block") {
                    rulesDiv.style.display = "none";
                    rulesToggle.textContent = "HOW TO PLAY";
                }
            });

            bonusBtn.addEventListener('click', () => {
                if (setupMovesAvailable <= 0) {
                    messageElement.textContent = "Click + for guidance.";
                    showTemporaryMessage();
                    return;
                }
                if (selected.length === 0) {
                    messageElement.textContent = "Select a playable move first";
                    showTemporaryMessage();
                    return;
                }


                let moved = applyMove();
                clearSelection();
                renderWord();
                // replenishGrid(); // MOVED TO THE END
                if (!moved) {
                    messageElement.textContent = "Invalid move. Click + for guidance.";
                    showTemporaryMessage();
                    return;
                }
                setupMovesAvailable--;
                updateBonusButton();
                bonusCounter++;
                bonusTicker = "||" + bonusCounter;
                playedWords.add(bonusTicker);
                updateHistory();
                bonusTicker = '';
                lastValidWord = currentWord;
                messageElement.innerHTML = `Bonus setup move played.`;
                bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                noBonusStreak = 0;
                consecutiveBonuses++;
                updateStatus();
                penaliseConsecutiveBonuses();
                showTemporaryMessage();
                activateSpecialMode(); //ADDED FOR BONUS MOVE EFFECT
                replenishGrid(); //MOVED TO HERE TO STOP GRID EXPAND FOR SETUP MOVE

                return;
            });

            gridRefreshBtn.addEventListener('click', () => {
                if (gridRefreshBonusesAvailable > 0) {
                    gridRefreshBonusesAvailable--;
                    bonusCounter++;
                    bonusTicker = "#" + bonusCounter;
                    playedWords.add(bonusTicker);
                    updateHistory();
                    bonusTicker = '';
                    initGrid();
                    updateGridRefreshButton();
                    messageElement.textContent = "Grid refreshed!";
                    showTemporaryMessage();
                    bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                    noBonusStreak = 0;
                    consecutiveBonuses++;
                    updateStatus();
                    penaliseConsecutiveBonuses();
                    letterGrid.classList.add('anim-refresh');
                    saveGameState();
                    setTimeout(() => {
                        letterGrid.classList.remove('anim-refresh');
                    }, 1000);
                }
            });

            newGameBtn.addEventListener('click', () => {

                if (isActiveGame == true && chain >= 5) {
                    let text = "Are you sure you want to restart?";
                    if (confirm(text) == false) {
                        return;
                    }
                }
                sa_event("new_game");
                saveHighScore();
                getHighScores();
                updateAllTimeStats();
                
                localStorage.removeItem("stringChainState");
                localStorage.removeItem("isDisqualified");
                gameID = new Date().toISOString().slice(0, 19).replace('T', ' ');
                gridSize = 3;
                cellSize = 68;
                checkPlayAreaMeasurements();
                missionsBtn.classList.add("span-0");
                // dummyBtn3.classList.add("span-0");
                gridRefreshBtn.classList.remove("span-2");
                grid = [];
                score = 0;
                chain = 0;
                setupMovesAvailable = 5;
                gridRefreshBonusesAvailable = 5;
                asteriskEarned = 0;
                lastAsteriskThreshold = 0;
                wordLengthMilestones = [ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50 ];
                chainMilestones = [ 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576 ];
                stringMilestones = [ 100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000 ];
                streakMilestones = [ 10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600 ];
                milestones = [];
                noBonusStreak = 0;
                bestNoBonusStreak = 0;
                consecutiveBonuses = 0;
                // milestonesSummary = "";
                milestonesBtn.classList.add('hidden');
                missionsBtn.classList.add('hidden');
                livesLost = 0;
                totalLives = 3;
                playedWords.clear();
                bonusTicker = '';
                bonusCounter = 0;
                clickNumber = 0;
                // disallowedWords.clear();
                gridElement.style.pointerEvents = 'auto';
                wordContainer.style.pointerEvents = 'auto';
                scoreElement.textContent = score;
                chainElement.textContent = chain;
                messageElement.textContent = '';
                // disallowedElement.textContent = '';
                updateBonusButton();
                updateGridRefreshButton();
                definitionsElement.textContent = '';
                specialModeActive = false;
                fitWordContainer();
                isActiveGame = true;
                previousWord = '';
                actionBtn.disabled = false;
                currentWord = randomWord();
                initGrid();
                renderWord();
                validateWord(previousWord);
                updateHistory();
                updateStatus();
                removeAnimation();
                clearSpecialMode();
                loadLocalWords();
                // localStorage.clear(); // FOR HARD RESET TO SEE NEW USER EXPERIENCE
                if (dropdownDiv.style.display = "block") { dropdownToggle.click(); }
            });

            milestonesBtn.addEventListener('click', () => {
                milestonesModal.classList.remove('hidden');
                collapseModal.style.display = "block";
                renderMilestones();
            });


            milestonesModal.addEventListener("click", (e) => {
                if (e.target === milestonesModal) {
                    milestonesModal.classList.add("hidden");
                    collapseModal.style.display = "none";
                    topFunction();
                }
            });

            function showMilestonesModal() {
                milestonesModal.classList.remove('hidden');
                // setTimeout(() => {
                //     milestonesModal.classList.add('hidden');
                // }, 4000); // Hide after 8 seconds
            }


            missionsBtn.addEventListener('click', () => {
                missionsModal.classList.remove('hidden');
                collapseModal.style.display = "block";
                missionsHelpBtn.style.display = "block";
                renderMissions();
            });


            missionsHelpBtn.addEventListener('click', () => {
                if (!missionsHelpBtn.classList.contains('selected')) {
                    clickNumber = 1;
                    missionsHelpBtn.classList.add('selected');
                    missionsHelp.classList.remove('hidden');
                    missionsHelp.innerHTML = `Complete half of the current level<br>to unlock the next level.<br><br>`;
                } else if (clickNumber == 1) {
                    clickNumber = 2;
                    missionsHelp.innerHTML = `Just make the word<br>to complete the mission.<br><br>`;
                } else if (clickNumber == 2) {
                    clickNumber = 3;
                    missionsHelp.innerHTML = `Missions persist between games.<br>You can undertake them at your leisure.<br><br>`;
                } else if (clickNumber == 3) {
                    clickNumber = 0;
                    missionsHelpBtn.classList.remove('selected');
                    missionsHelp.classList.add('hidden');
                    missionsHelp.innerHTML = ``;
                }
            });

            missionsModal.addEventListener("click", (e) => {
                if (e.target === missionsModal) {
                    missionsModal.classList.add("hidden");
                    collapseModal.style.display = "none";
                    missionsHelpBtn.style.display = "none";
                    topFunction();
                }
            });

            function showMissionsModal() {
                missionsModal.classList.remove('hidden');
                // setTimeout(() => {
                //     missionsModal.classList.add('hidden');
                // }, 4000); // Hide after 8 seconds
            }

            function updateAllTimeStats() {
                allTimeString = Math.max(allTimeString, score);
                allTimeChain = Math.max(allTimeChain, chain);
                allTimeStreak = Math.max(allTimeStreak, bestNoBonusStreak);
                if (allTimeWordLength <= currentWord.length) {
                    allTimeWordLength = currentWord.length;
                    allTimeWord = currentWord;
                }

                allTimeSummary = `<table style="border:none;text-align:center;align-content:center;margin-left:auto;margin-right:auto;">
                    <tr>
                        <td style="width:50%;border:none;">
                            <p class="sq-para1"><span class="rewards2">${allTimeString} string</span></p>
                        </td>
                        <td style="border:none;">
                            <p class="sq-para1"><span class="rewards2">chain ${allTimeChain}</span></p>
                        </td>
                    </tr>
                    <tr style="border:none;">
                        <td style="border:none;">
                            <p class="sq-para1"><span class="rewards2">${allTimeWordLength} letters</span><br><span class="sq-word">${allTimeWord.toLowerCase()}</span></p>
                        </td>
                        <td style="border:none;">
                            <p class="sq-para1"><span class="rewards2">no-bonus streak of ${allTimeStreak}</span></p>
                        </td>
                    </tr>
                </table>`;
                allTimeBestElement.innerHTML = `<h6>ALL TIME BEST</h6>
                    ${allTimeSummary}`;
                highScoresElement.innerHTML = `<h2>ALL TIME BEST</h2>
                    ${allTimeSummary}`;
            }

            //END OF BUTTONS

            //ANIMATIONS AND HIGHLIGHTS

            // function highlightPlayed(currentWord) {
            //     historyElement.innerHTML = historyElement.innerHTML.replace(
            //         new RegExp(currentWord, 'gi'),
            //         '<mark class="highlight">$&</mark>'
            //     );

            //     const newMarks = historyElement.querySelectorAll('mark.highlight:not(.fade)');
            //     newMarks.forEach(mark => {
            //         // setTimeout(() => mark.classList.add('fade'), 18000);  // start fade
            //         setTimeout(() => mark.outerHTML = mark.innerText, 60000); // remove
            //     });
            // }

            function highlightPlayed(currentWord) {
    const safeWord = currentWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`\\b${safeWord}\\b`, 'gi');

    // Replace and mark
    historyElement.innerHTML = historyElement.innerHTML.replace(
        regex,
        '<mark class="highlight">$&</mark>'
    );

    const marks = historyElement.querySelectorAll('mark.highlight');
    if (!marks.length) return;

    // Always target the most recent occurrence
    const target = marks[marks.length - 1];

    const containerRect = historyElement.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();

    // const offset =
    //     targetRect.top
    //     - containerRect.top
    //     - historyElement.clientHeight / 2
    //     + target.offsetHeight / 2;

    // historyElement.scrollTo({
    //     top: historyElement.scrollTop + offset,
    //     behavior: 'smooth'
    // });

        const destination =
            historyElement.scrollTop +
            (targetRect.top - containerRect.top) -
            (containerRect.height / 2) +
            (targetRect.height / 2);

    historyElement.scrollTo({
        top: Math.max(0, destination),
        behavior: 'smooth'
    });

    // Remove highlight after 20s
    marks.forEach(mark => {
        setTimeout(() => {
            if (mark.isConnected) {
                mark.replaceWith(mark.textContent);
            }
        }, 20000);
    });
}



            
// //this version works (mostly)
// function highlightPlayed(currentWord) {
//                 // Escape any special regex characters in the word
//                 const safeWord = currentWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
//                 // const characterCount = 

//                 // Match whole word only
//                 const regex = new RegExp(`\\b${safeWord}\\b`, 'gi');

//                 // Highlight the word
//                 historyElement.innerHTML = historyElement.innerHTML.replace(
//                     regex,
//                     '<mark class="highlight">$&</mark>'
//                 );
//                 const marks = historyElement.querySelectorAll('mark.highlight');
//                 const target = marks[marks.length - 1];

//                 const lineHeight = target.offsetHeight;
//                 const destination = target.offsetTop - (lineHeight * 21);

//                 historyElement.scrollTo({
//                     top: destination,
//                     behavior: 'smooth'
//                 });

//                 // Keep highlight for 60s
//                 const newMarks = historyElement.querySelectorAll('mark.highlight:not(.fade)');
//                 newMarks.forEach(mark => {
//                     setTimeout(() => mark.outerHTML = mark.innerText, 60000);
//                 });
//             }


            // //this version works
            // function highlightPlayed(currentWord) {
            //     // Escape any special regex characters in the word
            //     const safeWord = currentWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            //     // const characterCount = 

            //     // Match whole word only
            //     const regex = new RegExp(`\\b${safeWord}\\b`, 'gi');

            //     // Highlight the word
            //     historyElement.innerHTML = historyElement.innerHTML.replace(
            //         regex,
            //         '<mark id="target" class="highlight">$&</mark>'
            //     );

            //     const lineHeight = target.offsetHeight;
            //     // const destination = target.offsetTop + (lineHeight * 20);
            //     const destination = target.offsetTop - (lineHeight * 21);

            //     historyElement.scrollTo({
            //         top: destination,
            //         behavior: 'smooth'
            //     });

            //     // Keep highlight for 60s
            //     const newMarks = historyElement.querySelectorAll('mark.highlight:not(.fade)');
            //     newMarks.forEach(mark => {
            //         setTimeout(() => mark.outerHTML = mark.innerText, 60000);
            //     });
            // }



            // function highlightPlayed(currentWord) {
            //     const safeWord = currentWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            //     const regex = new RegExp(`\\b${safeWord}\\b`, 'gi');

            //     historyElement.innerHTML = historyElement.innerHTML.replace(
            //         regex,
            //         '<mark class="highlight">$&</mark>'
            //     );

            //     // Get the most recent highlight
            //     const marks = historyElement.querySelectorAll('mark.highlight');
            //     const target = marks[marks.length - 1];

            //     if (!target) return;

            //     const containerRect = historyElement.getBoundingClientRect();
            //     const targetRect = target.getBoundingClientRect();

            //     const destination =
            //         historyElement.scrollTop +
            //         (targetRect.top - containerRect.top) -
            //         (containerRect.height / 2) +
            //         (targetRect.height / 2);

            //     historyElement.scrollTo({
            //         top: destination,
            //         behavior: 'smooth'
            //     });

            //     // Fade after 60s
            //     setTimeout(() => {
            //         target.classList.add('fade');
            //         setTimeout(() => target.outerHTML = target.innerText, 1000);
            //     }, 60000);
            // }




            function playAnimation() { 
                actionBtn.classList.remove('anim-play');
                void actionBtn.offsetWidth; // reflow to restart animation
                actionBtn.classList.add('anim-play');
            }

            function redAnimation() { wordContainer.classList.add('anim-neg'); }
            function bonusAnimation() { bonusBtn.classList.add('anim-bonus'); }
            function gridRefreshAnimation() { gridRefreshBtn.classList.add('anim-bonus'); }
            function alreadyUsedAnimation() {
                wordContainer.classList.add("shake");
                // Remove class after animation so it can trigger again later
                wordContainer.addEventListener("animationend", () => {
                    wordContainer.classList.remove("shake");
                }, { once: true });
            }
            function greenAnimation() {
                const elements = wordContainer.querySelectorAll('.letter, .insert-slot');
                const animationDuration = 500; // in ms (0.5s from CSS)
                const stagger = 30; // in ms (0.03s)

                elements.forEach((el, index) => {
                    el.classList.remove('anim-pos');
                    void el.offsetWidth; // reflow to restart animation

                    el.style.animationDelay = `${index * stagger / 1000}s`;
                    el.classList.add('anim-pos');

                    // Calculate when to remove the class
                    const totalDelay = animationDuration + index * stagger;
                    setTimeout(() => {
                        el.classList.remove('anim-pos');
                        //   el.style.animationDelay = ''; // optional: clean up inline style
                    }, totalDelay);
                });
            }

            function removeAnimation() {
                if (wordContainer.classList.contains('anim-neg')) { wordContainer.classList.remove('anim-neg'); }
                if (wordContainer.classList.contains('anim-pos')) { wordContainer.classList.remove('anim-pos'); }
                if (letterGrid.classList.contains('anim-refresh')) { letterGrid.classList.remove('anim-refresh'); }
                if (bonusBtn.classList.contains('anim-bonus')) { bonusBtn.classList.remove('anim-bonus'); }
                if (gridRefreshBtn.classList.contains('anim-bonus')) { gridRefreshBtn.classList.remove('anim-bonus'); }
                if (wordContainer.classList.contains('shake')) { wordContainer.classList.remove('shake'); }
                if (actionBtn.classList.contains('anim-play')) { actionBtn.classList.remove('anim-play'); }
                if (milestonesBtn.classList.contains('anim-bonus')) { milestonesBtn.classList.remove('anim-bonus'); }

            }

            function activateSpecialMode() {
                specialModeActive = true;
                wordContainer.classList.add('special');
                messageElement.classList.add('special-sauce');
                saveGameState();
                return;
            }
            function clearSpecialMode() {
                specialModeActive = false;
                wordContainer.classList.remove('special');
                messageElement.classList.remove('special-sauce');
                saveGameState();
                return;
            }

            //END OF ANIMATIONS AND HIGHLIGHTS

            //THEMES AND PRESENTATION

            //SCROLLING ETC
            window.onscroll = function () { scrollFunction() };
            function scrollFunction() {
                if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
                    scrollBtn.style.display = "block";
                } else {
                    scrollBtn.style.display = "none";
                }
            }
            // When the user clicks on the button, scroll to the top of the document
            function topFunction() {
                document.body.scrollTop = 0;
                document.documentElement.scrollTop = 0;
            }

            scrollBtn.addEventListener("click", () => {
                if (dropdownDiv.style.display = "block") { dropdownToggle.click() };
                topFunction();
            });

            collapseModal.addEventListener("click", () => {
                topFunction();
                if (dropdownDiv.style.display = "block") { dropdownToggle.click() };
                if (asteriskModal.classList.contains("hidden") == false) { asteriskModal.classList.add("hidden") };
                collapseModal.style.display = "none";
                missionsHelpBtn.style.display = "none";
                milestonesModal.classList.add("hidden");
                missionsModal.classList.add("hidden");
            });
            //END OF SCROLLING ETC

            //THEMES
            const themeToggle = document.getElementById("themeToggle");
            const themes = ["default", "first-green", "first-red", "fruit-salad", "hi-contrast", "green-pops", "tannery", "dark-grey", "not-too-light", "winery", "minimal-liminal", "blue-pops", "pinko", "greenery", "minimal-animal", "yello-pops", "too-light"];
            let currentTheme = localStorage.getItem("theme") || "default";
            if (currentTheme !== "default") {
                document.documentElement.classList.add(currentTheme);
            }
            themeToggle.addEventListener("click", () => {
                // Remove current theme if not default
                if (currentTheme !== "default") {
                    document.documentElement.classList.remove(currentTheme);
                }

                // Cycle to next theme
                const currentIndex = themes.indexOf(currentTheme);
                const nextIndex = (currentIndex + 1) % themes.length;

                currentTheme = themes[nextIndex];

                // Apply if not default
                if (currentTheme !== "default") {
                    document.documentElement.classList.add(currentTheme);
                }

                // Save
                localStorage.setItem("theme", currentTheme);
            });
            //END OF THEMES

            //WORD CONTAINER
            function fitWordContainer() {
                let letterCount = wordContainer.querySelectorAll('.letter').length;

                // let scaleCalc = 11 / (6 + letterCount);
                let scaleCalc = 330 / ((33 * letterCount) + (17 * (letterCount + 1)) + (10 * letterCount));
                scaleCalc = Math.min(scaleCalc, 1.3);

                document.documentElement.style.setProperty('--scale-var', scaleCalc);
                return;
            }
            //END OF WORD CONTAINER

            //END OF THEMES AND PRESENTATION

            //SAVING, LOADING, HIGHSCORES

            function saveGameState() {
                const gameState = {
                    isActiveGame, 
                    gameID, 
                    currentWord, 
                    lastValidWord, 
                    gridSize, 
                    grid, 
                    gridFallback, 
                    score, 
                    chain, 
                    setupMovesAvailable, 
                    asteriskEarned, 
                    lastAsteriskThreshold, 
                    gridRefreshBonusesAvailable,
                    totalLives, 
                    livesLost, 
                    specialModeActive, 
                    bonusCounter,
                    wordLengthMilestones, 
                    chainMilestones, 
                    stringMilestones, 
                    noBonusStreak,
                    bestNoBonusStreak,
                    consecutiveBonuses,
                    streakMilestones, 
                    milestones,
                    unlockedMissionTier,
                    completedMissions: Array.from(completedMissions),
                    playedWords: Array.from(playedWords),
                    allTimeString, allTimeChain, allTimeStreak, allTimeWord, allTimeWordLength
                };
                localStorage.setItem("stringChainState", JSON.stringify(gameState));
            }

            // Load and restore directly
            function loadGameState() {
                // actionBtn.disabled = disqualified; 
                if (disqualified) {
                    newGameBtn.click();
                    return;
                }
                const saved = localStorage.getItem("stringChainState");

                if (!saved) {
                    newGameBtn.click();
                    return;
                }

                try {
                    ({
                        isActiveGame, 
                        gameID, 
                        currentWord, 
                        lastValidWord, 
                        gridSize, 
                        grid, 
                        gridFallback, 
                        score, 
                        chain, 
                        setupMovesAvailable, 
                        asteriskEarned, 
                        lastAsteriskThreshold, 
                        gridRefreshBonusesAvailable,
                        totalLives, 
                        livesLost, 
                        specialModeActive, 
                        bonusCounter,
                        wordLengthMilestones, 
                        chainMilestones, 
                        stringMilestones, 
                        noBonusStreak,
                        bestNoBonusStreak,
                        consecutiveBonuses,
                        streakMilestones, 
                        milestones,
                        unlockedMissionTier,
                        completedMissions,
                        playedWords,
                        allTimeString, allTimeChain, allTimeStreak, allTimeWord, allTimeWordLength
                    } = JSON.parse(saved));
                    // disallowedWords = new Set(disallowedWords);
                    playedWords = new Set(playedWords);
                    completedMissions = new Set(completedMissions);
                    renderWord();
                    checkPlayAreaMeasurements();
                    renderGrid();
                    updateHistory();
                    updateMilestones();
                    updateAllTimeStats();
                    // updateDisallowedWords();
                    updateBonusButton();
                    updateGridRefreshButton();
                    // showDefinitions(lastValidWord);
                    updateStatus();
                    loadLocalWords();
                    if (gridSize == 3) { 
                        missionsBtn.classList.add("span-0"); 
                        gridRefreshBtn.classList.remove("span-2"); 
                        milestonesBtn.classList.add("hidden"); 
                        missionsBtn.classList.add("hidden");
                    } else if ((gridSize == 4) && (chain >= 32)) {
                        gridRefreshBtn.classList.add("span-2"); 
                        milestonesBtn.classList.remove("hidden");
                        missionsBtn.classList.remove("span-0"); 
                        missionsBtn.classList.remove("hidden"); 
                        missionsBtn.classList.remove("opacity-hide"); 
                    } else if ((gridSize == 4) && (chain < 32)) { 
                        missionsBtn.classList.remove("span-0"); 
                        gridRefreshBtn.classList.add("span-2"); 
                        milestonesBtn.classList.remove("hidden"); 
                        missionsBtn.classList.remove("hidden");
                        missionsBtn.classList.add("opacity-hide"); 
                    }    
                    
                    scoreElement.textContent = score;
                    chainElement.textContent = chain;
                    if (specialModeActive == true) {
                        activateSpecialMode();
                    }
                    updateAllTimeStats();

                } catch (err) {
                    console.error("Error loading saved state", err);
                    newGameBtn.click();
                }
            }



            function saveHighScore() {
                const stringchainHighScore = JSON.parse(localStorage.getItem("stringchainHighScore")) || [];
                const saveTime = new Intl.DateTimeFormat(undefined, {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false // forces 24-hour clock
                })
                    .format(new Date())
                    .replace(/,/g, ''); // strip commas
                const highlight = getHighlightReel();
                const newHighScore = { saveTime, score, chain, gameID, highlight };

                // Check if an entry already exists for this gameID
                const existingIndex = stringchainHighScore.findIndex(entry => entry.gameID === gameID);

                if (chain < 5) { return };
                if (existingIndex !== -1) {
                    // Overwrite the existing record
                    stringchainHighScore[existingIndex] = newHighScore;

                    // Save and return early
                    localStorage.setItem("stringchainHighScore", JSON.stringify(stringchainHighScore));
                    return;
                }

                stringchainHighScore.push({
                    saveTime: saveTime,
                    score: score,
                    chain: chain,
                    gameID: gameID,
                    highlight: highlight
                });

                //LOG HIGHSCORE EVENT
                let gameTracker = gameID.replace(/[^\d]/g, '');
                sa_event(() =>
                    `${gameTracker}_${score}_${chain}_${highlight.replace(/ /g, '_')}`
                );

                stringchainHighScore.sort((a, b) => b.score - a.score);

                const byScore = [...stringchainHighScore]
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 3);
                const byChain = [...stringchainHighScore]
                    .sort((a, b) => b.chain - a.chain)
                    .slice(0, 3);

                const combined = [...byScore, ...byChain].filter((item, index, self) => index === self.findIndex(g => g.saveTime === item.saveTime));
                combined.sort((a, b) => b.chain - a.chain);
                localStorage.setItem('stringchainHighScore', JSON.stringify(combined));
            }

            function getHighScores() {
                const scoreTableParse = JSON.parse(localStorage.getItem('stringchainHighScore')) || [];
                let scoreTable = scoreTableParse
                scoreTable = scoreTable.filter(entry => !(entry.score === 0 && entry.chain === 0));
                const rows = scoreTable.map(entry => {
                    const highlightRow = entry.highlight && entry.highlight.trim()
                        ? `<tr><td colspan="3" class="highlight-reel">${entry.highlight}</td></tr>`
                        : "";
                    return `<tr><td>${entry.score}</td><td>${entry.chain}</td><td>${entry.saveTime}</td></tr>${highlightRow}`;
                }).join('');

                if (!rows) { return };
                // highScoresElement.innerHTML = `<h4>BEST GAMES</h4><table class = "high-score-table"><tr><th>STRING</th><th>CHAIN</th><th>SAVED</th></tr>${rows}</table>`;
            }



            // >>> FINAL getHighlightReel
            function getHighlightReel() {
                let words = Array.from(playedWords)
                    .filter(w => /^[a-zA-Z]+$/.test(w)) // Exclude entries containing any non-alphabetic character
                    .map(w => w.replace(/[|#*]/g, "").trim());
                if (words.length === 0) return "";

                const longestWordLength = Math.max(...words.map(w => w.length));
                const runs = [];
                let currentRun = [];

                // Find all runs of longest word length
                for (let i = 0; i < words.length; i++) {
                    if (words[i].length === longestWordLength) {
                        currentRun.push(i); // Store the index of the word in the current run
                    } else if (currentRun.length > 0) {
                        runs.push([...currentRun]); // Save the current run
                        currentRun = []; // Reset for the next run
                    }
                }
                if (currentRun.length > 0) {
                    runs.push([...currentRun]); // Add the last run if it exists
                }

                // Find the best run (longest run, or the last one if tied)
                const bestRun = runs.reduce((best, current) => {
                    if (current.length > best.length) return current;
                    if (current.length === best.length) return current; // Use the last run in case of a tie
                    return best;
                }, []);

                // Determine the number of words to display based on the longest word length
                let displayCount;
                if (longestWordLength >= 10) {
                    displayCount = 3;
                } else if (longestWordLength >= 7) {
                    displayCount = 4;
                } else {
                    displayCount = 5;
                }

                // Calculate the slice range based on the best run's length
                let sliceStart, sliceEnd;
                if (bestRun.length >= displayCount) {
                    sliceStart = bestRun[0];
                    sliceEnd = bestRun[0] + displayCount;
                } else {
                    const runStart = bestRun[0];
                    const runEnd = bestRun[bestRun.length - 1];
                    const runLength = bestRun.length;

                    if (runLength === displayCount - 1) {
                        sliceStart = runStart - 1;
                        sliceEnd = runStart + displayCount - 1;
                    } else if (runLength === displayCount - 2) {
                        sliceStart = runStart - 1;
                        sliceEnd = runEnd + 2;
                    } else if (runLength === 1) {
                        sliceStart = runStart - (displayCount - 2);
                        sliceEnd = runStart + 2;
                    } else {
                        sliceStart = runStart - (displayCount - runLength);
                        sliceEnd = runEnd + 1;
                    }

                    // Adjust if no word after the run is available
                    if (sliceEnd > words.length) {
                        const overflow = sliceEnd - words.length;
                        sliceStart = Math.max(0, sliceStart - overflow);
                        sliceEnd = words.length;
                    }
                }

                // Ensure sliceStart and sliceEnd are within bounds
                sliceStart = Math.max(0, sliceStart);
                sliceEnd = Math.min(words.length, sliceEnd);

                return words.slice(sliceStart, sliceEnd).join(" ");
            }
            // <<< END FINAL








            //END OF SAVING, LOADING, HIGHSCORES

            //CHANGING STATES MESSAGES TEXT
            // function updateStatus() {
            //     let livesLeft = totalLives - livesLost;
            //     // let baseStr = "■ ■ ■ ■ ■"
            //     // let xStr = "□ □ □ □ □ "
            //     let baseStr = "| | | | |"
            //     let xStr = "- - - - - "
            //     // let base = '<big><big><big>' + xStr.slice(2 * left) + baseStr.slice((2 * livesLost) - 1) + '</big></big></big>';
            //     let base = '<b>' + xStr.slice(2 * livesLeft) + baseStr.slice(2 * livesLost) + '</b>';
            //     statusElement.innerHTML = base;
            // }







            // function updateStatus() {
            //     const livesLeft = totalLives - livesLost;

            //     let output = "";

            //     // Lost lives
            //     for (let i = 0; i < livesLost; i++) {
            //         output += "- ";
            //     }

            //     // Remaining lives
            //     for (let i = 0; i < livesLeft; i++) {
            //         output += "| ";
            //     }

            //     statusElement.innerHTML = `<b>${output.trim()}</b>`;
            // }


            // Enhanced updateStatus with bonus highlighting WORK IN PROGRESS

            function updateStatus() {
                const livesLeft = Math.min(totalLives,12) - livesLost;
                let output = "";

                // We loop through the total number of lives/slots
                for (let i = 0; i < Math.min(totalLives,12); i++) {
                    // 1. Determine the character (- for lost, | for remaining)
                    const char = (i < livesLost) ? "-" : "|";
                    
                    // 2. Check if this specific slot should be highlighted by a bonus
                    // i < consecutiveBonuses means this slot is "active" or "used"
                    const isHighlighted = i < consecutiveBonuses;
                    const color = isHighlighted ? "var(--text)" : "var(--accent)";

                    // 3. Wrap in a span with the color
                    output += `<span style="color: ${color}">${char}</span> `;
                }

                statusElement.innerHTML = `<b>${output.trim()}</b>`;
                if (consecutiveBonuses == totalLives - 1) {
                messageElement.textContent = `One more bonus can be used without penalty`;
                }
                if (consecutiveBonuses == totalLives) {
                messageElement.textContent = `Play a valid word!`;
                }
            }


            function penaliseConsecutiveBonuses() {
                if ((consecutiveBonuses < (totalLives + 1))) { return; }
                livesLost++;
                consecutiveBonuses = 0;
                messageElement.textContent = `-1 life for bonus overuse`;
                milestones.push({
                                word: `(${currentWord})`,
                                penalty: true,
                                penaltyNumber: livesLost,
                                penaltyReason: `bonus overuse`,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    livesPenalty: 1
                                }
                            });
                if (livesLost >= totalLives) {
                            messageElement.textContent += ", GAME OVER.";
                            saveHighScore();
                            disableGame();
                            saveGameState();
                        }
                showTemporaryMessage();
                updateStatus();
                }


            function updateBonusButton() {
                if (setupMovesAvailable > 0) {
                    bonusBtn.textContent = `${setupMovesAvailable} ||`;
                    bonusBtn.classList.remove('disabled');
                    bonusBtn.disabled = false;
                } else {
                    bonusBtn.textContent = `||`;
                    bonusBtn.classList.add('disabled');
                    bonusBtn.disabled = true;
                }
            }

            function updateGridRefreshButton() {
                if (gridRefreshBonusesAvailable > 0) {
                    gridRefreshBtn.textContent = `# ${gridRefreshBonusesAvailable}`;
                    gridRefreshBtn.classList.remove('disabled');
                    gridRefreshBtn.disabled = false;
                } else {
                    gridRefreshBtn.textContent = `#`;
                    gridRefreshBtn.classList.add('disabled');
                    gridRefreshBtn.disabled = true;
                }
            }

            function disableGame() {
                isActiveGame = false;
                localStorage.setItem("isDisqualified", "true");
                actionBtn.disabled = true;
                bonusBtn.disabled = true;
                gridRefreshBtn.disabled = true;
                gridElement.style.pointerEvents = 'none';
                wordContainer.style.pointerEvents = 'none';
            }

            function showTemporaryMessage(message) {
                messageElement.style.display = "block";
            }

            function updateHistory() {
                historyElement.innerHTML = [...playedWords]
                    .reverse()
                    .map(w => {
                        // Check if the entry is a bonus and strip the number
                        if (w.startsWith("||")) return "|| ";
                        if (w.startsWith("#")) return "# ";
                        if (w.startsWith("*")) return "* ";

                        // Check if the entry is an incorrect attempt (contains "(")

                        if (w.includes("4x4")) return `<i>${w}</i> `;
                        if (w.includes("(")) 
                        //strip numeric characters
                            return `<i>${w.replace(/\d+/g, '')}</i> `;
                        // For regular words, append a space
                        return w + " ";
                    })
                    .join('');
            }





            function updateMilestones() {
                // Check if milestone exists for latest game state
                if (!wordLengthMilestones.includes(currentWord.length) && !chainMilestones.includes(chain) && !(stringMilestones[0] <= score) && !(streakMilestones.includes(noBonusStreak))) {
                    return;
                }

                //Apply bonuses in this order
                try {
                    //Applies string length milestones first
                    if (stringMilestones[0] <= score) {
                        //this one works a little differently, score can be exceeded
                        // Remove it so it can't trigger again
                        const stringMilestoneAmount = stringMilestones[0];
                        stringMilestones.splice(0, 1);
                        // Apply reward
                        if (stringMilestoneAmount % 200 === 0) {
                            milestones.push({
                                word: currentWord,
                                stringQuest: true,
                                chain: chain,
                                string: score,
                                stringMilestoneAmount: stringMilestoneAmount,
                                length: currentWord.length,
                                rewards: { setupStringQuest: 10, setupBeforeStringQuest: setupMovesAvailable }
                            });
                            setupMovesAvailable = 10 + setupMovesAvailable;
                        } else if (stringMilestoneAmount % 200 !== 0) {
                            milestones.push({
                                word: currentWord,
                                stringQuest: true,
                                chain: chain,
                                string: score,
                                stringMilestoneAmount: stringMilestoneAmount,
                                length: currentWord.length,
                                rewards: { gridRefreshStringQuest: 10, gridRefreshBeforeStringQuest: gridRefreshBonusesAvailable }
                            });
                            gridRefreshBonusesAvailable = 10 + gridRefreshBonusesAvailable;
                        }
                        updateBonusButton();
                        updateGridRefreshButton();
                    };
                } catch (e) {
                    console.error("String milestone failed", e);
                }

                try {
                    // Applies chain milestones
                    if (chainMilestones.includes(chain)) { 
                        const chainQuestIndex = chainMilestones.indexOf(chain); 
                        // Remove it so it can't trigger again
                        chainMilestones.splice(chainQuestIndex, 1); 
                        // Apply reward 
                        if (chain == 32) {missionsBtn.classList.remove("hidden"); missionsBtn.classList.remove("opacity-hide"); }
                        if (chain != 128) {
                            milestones.push({ 
                                word: currentWord, 
                                chainQuest: true, 
                                chain: chain, 
                                length: currentWord.length, 
                                rewards: { setupChainQuest: (0.5 * chain), 
                                    gridRefreshChainQuest: (0.5 * chain), 
                                    setupBeforeChainQuest: setupMovesAvailable, 
                                    gridRefreshBeforeChainQuest: gridRefreshBonusesAvailable } }); 
                            setupMovesAvailable = setupMovesAvailable + (0.5 * chain);
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + (0.5 * chain);
                        }
                        if (chain == 128) { 
                            milestones.push({ 
                                word: currentWord, 
                                chainQuest: true, 
                                chain: chain, 
                                length: currentWord.length, 
                                rewards: { setupChainQuest: (0.5 * chain), 
                                    gridRefreshChainQuest: (0.5 * chain), 
                                    setupBeforeChainQuest: setupMovesAvailable, 
                                    gridRefreshBeforeChainQuest: gridRefreshBonusesAvailable,
                                    wildcardUnlocked: true } });
                            setupMovesAvailable = setupMovesAvailable + (0.5 * chain);
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + (0.5 * chain);
                        } 
                        updateBonusButton(); 
                        updateGridRefreshButton(); 
                    };          
                } catch (e) {
                    console.error("Chain milestone failed", e);
                }

                try {
                    // Applies word length milestones
                    if (wordLengthMilestones.includes(currentWord.length)) {
                        const wordQuestIndex = wordLengthMilestones.indexOf(currentWord.length);
                        // Remove it so it can't trigger again
                        wordLengthMilestones.splice(wordQuestIndex, 1);


                        //Applies bonus or shuffle for word length milestones
                        if (currentWord.length % 2 === 0 && currentWord.length >= 7 && totalLives == 11) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    setupWordQuest: currentWord.length, 
                                    setupBeforeWordQuest: setupMovesAvailable,
                                    livesMaxed: true,
                                    lives: 1 
                                }
                            });
                            setupMovesAvailable = setupMovesAvailable + currentWord.length;
                            updateBonusButton();
                            totalLives++;
                            updateStatus();
                        } else if (currentWord.length % 2 === 0 && currentWord.length >= 7 && totalLives < 12) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    setupWordQuest: currentWord.length, 
                                    setupBeforeWordQuest: setupMovesAvailable,
                                    lives: 1 
                                }
                            });
                            setupMovesAvailable = setupMovesAvailable + currentWord.length;
                            updateBonusButton();
                            totalLives++;
                            updateStatus();
                        } else if (currentWord.length % 2 === 0 && currentWord.length >= 7 && totalLives == 12) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    setupWordQuest: currentWord.length, 
                                    setupBeforeWordQuest: setupMovesAvailable,
                                }
                            });
                            setupMovesAvailable = setupMovesAvailable + currentWord.length;
                            updateBonusButton();
                            updateStatus();
                        } else if (currentWord.length % 2 !== 0 && currentWord.length >= 7 && totalLives == 11) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    gridRefreshWordQuest: currentWord.length,
                                    gridRefreshBeforeWordQuest: gridRefreshBonusesAvailable,
                                    livesMaxed: true,
                                    lives: 1
                                }
                            });
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + currentWord.length;
                            updateGridRefreshButton();
                            totalLives++;
                            updateStatus();
                        } else if (currentWord.length % 2 !== 0 && currentWord.length >= 7 && totalLives < 12) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    gridRefreshWordQuest: currentWord.length,
                                    gridRefreshBeforeWordQuest: gridRefreshBonusesAvailable,
                                    lives: 1 
                                }
                            });
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + currentWord.length;
                            updateGridRefreshButton();
                            totalLives++;
                            updateStatus();
                        } else if (currentWord.length % 2 !== 0 && currentWord.length >= 7 && totalLives == 12) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    gridRefreshWordQuest: currentWord.length,
                                    gridRefreshBeforeWordQuest: gridRefreshBonusesAvailable,
                                }
                            });
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + currentWord.length;
                            updateGridRefreshButton();
                            updateStatus();
                        } else if (currentWord.length % 2 === 0 && currentWord.length > 6) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    setupWordQuest: currentWord.length, 
                                    setupBeforeWordQuest: setupMovesAvailable 
                                }
                            });
                            setupMovesAvailable = setupMovesAvailable + currentWord.length;
                            updateBonusButton();
                        } else if (currentWord.length % 2 !== 0 && currentWord.length > 6) {
                            milestones.push({
                                word: currentWord,
                                wordQuest: true,
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    gridRefreshWordQuest: currentWord.length, 
                                    gridRefreshBeforeWordQuest: gridRefreshBonusesAvailable 
                                }
                            });
                            gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + currentWord.length;
                            updateGridRefreshButton();
                        }
                    };
                } catch (e) {
                    console.error("Word milestone failed", e);
                }

                try {
                    //Applies no-bonus streak milestones
                    if (streakMilestones.includes(noBonusStreak)) {
                        const streakQuestIndex = streakMilestones.indexOf(noBonusStreak);
                        // Remove it so it can't trigger again
                        streakMilestones.splice(streakQuestIndex, 1);
                        // Apply reward
                        milestones.push({
                            word: currentWord,
                            streakQuest: true,
                            length: currentWord.length,
                            rewards: {
                                setupStreakQuest: noBonusStreak,
                                gridRefreshStreakQuest: noBonusStreak,
                                setupBeforeStreakQuest: setupMovesAvailable,
                                gridRefreshBeforeStreakQuest: gridRefreshBonusesAvailable
                            }
                        });
                        setupMovesAvailable = setupMovesAvailable + noBonusStreak;
                        gridRefreshBonusesAvailable = gridRefreshBonusesAvailable + noBonusStreak;
                        updateBonusButton();
                        updateGridRefreshButton();
                    };
                } catch (e) {
                    console.error("Streak milestone failed", e);
                }

                milestonesBtn.classList.add('anim-bonus');

                renderMilestones();
                saveGameState();
            }

            function nextMileStones() {
                const nextString = stringMilestones[0];
                const nextStringToGo = nextString - score;
                const nextChain = chainMilestones[0];
                const nextChainToGo = nextChain - chain;
                const nextWordLength = `${wordLengthMilestones[0]}, ${wordLengthMilestones[1]}, ${wordLengthMilestones[2]}, ${wordLengthMilestones[3]}`; // show next 4 word lengths
                const nextStreak = streakMilestones[0];
                const avgWordLength = Math.round(100 * score / chain) / 100;
                // <p class="sq-para2">Shooting for:</p>

                let milestoneSummary = `
                <table style="border:none;justify-content:center;align-content:center;margin:auto;">
                    <tr style="width:40%;">
                        <td style="border:none">
                            <p class="sq-para1"><span class="rewards2">${nextString}+ string</span><br>${nextStringToGo} letters to go</p>
                        </td>
                        <td style="border:none;">
                            <p class="sq-para1"><span class="rewards2">chain ${nextChain}</span><br>${nextChainToGo} words to go</p>
                        </td>
                    </tr>
                    <tr style="width:40%;">
                        <td style="border:none">
                            <p class="sq-para1"><span class="rewards2">${nextWordLength} letters</span><br>currently ${currentWord.length}, avg ${avgWordLength} letters</p>
                        </td>
                        <td style="border:none">
                            <p class="sq-para1"><span class="rewards2">no-bonus streak of ${nextStreak}</span><br>currently ${noBonusStreak}, best ${bestNoBonusStreak} words</p>
                        </td>
                    </tr>
                </table>`;

                if (isActiveGame == false) { 
                    milestoneSummary = `<p class="sq-para2">GAME OVER! 
                    <br>${score} string chain ${chain}
                    <br>best no-bonus streak of ${bestNoBonusStreak}</p>`;
                }
                
                document.getElementById("nextMilestoneInfo").innerHTML = milestoneSummary;
                // return milestoneSummary;
            }







            function getOrdinal(n) {
                const s = ["th", "st", "nd", "rd"];
                const v = n % 100;
                return n + (s[(v - 20) % 10] || s[v] || s[0]);
            }


            function renderRewards(q) {
                nextMileStones();
                const headerParts = [];
                const rewardLines = [];

                if (q.stringQuest) headerParts.push(`${q.stringMilestoneAmount}+ string`);
                if (q.chainQuest) headerParts.push(`chain ${q.chain}`);
                if (q.wordQuest) headerParts.push(`${q.length} letters`);
                if (q.streakQuest) headerParts.push(`no-bonus streak of ${q.rewards.setupStreakQuest}`);
                if (q.penalty) {
                    const ordinalPenalty = getOrdinal(q.penaltyNumber);
                    headerParts.push(`${ordinalPenalty} penalty - ${q.penaltyReason}`);
                }
                if (q.missionQuest) headerParts.push(`mission✧✧`);

                const headerLine =
                        `${headerParts.join(", ")}`
                ;

                //STRING QUEST REWARDS
                // if (q.rewards?.setupStringQuest || q.rewards?.gridRefreshStringQuest) {
                // rewardLines.push(`<span class="rewards">`);
                // }
                if (q.rewards?.setupStringQuest) {
                    // rewardLines.push(`+${q.rewards.setupStringQuest} makes ${(q.rewards.setupStringQuest + q.rewards.setupBeforeStringQuest)} ||`);
                    rewardLines.push(`<span class="rewards">+${q.rewards.setupStringQuest} ||</span>`);
                }
                if (q.rewards?.gridRefreshStringQuest) {
                    // rewardLines.push(`+${q.rewards.gridRefreshStringQuest} makes # ${(q.rewards.gridRefreshStringQuest + q.rewards.gridRefreshBeforeStringQuest)}`);
                    rewardLines.push(`<span class="rewards"># +${q.rewards.gridRefreshStringQuest}</span>`);
                }                
                
                // if (q.rewards?.setupStringQuest || q.rewards?.gridRefreshStringQuest) {
                // rewardLines.push(`</span>`);
                // }

                //CHAIN QUEST REWARDS

                if (q.rewards?.wildcardUnlocked) {
                    rewardLines.push(`<span class="rewards">wildcard unlocked</span>`);
                } 
                
                if (q.rewards?.setupChainQuest || q.rewards?.gridRefreshChainQuest) {
                    rewardLines.push(`<span class="rewards">`);
                }
                
                if (q.rewards?.setupChainQuest) {
                    // rewardLines.push(`+${q.rewards.setupChainQuest} makes ${(q.rewards.setupBeforeChainQuest + q.rewards.setupChainQuest)} ||`);
                    rewardLines.push(`+${q.rewards.setupChainQuest} || `);
                }
                if (q.rewards?.gridRefreshChainQuest) {
                    // rewardLines.push(`+${q.rewards.gridRefreshChainQuest} makes # ${(q.rewards.gridRefreshBeforeChainQuest + q.rewards.gridRefreshChainQuest)}`);
                    rewardLines.push(`# +${q.rewards.gridRefreshChainQuest}`);
                }
                if (q.rewards?.setupChainQuest || q.rewards?.gridRefreshChainQuest) {
                rewardLines.push(`</span>`);
                }

                //WORD QUEST REWARDS
                
                // if (q.rewards?.gridExpanded || q.rewards?.lives || q.rewards?.setupWordQuest || q.rewards?.gridRefreshWordQuest) {
                //     rewardLines.push(`<span class="rewards">`);
                // }
                if (q.rewards?.gridExpanded) {
                    rewardLines.push(`<span class="rewards">4x4 unlocked</span>`);
                    // rewardLines.push(`milestones unlocked`);
                }

                if (q.rewards?.setupWordQuest) {
                    // rewardLines.push(`+${q.rewards.setupWordQuest} makes ${(q.rewards.setupBeforeWordQuest + q.rewards.setupWordQuest)} ||`);
                    rewardLines.push(`<span class="rewards">+${q.rewards.setupWordQuest} ||`);
                }
                if (q.rewards?.gridRefreshWordQuest) {
                    // rewardLines.push(`+${q.rewards.gridRefreshWordQuest} makes # ${(q.rewards.gridRefreshBeforeWordQuest + q.rewards.gridRefreshWordQuest)}`);
                    rewardLines.push(`<span class="rewards"># +${q.rewards.gridRefreshWordQuest}`);
                }
                if (q.rewards?.lives && q.rewards?.livesMaxed) {
                    // rewardLines.push(`+1 life for ${q.length} letters`);
                    rewardLines.push(`  +1 life</span><span class="rewards">max lives reached</span>`);
                }
                if (q.rewards?.lives && !(q.rewards?.livesMaxed)) {
                    // rewardLines.push(`+1 life for ${q.length} letters`);
                    rewardLines.push(`  +1 life</span>`);
                }
                // if (q.rewards?.gridExpanded || q.rewards?.lives || q.rewards?.setupWordQuest || q.rewards?.gridRefreshWordQuest) {
                // rewardLines.push(`</span>`);
                // }


                //STREAK QUEST REWARDS
                if (q.rewards?.setupStreakQuest || q.rewards?.gridRefreshStreakQuest) {
                    rewardLines.push(`<span class="rewards">`);
                }
                
                if (q.rewards?.setupStreakQuest) {
                    // rewardLines.push(`+${q.rewards.setupStreakQuest} makes ${(q.rewards.setupStreakQuest + q.rewards.setupBeforeStreakQuest)} ||`);
                    rewardLines.push(`+${q.rewards.setupStreakQuest} || `);
                }
                if (q.rewards?.gridRefreshStreakQuest) {
                    // rewardLines.push(`+${q.rewards.gridRefreshStreakQuest} makes # ${(q.rewards.gridRefreshStreakQuest + q.rewards.gridRefreshBeforeStreakQuest)}`);
                    rewardLines.push(`# +${q.rewards.gridRefreshStreakQuest}`);
                }

                if (q.rewards?.setupStreakQuest || q.rewards?.gridRefreshStreakQuest) {
                    rewardLines.push(`</span>`);
                }


                //PENALTIES
                if (q.rewards?.setupPenalty || q.rewards?.gridRefreshPenalty) {
                    rewardLines.push(`<span class="rewards2">`);
                }

                if (q.rewards?.setupPenalty) {
                    // rewardLines.push(`-${q.rewards.setupPenalty} makes ${(q.rewards.setupBeforePenalty - q.rewards.setupPenalty)} ||`);
                    rewardLines.push(`-${q.rewards.setupPenalty} || `);
                }
                if (q.rewards?.gridRefreshPenalty) {
                    // rewardLines.push(`-${q.rewards.gridRefreshPenalty} makes # ${(q.rewards.gridRefreshBeforePenalty - q.rewards.gridRefreshPenalty)}`);
                    rewardLines.push(`# -${q.rewards.gridRefreshPenalty}`);
                }
                if (q.rewards?.setupPenalty || q.rewards?.gridRefreshPenalty) {
                    rewardLines.push(`</span>`);
                }
                if (q.rewards?.livesPenalty) {
                    rewardLines.push(`<span class="rewards2">-${q.rewards.livesPenalty} life</span>`);
                }


                //MISSION QUEST REWARDS
                if (q.rewards?.setupMissionQuest || q.rewards?.gridRefreshMissionQuest) {
                    rewardLines.push(`<span class="rewards">`);
                }
                
                if (q.rewards?.setupMissionQuest) {
                    // rewardLines.push(`+${q.rewards.setupStreakQuest} makes ${(q.rewards.setupStreakQuest + q.rewards.setupBeforeStreakQuest)} ||`);
                    rewardLines.push(`+${q.rewards.setupMissionQuest} || `);
                }
                if (q.rewards?.gridRefreshMissionQuest) {
                    // rewardLines.push(`+${q.rewards.gridRefreshStreakQuest} makes # ${(q.rewards.gridRefreshStreakQuest + q.rewards.gridRefreshBeforeStreakQuest)}`);
                    rewardLines.push(`# +${q.rewards.gridRefreshMissionQuest}`);
                }

                if (q.rewards?.setupMissionQuest || q.rewards?.gridRefreshMissionQuest) {
                    rewardLines.push(`</span>`);
                }



                // --- Assemble ---
                return `
                    <p class="sq-para">
                    ${headerLine}<br>
                    ${rewardLines.length ? ` <small>${rewardLines.join("")}</small>` : ""}
                    <br><span class="sq-word">${q.word.toLowerCase()}</span>
                    </p>
                `;
            }




            function renderMilestones() {
                const merged = Object.values(
                    milestones.reduce((map, quest) => {
                        const key = `${quest.word}|${quest.chain}`;

                        if (!map[key]) {
                            map[key] = {
                                ...quest,
                                rewards: { ...quest.rewards }
                            };
                        } else {
                            // merge reasons
                            map[key].wordQuest ||= quest.wordQuest;
                            map[key].chainQuest ||= quest.chainQuest;
                            map[key].stringQuest ||= quest.stringQuest;
                            map[key].streakQuest ||= quest.streakQuest;
                            map[key].penalty ||= quest.penalty;
                            map[key].missionQuest ||= quest.missionQuest;

                            // preserve max / meaningful values
                            map[key].length = Math.max(map[key].length ?? 0, quest.length ?? 0);
                            map[key].stringMilestoneAmount = Math.max(
                                map[key].stringMilestoneAmount ?? 0,
                                quest.stringMilestoneAmount ?? 0
                            );

                            // merge rewards
                            map[key].rewards = {
                                ...map[key].rewards,
                                ...quest.rewards
                            };
                        }

                        return map;
                    }, {})
                );

                milestonesContent.innerHTML = merged
                    .reverse()
                    .map(q => renderRewards(q))
                    .join("");

                // streakinfo.innerHTML = `best no-bonus streak is ${bestNoBonusStreak} words`;
            }


            function computeOpenMissions() {
                openMissions = [];

                for (let len = 4; len <= unlockedMissionTier; len++) {
                    if (!missions[len]) continue;

                    for (const word of missions[len]) {
                    if (!completedMissions.has(word)) {
                        openMissions.push(word);
                    }
                    }
                }
            }


            function checkMission(currentWord) {
                const upper = currentWord.toUpperCase();
                const len = upper.length;

                // Must be within revealed tiers
                if (len > unlockedMissionTier) return;

                // Must exist in missions
                if (!missions[len]?.includes(upper)) return;

                // Must not already be completed
                if (completedMissions.has(upper)) return;

                // Complete it
                completedMissions.add(upper);
                console.log(`Mission completed: ${upper}`);
                messageElement.textContent = `Mission completed: ${upper}`;
                milestones.push({
                                word: currentWord,
                                missionQuest: true,
                                chain: chain,
                                string: score,
                                length: currentWord.length,
                                rewards: { setupMissionQuest: currentWord.length, 
                                    setupBeforeMissionQuest: setupMovesAvailable,
                                    gridRefreshMissionQuest: currentWord.length, 
                                    gridRefreshBeforeMissionQuest: gridRefreshBonusesAvailable }
                            });
                setupMovesAvailable = currentWord.length + setupMovesAvailable;
                gridRefreshBonusesAvailable = currentWord.length + gridRefreshBonusesAvailable;
                // Recalculate unlock condition based on highest open tier only
                const currentTierWords = missions[unlockedMissionTier];
                if (!currentTierWords) return;

                const completedInTier = currentTierWords.filter(
                    word => completedMissions.has(word)
                ).length;

                if (completedInTier / currentTierWords.length >= 0.5) {
                    unlockedMissionTier++;
                }

            }

            function renderMissions() {
                computeOpenMissions();
                missionsContent.innerHTML = "<br>";

                for (let len = unlockedMissionTier; len >= 4; len--) {
                    if (!missions[len]) continue;

                    const items = missions[len]
                        .map(word => {
                            const completed = completedMissions.has(word);
                            return `<span class="missions-display${completed ? " completed" : ""}">${word.toLowerCase()}</span>`;
                        })
                        .join(" ");

                    missionsContent.innerHTML += `
                        ${items}
                        <br><br>
                    `;
                }
            }










            // function renderMilestones() {
            //     const merged = Object.values(
            //         milestones.reduce((map, quest) => {
            //             const key = `${quest.word}|${quest.rewards}`;

            //             if (!map[key]) {
            //                 map[key] = {
            //                     ...quest,
            //                     rewards: { ...quest.rewards }
            //                 };
            //             } else {
            //                 map[key].rewards = {
            //                     ...map[key].rewards,
            //                     ...quest.rewards
            //                 };
            //             }

            //             return map;
            //         }, {})
            //     );

            //     milestonesContent.innerHTML = merged
            //         .map(q => renderRewards(q))
            //         .join("");
            // }

            function rollbackGrid() {
                const savedGridState = localStorage.getItem("stringChainState");
                const gridState = JSON.parse(savedGridState);
                grid = gridState.grid;
                gridSize = gridState.gridSize;
                // messageElement.textContent = `GRID ROLLBACK STATE: ${grid}`
                // grid = gridFallback; // ALT VERSION - ALSO NOT WORKING
                // renderGrid();
            }

            // function showDefinitions(word) {
            //     // Fetch up to first 3 definitions and show them
            //     fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)
            //         .then(res => res.json())
            //         .then(data => {
            //             if (!Array.isArray(data)) throw new Error();
            //             let defs = [];
            //             data.forEach(entry => {
            //                 entry.meanings?.forEach(meaning => {
            //                     meaning.definitions?.forEach(defObj => {
            //                         if (defs.length < 3) defs.push(defObj.definition);
            //                     });
            //                 });
            //             });
            //             definitionsElement.innerHTML = defs.length
            //                 ? `<strong>${word}</strong>:<br>${defs.map(d => `- ${d}`).join('<br>')}`
            //                 : `No definitions found for "${word}".`;
            //         })
            //         .catch(() => {
            //             definitionsElement.textContent = `No definitions found for "${word}".`;
            //         });
            // }
            //END OF CHANGING STATES


            //CORE GAMEPLAY
            function randomLetter() {
                return alphabet[Math.floor(Math.random() * alphabet.length)];
            }

            function randomWord() {
                return starterWords[Math.floor(Math.random() * starterWords.length)];
            }














            const asteriskModal = document.getElementById("asteriskModal");
            const alphaGrid = asteriskModal.querySelector(".alpha-grid");

            // Close modal if clicking outside content
            asteriskModal.addEventListener("click", (e) => {
                if (e.target === asteriskModal) {
                    pendingAsteriskCell = null;
                    asteriskModal.classList.add("hidden");
                    collapseModal.style.display = "none";
                }
            });




            let pendingAsteriskCell = null; // the cell being replaced

            // Build A–Z buttons + one asterisk
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ*?".split("");
            letters.forEach(l => {
                const btn = document.createElement("button");
                btn.textContent = l;
                if (l === "?") {
                    btn.id = "helpBtn"; // or btn.classList.add("helpBtn");
                }
                btn.addEventListener("click", () => chooseAsteriskLetter(l));
                alphaGrid.appendChild(btn);
            });

            // Called when a letter is chosen
            function chooseAsteriskLetter(letter) {
                if (!pendingAsteriskCell) return;

                if (letter === "*") {
                    // Exit: keep the bonus intact
                    pendingAsteriskCell = null;
                    asteriskModal.classList.add("hidden");
                    collapseModal.style.display = "none";
                    return;
                }


                if (letter === "?") {
                    //show basic instruction
                    if (wildcardOne.classList.contains('opacity-hide') && wildcardThree.classList.contains('hidden')) {
                        wildcardOne.classList.remove('opacity-hide');
                        wildcardTwo.classList.remove('opacity-hide');
                        helpBtn.classList.add("selected");   // when showing instructions
                        return;
                    }

                    //Show even more info
                    if (wildcardThree.classList.contains('hidden') && !(wildcardOne.classList.contains('opacity-hide'))) {
                        wildcardThree.classList.remove('hidden');
                        helpBtn.classList.add("selected");   // when showing instructions
                        return;
                    }

                    // Hide all info if already shown
                    if (!wildcardOne.classList.contains('opacity-hide') && !wildcardThree.classList.contains('hidden')) {
                        wildcardOne.classList.add('opacity-hide');
                        wildcardTwo.classList.add('opacity-hide');
                        wildcardThree.classList.add('hidden');
                        helpBtn.classList.remove("selected");   // when showing instructions
                        return;
                    }

                    // wildcardOne.classList.remove('opacity-hide');
                    // wildcardTwo.classList.remove('opacity-hide');
                    // wildcardThree.classList.remove('opacity-hide');
                    // // alphaGrid.btn.classList.add('selected');
                    // return;
                }








                // Replace board asterisk with chosen letter
                const cell = pendingAsteriskCell;
                const r = parseInt(cell.dataset.row, 10);
                const c = parseInt(cell.dataset.col, 10);

                grid[r][c] = letter;
                cell.textContent = letter;
                cell.dataset.type = "grid";

                pendingAsteriskCell = null;
                asteriskModal.classList.add("hidden");
                collapseModal.style.display = "none";
                bonusCounter++;
                bonusTicker = "*" + bonusCounter;
                playedWords.add(bonusTicker);
                updateHistory();
                bonusTicker = '';
                saveGameState();
                // Auto-select this cell after replacement
                selectCell(cell);
            }




            // Expose this function for selectCell
            function openAsteriskModal(cell) {
                topFunction();
                pendingAsteriskCell = cell;
                asteriskModal.classList.remove("hidden");
                collapseModal.style.display = "block";
            }




            function selectCell(cell) {
                // cell.classList.remove('selected');
                if (!specialModeActive) { messageElement.textContent = "" };




                // --- Handle Asterisk Bonus Early ---
                if (cell.textContent === "*") {
                    openAsteriskModal(cell);
                    return; // stop here, wait for modal choice
                }




                const type = cell.dataset.type;
                const isSelected = selected.includes(cell);
                // --- Helpers ---
                const getSelectedOfType = (t) => selected.filter(c => c.dataset.type === t);
                const deselect = (c) => {
                    c.classList.remove('selected');
                    selected = selected.filter(s => s !== c);
                };
                const updateLastSelected = () => {
                    if (selected.length === 1) {
                        lastSelectedCell = selected[0];
                        lastSelectedType = lastSelectedCell.dataset.type;
                    }
                };
                const dropFirstOf = (t) => deselect(getSelectedOfType(t)[0]);

                // --- Toggle Off ---
                if (isSelected) {
                    deselect(cell);
                    updateLastSelected();
                    return;
                }

                // --- Count current types ---
                let count = {
                    word: getSelectedOfType('word').length,
                    grid: getSelectedOfType('grid').length,
                    insert: getSelectedOfType('insert').length
                };

                // --- Determine legality and resolve conflicts ---
                if (type === 'grid') {
                    if (count.grid === 1) {
                        dropFirstOf('grid');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                        // Hard early exit from branch logic
                    } else if (count.word === 1 && count.insert === 1) {
                        dropFirstOf(lastSelectedType === 'word' ? 'insert' : 'word');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    } else if (count.word === 2) {
                        dropFirstOf('word');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    }
                }
                else if (type === 'insert') {
                    if (count.insert === 1) {
                        dropFirstOf('insert');
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    } else if (count.word === 1 && count.grid === 1) {
                        dropFirstOf(lastSelectedType === 'grid' ? 'word' : 'grid');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    } else if (count.word === 2) {
                        dropFirstOf('word');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    }
                }
                else if (type === 'word') {
                    if (count.word === 2) {
                        dropFirstOf('word');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    } else if (count.grid === 1 && count.insert === 1) {
                        dropFirstOf(lastSelectedType === 'grid' ? 'insert' : 'grid');
                        // Recalculate counts after change
                        count = {
                            word: getSelectedOfType('word').length,
                            grid: getSelectedOfType('grid').length,
                            insert: getSelectedOfType('insert').length
                        };
                    }
                }

                // --- Limit total selections to 2 ---
                if (selected.length === 2) {
                    selected.forEach(c => {
                        if (c !== lastSelectedCell) deselect(c);
                    });
                }

                // --- Finalize Selection ---
                cell.classList.add('selected');
                selected.push(cell);
                lastSelectedCell = cell;
                lastSelectedType = type;
            }


            function renderWord() {
                wordContainer.innerHTML = '';

                const insertSlotStart = document.createElement('div');
                insertSlotStart.className = 'insert-slot';
                insertSlotStart.dataset.type = 'insert';
                insertSlotStart.dataset.index = 0;

                insertSlotStart.addEventListener('click', () => selectCell(insertSlotStart));
                wordContainer.appendChild(insertSlotStart);

                for (let i = 0; i < currentWord.length; i++) {
                    const letterDiv = document.createElement('div');
                    letterDiv.className = 'letter';
                    letterDiv.textContent = currentWord[i];
                    letterDiv.dataset.type = 'word';
                    letterDiv.dataset.index = i;
                    // fitWordContainer();

                    // Highlight if selected (selected is an array of indices)

                    if (selected.includes(i)) {
                        letterDiv.classList.add('selected');
                    }

                    letterDiv.addEventListener('click', () => selectCell(letterDiv));
                    wordContainer.appendChild(letterDiv);

                    const insertSlot = document.createElement('div');
                    insertSlot.className = 'insert-slot';
                    insertSlot.dataset.type = 'insert';
                    insertSlot.dataset.index = i + 1;
                    // fitWordContainer();


                    // if (specialModeActive) insertSlot.classList.add('special');


                    if (selected.includes(i + 1)) {
                        insertSlot.classList.add('selected');
                    }

                    insertSlot.addEventListener('click', () => selectCell(insertSlot));
                    wordContainer.appendChild(insertSlot);

                }
                fitWordContainer();
            }



            function checkPlayAreaMeasurements() {
                if (gridSize == 3) {
                    cellSize = 68;
                } else if (gridSize == 4) {
                    cellSize = 49;
                }
                leftRail.style.gridTemplateRows = `repeat(${gridSize}, ${cellSize}px)`;
                rightRail.style.gridTemplateRows = `repeat(${gridSize}, ${cellSize}px)`;
                scrollBtn.style.height = `${cellSize}px`;
                missionsHelpBtn.style.height = `${cellSize}px`;
                collapseModal.style.height = `${cellSize}px`;
            }


            function renderGrid() {
                // maybePlaceAsterisk();
                gridElement.innerHTML = '';
                gridElement.style.gridTemplateRows = `repeat(${gridSize}, ${cellSize}px)`;
                gridElement.style.gridTemplateColumns = `repeat(${gridSize}, ${cellSize}px)`;
                gridElement.style.gridTemplateColumns = `repeat(${gridSize}, ${cellSize}px)`;
                gridElement.style.rowGap = 'var(--gap)';
                gridElement.style.columnGap = 'var(--gap)';

                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.textContent = grid[r][c] || '';

                        // Mark empty cells as 'used' (meaning no letter present)
                        if (!grid[r][c]) cell.classList.add('used');

                        cell.dataset.type = 'grid';
                        cell.dataset.row = r;
                        cell.dataset.col = c;


                        const cellId = `${r},${c}`;
                        if (selected.includes(cellId)) {
                            cell.classList.add('selected');
                        }


                        cell.addEventListener('click', (event) => {
                            if (cell.classList.contains("used")) {
                                event.stopPropagation(); // optional
                                return; // ignore click
                            }
                            selectCell(cell);
                        });
                        gridElement.appendChild(cell);
                    }
                }
            }

            function initGrid() {
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        // If cell is not already an asterisk, replace it with a new letter
                        if (grid[r] && grid[r][c] === "*" && chain > 0) {
                            continue; // keep existing bonus
                        }
                        if (!grid[r]) grid[r] = [];
                        grid[r][c] = randomLetter();
                    }
                }
                renderGrid();
                gridFallback = grid;
            }

            //#region replenishGrid Function working

            // function replenishGrid() {
            //     for (let r = 0; r < gridSize; r++) {
            //         if (grid[r].every(cell => cell === null)) {
            //             for (let c = 0; c < gridSize; c++) {
            //                 grid[r][c] = randomLetter();
            //             }
            //         }
            //     }

            //     for (let c = 0; c < gridSize; c++) {
            //         if (grid.every(row => row[c] === null)) {
            //             for (let r = 0; r < gridSize; r++) {
            //                 grid[r][c] = randomLetter();
            //             }
            //         }
            //     }

            //     if (currentWord.length >= 6 && gridSize === 3 && !specialModeActive) {
            //         const oldGrid = grid.map(row => row.slice()); // copy current 3x3

            //         // Build new 4x4 grid, start as null
            //         const newSize = 4;
            //         const newGrid = Array.from({ length: newSize }, () => Array(newSize).fill(null));

            //         // Preserve existing letters/empties in top-left 3x3
            //         for (let r = 0; r < 3; r++) {
            //             for (let c = 0; c < 3; c++) {
            //                 newGrid[r][c] = oldGrid[r][c]; // may be a letter or null
            //             }
            //         }

            //         // Refresh ONLY the used cells (nulls) inside the original 3x3
            //         for (let r = 0; r < 3; r++) {
            //             for (let c = 0; c < 3; c++) {
            //                 if (newGrid[r][c] === null) {
            //                     newGrid[r][c] = randomLetter();
            //                 }
            //             }
            //         }

            //         // Populate the new right column (c = 3) and bottom row (r = 3)
            //         for (let r = 0; r < 4; r++) newGrid[r][3] = randomLetter();
            //         for (let c = 0; c < 4; c++) newGrid[3][c] = randomLetter();

            //         // Commit expansion
            //         gridSize = 4;
            //         grid = newGrid;
            //     }

            //     renderGrid();
            // }

            //#endregion


            // Track earned bonuses

            function checkAsteriskBonus(chain) {
                if (chain >= 128) {
                    // Calculate the most recent threshold
                    const threshold = 128 + Math.floor((chain - 128) / 32) * 32;
                    // const threshold = Math.floor((chain) / 5) * 5; //test mode
                    if (threshold > lastAsteriskThreshold) {
                        asteriskEarned++;
                        lastAsteriskThreshold = threshold;
                    }
                }
            }

            function maybePlaceAsterisk(refreshedCells) {
                if (asteriskEarned > 0 && refreshedCells.length > 0) {
                    const [r, c] = refreshedCells[Math.floor(Math.random() * refreshedCells.length)];
                    grid[r][c] = "*";
                    asteriskEarned--;
                }
            }

            function replenishGrid() {
                let refreshedCells = [];

                // Refill empty rows
                for (let r = 0; r < gridSize; r++) {
                    if (grid[r].every(cell => cell === null)) {
                        for (let c = 0; c < gridSize; c++) {
                            grid[r][c] = randomLetter();
                            refreshedCells.push([r, c]);
                        }
                    }
                }

                // Refill empty columns
                for (let c = 0; c < gridSize; c++) {
                    if (grid.every(row => row[c] === null)) {
                        for (let r = 0; r < gridSize; r++) {
                            grid[r][c] = randomLetter();
                            refreshedCells.push([r, c]);
                        }
                    }
                }

                // Place asterisk if earned
                maybePlaceAsterisk(refreshedCells);

                // Handle 3x3 → 4x4 expansion
                if (currentWord.length >= 6 && gridSize === 3 && !specialModeActive) {
                    const oldGrid = grid.map(row => row.slice());
                    const newSize = 4;
                    const newGrid = Array.from({ length: newSize }, () => Array(newSize).fill(null));

                    // Preserve old 3x3
                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            newGrid[r][c] = oldGrid[r][c];
                        }
                    }

                    // Refill used/nulls inside old 3x3
                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            if (newGrid[r][c] === null) {
                                newGrid[r][c] = randomLetter();
                                refreshedCells.push([r, c]);
                            }
                        }
                    }

                    // Populate new row + col
                    for (let r = 0; r < 4; r++) {
                        newGrid[r][3] = randomLetter();
                        refreshedCells.push([r, 3]);
                    }
                    for (let c = 0; c < 4; c++) {
                        newGrid[3][c] = randomLetter();
                        refreshedCells.push([3, c]);
                    }

                    gridSize = 4;
                    grid = newGrid;
                    checkPlayAreaMeasurements();
                    // missionsBtn.classList.remove("span-0");
                    if (chain < 32) { missionsBtn.classList.add("opacity-hide"); missionsBtn.classList.remove("hidden");}
                    // dummyBtn3.classList.remove("span-0");
                    gridRefreshBtn.classList.add("span-2");

                    playedWords.add("(4x4)");
                    updateHistory();
                    milestonesBtn.classList.remove("hidden");
                    // missionsBtn.classList.remove("hidden");
                    missionsBtn.classList.remove("span-0");

                    wordLengthMilestones.splice(0, 1);
                    milestones.push({
                            word: currentWord,
                            wordQuest: true,
                            chain: chain,
                            length: currentWord.length,
                            rewards: { gridExpanded: true }
                        });
                    // milestonesSummary +=
                    //     `<p><small><small><small>4x4 grid unlocked for 6+ letters: <span style="font-family: 'Courier New', monospace;">${currentWord.toLowerCase()}</span></small></small></small><br>`;

                    // Place asterisk if earned (again for expansion refresh)
                    maybePlaceAsterisk(refreshedCells);
                }
                saveGameState();
                renderGrid();
            }



















            function clearSelection() {
                selected.forEach(s => s.classList.remove('selected'));
                selected = [];
            }


            function applyMove() {
                if (selected.length === 0) return false;
                let moveHappened = false;

                if (selected.length === 1 && selected[0].dataset.type === 'word') {
                    const idx = parseInt(selected[0].dataset.index);
                    currentWord = currentWord.slice(0, idx) + currentWord.slice(idx + 1);
                    moveHappened = true;
                } else if (selected.length === 2) {
                    const types = selected.map(s => s.dataset.type);
                    if (types.includes('grid') && types.includes('word')) {
                        const gridCell = selected.find(s => s.dataset.type === 'grid');


                        const wordCell = selected.find(s => s.dataset.type === 'word');
                        const idx = parseInt(wordCell.dataset.index);
                        currentWord = currentWord.slice(0, idx) + gridCell.textContent + currentWord.slice(idx + 1);
                        grid[gridCell.dataset.row][gridCell.dataset.col] = null;
                        moveHappened = true;
                    } else if (types.every(t => t === 'word')) {
                        const [a, b] = selected.map(s => parseInt(s.dataset.index));
                        let arr = currentWord.split('');
                        [arr[a], arr[b]] = [arr[b], arr[a]];
                        currentWord = arr.join('');
                        moveHappened = true;
                    } else if (types.includes('grid') && types.includes('insert')) {
                        const gridCell = selected.find(s => s.dataset.type === 'grid');


                        const insertSlot = selected.find(s => s.dataset.type === 'insert');
                        const pos = parseInt(insertSlot.dataset.index);
                        let arr = currentWord.split('');
                        arr.splice(pos, 0, gridCell.textContent);
                        currentWord = arr.join('');
                        grid[gridCell.dataset.row][gridCell.dataset.col] = null;
                        moveHappened = true;
                    } else if (types.includes('word') && types.includes('insert')) {
                        const wordCell = selected.find(s => s.dataset.type === 'word');
                        const insertSlot = selected.find(s => s.dataset.type === 'insert');
                        let fromIdx = parseInt(wordCell.dataset.index);
                        let toIdx = parseInt(insertSlot.dataset.index);
                        if (fromIdx < toIdx) toIdx--;
                        let arr = currentWord.split('');
                        let [char] = arr.splice(fromIdx, 1);
                        arr.splice(toIdx, 0, char);
                        currentWord = arr.join('');
                        moveHappened = true;


                    }
                }
                return moveHappened;
            }


            function validateWord(previousWord) {
                const lower = currentWord.toLowerCase();
                if (playedWords.has(lower)) {
                    messageElement.textContent = `${currentWord} already used!`;
                    highlightPlayed(currentWord);
                    rollbackGrid();
                    alreadyUsedAnimation();
                    activateSpecialMode();
                    currentWord = previousWord;
                    renderWord();
                    // grid = gridFallback;
                    // renderGrid();
                    showTemporaryMessage();
                    saveGameState();
                    return;
                }

                if (
                    starterWords.includes(currentWord.toUpperCase()) ||
                    allowList.includes(currentWord.toUpperCase()) ||
                    LOCAL_WORDS.has(lower)
                ) {
                    playedWords.add(lower);
                    updateHistory();
                    lastValidWord = currentWord;
                    score += currentWord.length;
                    chain++;
                    checkAsteriskBonus(chain);

                    //THIS LOGIC DISABLED FOR NOW. ADDITIONAL BONUSES FOR MILESTONES ONLY
                    // if ((chain % 5 === 0) && chain > 4) {
                    //     setupMovesAvailable++;
                    //     updateBonusButton();
                    //     bonusAnimation();
                    // }
                    // if (Math.floor(score / 30) > Math.floor((score - currentWord.length) / 30) && score > 29) {
                    //     gridRefreshBonusesAvailable++;
                    //     updateGridRefreshButton();
                    //     gridRefreshAnimation();
                    // }

                    scoreElement.textContent = score;
                    chainElement.textContent = chain;
                    if (chain != 1) { messageElement.textContent = "Valid word!" }; //FROM LOCAL LIST
                    showTemporaryMessage();
                    clearSpecialMode(); // Nov 4 EDIT
                    greenAnimation();
                    playAnimation();
                    // showDefinitions(lower);
                    replenishGrid();
                    historyElement.scrollTo({ top: 0, behavior: 'smooth' });
                    gridFallback = grid;
                    noBonusStreak++;
                    bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                    consecutiveBonuses = 0;
                    updateMilestones();
                    updateAllTimeStats();
                    updateStatus();
                    checkMission(currentWord);
                    saveGameState();
                    return;
                }

                fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${lower}`)

                // fetch(`https://en.wiktionary.org/w/api.php?action=parse&page=${lower}&prop=wikitext&format=json&origin=*`)
                    // fetch(`https://cors.isomorphic-git.org/https://api.dictionaryapi.dev/api/v2/entries/en/${lower}`)
                    .then(res => {
                        if (!res.ok) throw new Error();
                        return res.json();
                    })
                    .then(() => {
                        playedWords.add(lower);
                        updateHistory();
                        lastValidWord = currentWord;
                        score += currentWord.length;
                        chain++;
                        checkAsteriskBonus(chain);
                        //THIS LOGIC DISABLED FOR NOW. ADDITIONAL BONUSES FOR MILESTONES ONLY
                        // if ((chain % 5 === 0) && chain > 4) {
                        //     setupMovesAvailable++;
                        //     updateBonusButton();
                        //     bonusAnimation();
                        // }
                        // if (Math.floor(score / 30) > Math.floor((score - currentWord.length) / 30) && score > 29) {
                        //     gridRefreshBonusesAvailable++;
                        //     updateGridRefreshButton();
                        //     gridRefreshAnimation();
                        // }
                        scoreElement.textContent = score;
                        chainElement.textContent = chain;
                        messageElement.textContent = "Yes, valid word!";
                        sa_event(() => "api_" + currentWord); //LOG API-VALIDATED WORDS (NOT ON LOCAL LIST)
                        clearSpecialMode(); // SEP 1 EDIT
                        greenAnimation();
                        playAnimation();
                        // showDefinitions(lower);
                        replenishGrid();
                        historyElement.scrollTo({ top: 0, behavior: 'smooth' });
                        gridFallback = grid;
                        noBonusStreak++;
                        bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                        consecutiveBonuses = 0;
                        updateMilestones();
                        updateAllTimeStats();
                        updateStatus();
                        checkMission(currentWord);
                        saveGameState();
                        showTemporaryMessage();
                        return;
                    })
                    .catch(() => {
                        livesLost++;

                        noBonusStreak = 0;
                        sa_event(() => "invalid_" + currentWord); //LOG INVALID WORDS
                        // let penalty = currentWord.length * livesLost;
                        milestones.push({
                                word: `(${currentWord})`,
                                penalty: true,
                                penaltyNumber: livesLost,
                                penaltyReason: 'invalid word',
                                chain: chain,
                                length: currentWord.length,
                                rewards: { 
                                    setupPenalty: Math.floor(0.5 * setupMovesAvailable),
                                    setupBeforePenalty: setupMovesAvailable,
                                    gridRefreshPenalty: Math.floor(0.5 * gridRefreshBonusesAvailable),
                                    gridRefreshBeforePenalty: gridRefreshBonusesAvailable,
                                    livesPenalty: 1
                                }
                            });
                        updateStatus();
                        setupMovesAvailable -= Math.floor(0.5 * setupMovesAvailable);
                        gridRefreshBonusesAvailable -= Math.floor(0.5 * gridRefreshBonusesAvailable);

                        playedWords.add(lower + `(-` + livesLost + `)`);

                        // bestNoBonusStreak = Math.max(bestNoBonusStreak, noBonusStreak);
                        // noBonusStreak = 0;
                        updateHistory();
                        messageElement.textContent = currentWord + `, unknown word`;
                        currentWord = lastValidWord;
                        renderWord();
                        rollbackGrid();
                        // grid = gridFallback;
                        // renderGrid();
                        updateBonusButton();
                        updateGridRefreshButton();
                        redAnimation();


                        if (livesLost >= totalLives) {
                            messageElement.textContent += ", GAME OVER.";
                            saveHighScore();
                            disableGame();
                            saveGameState();
                        }
                        scoreElement.textContent = score;
                        chainElement.textContent = chain;

                        // updateStatus();
                        // updateDisallowedWords();
                        saveGameState();
                        showTemporaryMessage();
                    });
            }

            function completeMove(validate = true) {
                let originalWord = currentWord;
                let moved = applyMove();
                clearSelection();
                renderWord();
                if (!moved) {
                    messageElement.textContent = "Not a valid move. Click + for guidance"; //MAX 42 chars
                    showTemporaryMessage();
                    return;
                }
                if (validate) validateWord(originalWord);
                // clearSpecialMode();
                // replenishGrid();
            }
            //END OF CORE GAMEPLAY
            loadGameState();




        </script>


        <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>

</html>
